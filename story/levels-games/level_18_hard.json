{
  "$schema": "./level-game.schema.json",
  "id": "level_18_hard",
  "tier": "tier_5",
  "title": "Sequence Detector (101)",
  "objective": "Detect the pattern 101",
  "description": "Build an FSM that outputs 1 when it detects the sequence '101' in a serial input stream. The detector should be overlapping (can immediately start detecting the next sequence).",
  "introText": "SEQUENCE DETECTORS are classic FSM problems used in communication protocols, pattern matching, and security systems. To detect '101', you need states: S0 (initial), S1 (seen '1'), S10 (seen '10'), and output 1 when in S10 and input is '1'. Overlapping means after detecting 101, if the next bit is 0, you're already in state S10 (the final '1' starts a new potential '101').",
  "physicsVisual": "sequence_detector",
  "hint": "States: S0→(1)→S1→(0)→S10→(1)→S0+OUTPUT. Use 2 D-FFs for 3 states. Output = Q1·Q0'·Input (in state S10 and input=1). This is a Mealy machine: output depends on current state AND input.",
  "availableGates": [
    "transistor",
    "not",
    "and",
    "or",
    "nand",
    "nor",
    "xor",
    "mux2to1",
    "srLatch",
    "dFlipFlop"
  ],
  "inputs": 2,
  "targetSequence": [
    {
      "in": [
        0,
        0
      ],
      "out": [
        0
      ],
      "desc": "CLK=0, In=0: Start in S0"
    },
    {
      "in": [
        1,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK↑, In=1: S0→S1"
    },
    {
      "in": [
        0,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK=0, In=0: Setup"
    },
    {
      "in": [
        0,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK↑, In=0: S1→S10"
    },
    {
      "in": [
        1,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK=0, In=1: Setup"
    },
    {
      "in": [
        1,
        1
      ],
      "out": [
        1
      ],
      "desc": "CLK↑, In=1: DETECTED 101! Output=1, →S1"
    },
    {
      "in": [
        0,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK=0, In=0: Setup"
    },
    {
      "in": [
        0,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK↑, In=0: S1→S10"
    },
    {
      "in": [
        1,
        1
      ],
      "out": [
        0
      ],
      "desc": "CLK=0, In=1: Setup"
    },
    {
      "in": [
        1,
        1
      ],
      "out": [
        1
      ],
      "desc": "CLK↑, In=1: DETECTED 101 again!"
    }
  ],
  "maxGates": 8,
  "xpReward": 250,
  "storyText": "FSM DESIGN METHODOLOGY: (1) Draw state diagram, (2) Create state table, (3) Choose state encoding, (4) Derive next-state equations, (5) Implement with flip-flops and logic. This systematic approach scales from traffic lights to CPU control units.",
  "physicsDetails": {
    "conceptCards": [
      {
        "term": "Finite State Machine (FSM)",
        "definition": "A computational model with a finite number of states, transitions between states based on inputs, and outputs determined by state (and possibly inputs).",
        "why": "FSMs are the foundation of sequential logic design—they model any system with memory and defined behaviors.",
        "analogy": "Like a board game: you're always on one square (state), dice rolls (inputs) determine your next square, and the square determines what happens (output).",
        "latex": "FSM = (States, Inputs, Outputs, Transitions)",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">FSM</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>",
        "visuals": [
          {
            "type": "fsm_traffic",
            "title": "FSM: State → Outputs"
          }
        ]
      },
      {
        "term": "Moore Machine",
        "definition": "An FSM where outputs depend ONLY on the current state, not on inputs. Outputs are 'attached' to states.",
        "why": "Moore machines have stable, glitch-free outputs that change only on clock edges.",
        "analogy": "Like traffic light colors: the light color depends on which state you're in, not on what cars are doing.",
        "latex": "Output = f(State)",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>",
        "visuals": [
          {
            "type": "decoder",
            "title": "State Decode to Outputs"
          }
        ]
      },
      {
        "term": "Mealy Machine",
        "definition": "An FSM where outputs depend on both current state AND current inputs. Outputs are 'attached' to transitions.",
        "why": "Mealy machines can respond faster (within the same clock cycle as input) but may have glitchy outputs.",
        "analogy": "Like a vending machine: what it dispenses depends on current state AND what button you press.",
        "latex": "Output = f(State, Input)",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>",
        "visuals": [
          {
            "type": "multiplexer",
            "title": "State+Input → Output MUX"
          }
        ]
      },
      {
        "term": "State Encoding",
        "definition": "The binary representation chosen for each state. Options: binary (minimum FFs), one-hot (one FF per state), Gray code (minimal transitions).",
        "why": "Encoding affects circuit complexity, speed, and power consumption.",
        "analogy": "Like numbering seats in a theater: you can use row+seat, sequential numbers, or coordinates.",
        "visuals": [
          {
            "type": "sr_latch",
            "title": "Storage: FFs Hold State"
          }
        ],
        "latex": "Binary: ceil(log_{2}N) FFs. One-hot: N FFs.",
        "html": null
      }
    ],
    "formulaCards": [
      {
        "name": "Ceiling Function",
        "latex": "⌈x⌉ = smallest integer ≥ x",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">⌉</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">es</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>",
        "variables": [
          {
            "symbol": "⌈x⌉",
            "meaning": "Ceiling of x - round up to next integer",
            "units": "integer"
          },
          {
            "symbol": "x",
            "meaning": "Any real number",
            "units": "real"
          }
        ],
        "meaning": "Always rounds UP. Used when you need 'at least' a certain number (like flip-flops for states).",
        "derivation": "Examples: ⌈1.1⌉=2, ⌈2.0⌉=2, ⌈2.9⌉=3. If x is not a whole number, go to the next whole number above.",
        "example": {
          "problem": "How many bits needed to represent 5 states?",
          "given": [
            "States = 5",
            "Bits = ⌈log₂(5)⌉"
          ],
          "steps": [
            "log_{2}(5) ≈ 2.32",
            "⌈2.32⌉ = 3",
            "3 bits can represent 2³=8 values (≥5)"
          ],
          "answer": "3 bits needed"
        }
      },
      {
        "name": "State Count vs Flip-Flops",
        "variables": [
          {
            "symbol": "FFs",
            "meaning": "Number of flip-flops needed",
            "units": "count"
          },
          {
            "symbol": "States",
            "meaning": "Number of states in FSM",
            "units": "count"
          },
          {
            "symbol": "⌈x⌉",
            "meaning": "Ceiling function (round up)",
            "units": ""
          }
        ],
        "meaning": "For binary encoding, you need enough flip-flops to represent all states in binary.",
        "derivation": "n flip-flops can represent 2ⁿ states. Need smallest n where 2ⁿ ≥ States.",
        "example": {
          "problem": "How many flip-flops for a traffic light (3 states)?",
          "given": [
            "States = 3 (GREEN, YELLOW, RED)"
          ],
          "steps": [
            "FFs = ⌈log_{2}(3)⌉",
            "log_{2}(3) ≈ 1.58",
            "⌈1.58⌉ = 2"
          ],
          "answer": "2 flip-flops (can represent 4 states, we use 3)"
        },
        "latex": "FFs = ⌈log_{2}(States)⌉",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">FF</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mclose\">)⌉</span></span></span></span>"
      },
      {
        "name": "Traffic Light State Encoding",
        "latex": "GREEN=00, YELLOW=01, RED=10",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">GREEN</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">00</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">LL</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">01</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">RE</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span>",
        "variables": [
          {
            "symbol": "S_{1}S_{0}",
            "meaning": "Two-bit state encoding",
            "units": "binary"
          },
          {
            "symbol": "00",
            "meaning": "GREEN state",
            "units": ""
          },
          {
            "symbol": "01",
            "meaning": "YELLOW state",
            "units": ""
          },
          {
            "symbol": "10",
            "meaning": "RED state",
            "units": ""
          }
        ],
        "meaning": "Each state is assigned a unique binary code. The sequence is GREEN→YELLOW→RED→GREEN.",
        "derivation": "With 2 FFs, we have codes 00,01,10,11. We use 00,01,10 and treat 11 as don't-care or reset to 00.",
        "example": {
          "problem": "What's the next state from YELLOW (01)?",
          "given": [
            "Current state = 01 (YELLOW)"
          ],
          "steps": [
            "Sequence: GREEN(00)→YELLOW(01)→RED(10)→GREEN(00)",
            "After 01 comes 10"
          ],
          "answer": "Next state = 10 (RED)"
        }
      },
      {
        "name": "Next State Logic (Mod-3 Counter)",
        "variables": [
          {
            "symbol": "S_{1}, S_{0}",
            "meaning": "Current state bits",
            "units": "Logic level"
          },
          {
            "symbol": "S_{1,\\text{next}}, S_{0,\\text{next}}",
            "meaning": "Next state bits",
            "units": "Logic level"
          }
        ],
        "meaning": "These equations implement the state transition 00→01→10→00 (cycling through 3 states).",
        "derivation": "From state table: 00→01 (S₁:0→0, S₀:0→1), 01→10 (S₁:0→1, S₀:1→0), 10→00 (S₁:1→0, S₀:0→0).",
        "example": {
          "problem": "Calculate next state from GREEN (S₁=0, S₀=0).",
          "given": [
            "S₁ = 0",
            "S₀ = 0"
          ],
          "steps": [
            "S_{1,\\text{next}} = S_{0}\\cdot\\bar{S}_{1} = 0\\cdot1 = 0",
            "S_{0,\\text{next}} = \\bar{S}_{0}\\cdot\\bar{S}_{1} = 1\\cdot1 = 1",
            "Next state = 01"
          ],
          "answer": "01 (YELLOW) - correct transition from GREEN"
        },
        "latex": "S_{1,\\text{next}} = S_{0}\\cdot\\bar{S}_{1}, S_{0,\\text{next}} = \\bar{S}_{0}\\cdot\\bar{S}_{1}",
        "html": null
      }
    ],
    "exercises": [
      {
        "question": "How many flip-flops for a 5-state FSM using binary encoding?",
        "hint": "FFs = ⌈log₂(5)⌉. What's the smallest n where 2ⁿ ≥ 5?",
        "answer": "3 flip-flops (2³ = 8 ≥ 5, but 2² = 4 < 5)"
      },
      {
        "question": "In one-hot encoding, how many flip-flops for a 5-state FSM?",
        "hint": "One-hot uses one FF per state.",
        "answer": "5 flip-flops (states: 00001, 00010, 00100, 01000, 10000)"
      },
      {
        "question": "Design a mod-4 counter (states 00→01→10→11→00). What's the next-state equation for S₁?",
        "hint": "S₁ toggles when S₀ is 1 (going from x1 to y0).",
        "answer": "S₁_next = S₁ ⊕ S₀ (toggle S₁ when S₀=1)"
      }
    ],
    "realWorld": {
      "context": "FSMs control everything from traffic lights to TCP/IP connections to CPU instruction decoders.",
      "example": "TCP state machine: CLOSED→LISTEN→SYN_RCVD→ESTABLISHED→FIN_WAIT→CLOSED. ARM Cortex-M instruction decoder uses ~50 states.",
      "numbers": "A modern CPU control unit might have thousands of states. FPGA implementations can handle millions of state transitions per second.",
      "connection": "This level teaches systematic FSM design—the methodology used to design any sequential control system."
    }
  }
}