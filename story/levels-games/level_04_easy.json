{
  "$schema": "./level-game.schema.json",
  "id": "level_04_easy",
  "tier": "tier_1",
  "title": "AND Gate",
  "objective": "Both inputs must be HIGH",
  "description": "Output 1 only if Input A AND Input B are 1.",
  "introText": "The AND gate outputs HIGH only when ALL its inputs are HIGH. Think of it as a series of requirements—everything must be true for the output to be true. Physically, this is like switches in series: current only flows if every switch is closed.",
  "physicsVisual": "series_circuit_detailed",
  "hint": "Connect both inputs to the AND gate.",
  "availableGates": [
    "transistor",
    "not",
    "and"
  ],
  "inputs": 2,
  "targetTruthTable": [
    {
      "in": [
        0,
        0
      ],
      "out": [
        0
      ]
    },
    {
      "in": [
        0,
        1
      ],
      "out": [
        0
      ]
    },
    {
      "in": [
        1,
        0
      ],
      "out": [
        0
      ]
    },
    {
      "in": [
        1,
        1
      ],
      "out": [
        1
      ]
    }
  ],
  "maxGates": 1,
  "xpReward": 25,
  "storyText": "You've mastered the AND gate—the 'both must agree' gate. AND gates are everywhere in computing: checking if multiple conditions are true, masking specific bits in data, controlling when actions should happen. Combined with OR and NOT, AND can express any Boolean function.",
  "physicsDetails": {
    "conceptCards": [
      {
        "term": "Series Circuit",
        "definition": "Components connected end-to-end so current must flow through ALL of them. If any component fails (opens), the entire current path breaks.",
        "why": "A series circuit is a direct physical analogy for AND logic: current can only flow (output = 1) if every switch in the chain is closed. If even one switch is open, the path is broken and no current flows (output = 0). This means all conditions must be true for the result to be true—just like AND logic in electronics and computing.",
        "analogy": "Like a chain of doors you must pass through—if ANY door is locked, you can't reach the end.",
        "visuals": [
          {
            "type": "series_circuit_detailed",
            "title": "Series Path: AND (Both Must Conduct)"
          }
        ]
      },
      {
        "term": "Boolean AND Operation",
        "definition": "A logical operation that outputs TRUE (1) only when ALL inputs are TRUE. Written as A·B, A∧B, or A AND B.",
        "why": "AND is one of three fundamental operations (with OR and NOT) that can express any computable function. It's essential for decision-making in circuits.",
        "latex": "Y = A \\cdot B",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
      },
      {
        "term": "Truth Table",
        "definition": "A table listing ALL possible input combinations and their corresponding outputs. For n inputs, there are 2^n rows.",
        "why": "Truth tables completely define a logic function. They're the specification that your circuit must match. For AND with 2 inputs: 4 rows (00→0, 01→0, 10→0, 11→1).",
        "analogy": "Like a lookup table: given inputs, look up the correct output."
      },
      {
        "term": "Basic Logic Gate Truth Tables",
        "definition": "Complete truth tables for the fundamental logic gates that form the foundation of all digital circuits.",
        "why": "These six gates (AND, OR, NOT, NAND, NOR, XOR) can express any Boolean function. Their truth tables are the building blocks for understanding and designing digital logic.",
        "tables": {
          "AND": {
            "symbol": "∧",
            "alt_symbols": [
              "·",
              "&"
            ],
            "table": [
              {
                "A": 0,
                "B": 0,
                "Y": 0
              },
              {
                "A": 0,
                "B": 1,
                "Y": 0
              },
              {
                "A": 1,
                "B": 0,
                "Y": 0
              },
              {
                "A": 1,
                "B": 1,
                "Y": 1
              }
            ]
          },
          "OR": {
            "symbol": "∨",
            "alt_symbols": [
              "+"
            ],
            "table": [
              {
                "A": 0,
                "B": 0,
                "Y": 0
              },
              {
                "A": 0,
                "B": 1,
                "Y": 1
              },
              {
                "A": 1,
                "B": 0,
                "Y": 1
              },
              {
                "A": 1,
                "B": 1,
                "Y": 1
              }
            ]
          },
          "NOT": {
            "symbol": "¬",
            "alt_symbols": [
              "~",
              "′"
            ],
            "table": [
              {
                "A": 0,
                "Y": 1
              },
              {
                "A": 1,
                "Y": 0
              }
            ]
          },
          "NAND": {
            "symbol": "⊼",
            "alt_symbols": [
              "↑"
            ],
            "table": [
              {
                "A": 0,
                "B": 0,
                "Y": 1
              },
              {
                "A": 0,
                "B": 1,
                "Y": 1
              },
              {
                "A": 1,
                "B": 0,
                "Y": 1
              },
              {
                "A": 1,
                "B": 1,
                "Y": 0
              }
            ]
          },
          "NOR": {
            "symbol": "⊽",
            "alt_symbols": [
              "↓"
            ],
            "table": [
              {
                "A": 0,
                "B": 0,
                "Y": 1
              },
              {
                "A": 0,
                "B": 1,
                "Y": 0
              },
              {
                "A": 1,
                "B": 0,
                "Y": 0
              },
              {
                "A": 1,
                "B": 1,
                "Y": 0
              }
            ]
          },
          "XOR": {
            "symbol": "⊕",
            "alt_symbols": [
              "⊻"
            ],
            "table": [
              {
                "A": 0,
                "B": 0,
                "Y": 0
              },
              {
                "A": 0,
                "B": 1,
                "Y": 1
              },
              {
                "A": 1,
                "B": 0,
                "Y": 1
              },
              {
                "A": 1,
                "B": 1,
                "Y": 0
              }
            ]
          }
        }
      },
      {
        "term": "Bit Masking",
        "definition": "A technique using bitwise operations to manipulate individual bits within binary data. AND masks extract bits, OR masks set bits, XOR masks toggle bits, and shifts move bit positions.",
        "why": "Bit masking is fundamental to digital systems: CPUs use it for data extraction, flag management, and arithmetic. It's the hardware implementation of bitwise operators in programming languages, enabling efficient data manipulation at the transistor level.",
        "operations": {
          "AND (&)": {
            "purpose": "Extract or clear specific bits",
            "example": "data & mask keeps bits where mask=1, clears where mask=0",
            "use_case": "Extracting fields from packed data structures"
          },
          "AND for checking": {
            "purpose": "Check if a specific bit is set (1) at a position",
            "example": "If (data & mask) is not zero, the bit was 1; if zero, the bit was 0.",
            "use_case": "Testing flags, conditions, or extracting a single bit value"
          },
          "OR (|)": {
            "purpose": "Set specific bits to 1",
            "example": "data | mask forces bits to 1 where mask=1",
            "use_case": "Setting flags or combining bit fields"
          },
          "OR for masking": {
            "purpose": "Ensure certain bits are set to 1 regardless of their previous value",
            "example": "data | mask sets bits to 1 where mask=1, leaves others unchanged.",
            "use_case": "Turning on features, combining options"
          },
          "XOR (^)": {
            "purpose": "Toggle specific bits",
            "example": "data ^ mask flips bits where mask=1",
            "use_case": "Error detection (parity) and encryption"
          },
          "XOR for masking": {
            "purpose": "Flip (toggle) bits at specific positions",
            "example": "data ^ mask changes bits from 0 to 1 or 1 to 0 where mask=1.",
            "use_case": "Toggling options, switching states"
          },
          "NOT (~)": {
            "purpose": "Invert all bits",
            "example": "~data flips every bit (0→1, 1→0)",
            "use_case": "Two's complement negation and bit inversion"
          },
          "SHIFT (<<, >>)": {
            "purpose": "Move bits left or right",
            "example": "data << n multiplies by 2^n, data >> n divides by 2^n",
            "use_case": "Multiplication/division by powers of 2, bit field positioning"
          }
        },
        "explanation": "Bit masking uses bitwise operations to manipulate or check individual bits. To check if a specific bit is set, use AND with a mask that has a 1 in the target position. If the result is not zero, that bit was 1; if zero, the bit was 0. OR can be used to force bits to 1, and XOR can be used to toggle bits. NOT inverts all bits. SHIFT moves bits left or right. These operations are essential for controlling and reading individual bits in digital systems.",
        "formulas": {
          "AND (&)": "result = data & mask; e.g., 10110101 & 00010000 = 00010000 (extracts bit 4)",
          "OR (|)": "result = data | mask; e.g., 10110101 | 00010000 = 10110101 (sets bit 4 to 1)",
          "XOR (^)": "result = data ^ mask; e.g., 10110101 ^ 00010000 = 10100101 (toggles bit 4)",
          "NOT (~)": "result = ~data; e.g., ~10110101 = 01001010 (inverts all bits)",
          "SHIFT LEFT (<<)": "result = data << n; e.g., 10110101 << 1 = 01101010 (shifts left by 1, multiplies by 2)",
          "SHIFT RIGHT (>>)": "result = data >> n; e.g., 10110101 >> 1 = 01011010 (shifts right by 1, divides by 2)"
        },
        "applications": [
          "Extracting specific bits from registers or memory",
          "Setting/clearing status flags in CPU control registers",
          "Implementing arithmetic operations (multiplication by powers of 2)",
          "Data compression and encoding schemes",
          "Hardware-level encryption and error correction"
        ],
        "hardware_connection": "Every bitwise operation corresponds to parallel logic gates operating on each bit simultaneously. An 8-bit AND operation uses 8 AND gates in parallel, executing in a single clock cycle.",
        "latex": "bit = (data AND mask)",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>"
      },
      {
        "term": "SI Prefixes for Time",
        "definition": "Standard prefixes for small time units: ms (milli) = 10⁻³s, μs (micro) = 10⁻⁶s, ns (nano) = 10⁻⁹s, ps (pico) = 10⁻¹²s.",
        "why": "Modern circuits switch in nanoseconds or picoseconds. 1 GHz = 1 ns period. Understanding these scales is essential for timing analysis.",
        "latex": "1 second = 10³ ms = 10⁶ μs = 10⁹ ns = 10¹² ps",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\">seco</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">12</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span></span></span></span>"
      }
    ],
    "formulaCards": [
      {
        "name": "Series Resistance",
        "variables": [
          {
            "symbol": "R_{total}",
            "meaning": "Total resistance of series combination",
            "units": "Ohms (Ω)"
          },
          {
            "symbol": "R_{1}, R_{2}",
            "meaning": "Individual resistor values",
            "units": "Ohms (Ω)"
          }
        ],
        "meaning": "In series, resistances ADD. More resistors in series = harder for current to flow = higher total resistance.",
        "example": {
          "problem": "Three resistors of 100Ω, 220Ω, and 330Ω are in series. What is the total resistance?",
          "given": [
            "R₁ = 100Ω",
            "R₂ = 220Ω",
            "R₃ = 330Ω"
          ],
          "steps": [
            "R_{total} = R_{1} + R_{2} + R_{3}",
            "R_{total} = 100 + 220 + 330 = 650Ω"
          ],
          "answer": "650Ω"
        },
        "latex": "R_{total} = R_{1} + R_{2} + R_{3} + \\ldots",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.123em;\"></span><span class=\"minner\">…</span></span></span></span>"
      },
      {
        "name": "Propagation Delay",
        "variables": [
          {
            "symbol": "t_{pd}",
            "meaning": "Propagation delay (time for output to change)",
            "units": "seconds"
          },
          {
            "symbol": "R_{on}",
            "meaning": "Transistor's on-resistance",
            "units": "Ohms (Ω)"
          },
          {
            "symbol": "C_{load}",
            "meaning": "Capacitance being charged/discharged",
            "units": "Farads (F)"
          }
        ],
        "meaning": "Output doesn't change instantly—it takes time to charge/discharge parasitic capacitances. This is governed by the RC time constant (τ = R × C), where R is resistance and C is capacitance; τ gives the characteristic time for a capacitor to charge or discharge and therefore limits how fast the circuit can switch. When a logic function is implemented with multiple stages in series (for example, an AND implemented as a NAND gate followed by an inverter), the total propagation delay is the sum of each stage's delays: t_pd(total) = t_pd(NAND) + t_pd(INV).",
        "example": {
          "problem": "A gate has R_on = 1kΩ and C_load = 10fF. Estimate the propagation delay.",
          "given": [
            "R_on = 1000Ω",
            "C_load = 10×10⁻¹⁵ F"
          ],
          "steps": [
            "t_{pd} = R_{on} \\times C_{load}",
            "t_{pd} = 1000 \\times 10\\times10⁻¹⁵ = 10\\times10⁻¹² s = 10ps"
          ],
          "answer": "~10 picoseconds"
        },
        "latex": "t_{pd} = R_{on} \\times C_{load}",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
      },
      {
        "name": "Maximum Frequency",
        "variables": [
          {
            "symbol": "f_{max}",
            "meaning": "Maximum operating frequency",
            "units": "Hertz (Hz)"
          },
          {
            "symbol": "t_{pd}",
            "meaning": "Total propagation delay through the path",
            "units": "seconds"
          }
        ],
        "meaning": "You can't clock a circuit faster than signals can propagate. The slowest path (critical path) determines maximum frequency.",
        "example": {
          "problem": "If propagation delay is 250ps, what is the maximum frequency?",
          "given": [
            "t_pd = 250ps = 250 × 10⁻¹² s"
          ],
          "steps": [
            "1. Apply formula f_{max} = \\frac{1}{t_{pd}}",
            "2. Substitute: f_{max} = 1 / (250 \\times 10⁻¹² s)",
            "3. Calculate in Hz: \\frac{1}{250} \\times 10¹² = 0.004 \\times 10¹² = 4 \\times 10⁹ Hz",
            "4. Convert to GHz: 4 \\times 10⁹ Hz = 4 GHz"
          ],
          "answer": "4 GHz"
        },
        "latex": "f_{max} = \\frac{1}{t_{pd}}",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">ma</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3932em;vertical-align:-0.5481em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3488em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2901em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5481em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>"
      }
    ],
    "exercises": [
      {
        "question": "Complete the AND truth table: A=0,B=0→? A=0,B=1→? A=1,B=0→? A=1,B=1→?",
        "hint": "AND outputs 1 only when both inputs are 1",
        "answer": "00→0, 01→0, 10→0, 11→1"
      },
      {
        "question": "You have an 8-bit byte = 10110101. You want to extract only bit 4 (counting from 0). What mask do you AND with?",
        "hint": "The mask should have a 1 only in position 4 (which is 2^4 = 16 in decimal, or 00010000 in binary)",
        "answer": {
          "steps": [
            "Bit 4 means the mask has a 1 only at position 4: 00010000 (binary) = 0x10 (hex) = 16 (decimal).",
            "Apply AND: 10110101 AND 00010000 keeps only bit 4 and clears all other bits.",
            "Result is 00010000, which means bit 4 was 1 in the original byte."
          ],
          "answer": "00010000 (binary) = 0x10 (hex) = 16 (decimal)"
        }
      },
      {
        "question": "A CMOS AND gate is built from a NAND + inverter. If NAND delay is 50ps and inverter delay is 30ps, what is the AND gate's propagation delay?",
        "hint": "Delays in series ADD",
        "answer": "t_pd(AND) = t_pd(NAND) + t_pd(INV) = 50ps + 30ps = 80ps"
      }
    ],
    "realWorld": {
      "context": "AND gates are used whenever multiple conditions must all be true before taking action.",
      "example": "When your CPU executes 'if (x > 5 && y < 10)', it uses AND logic to combine the two conditions. Both must be true for the if-block to execute.",
      "numbers": "A modern CPU performs billions of AND operations per second. A 64-bit comparison uses 64 parallel AND gates to check all bits simultaneously.",
      "connection": "In this level, you're implementing A AND \\bar{B}. This exact operation happens millions of times in a single web page load—checking conditions, masking data, validating inputs."
    }
  }
}