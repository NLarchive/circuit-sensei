{
  "$schema": "./level-game.schema.json",
  "id": "level_19_medium",
  "tier": "tier_6",
  "title": "ALU with Logic Operations",
  "objective": "Add AND, OR, XOR operations",
  "description": "Extend the ALU to perform both arithmetic (ADD/SUB) and logic (AND/OR/XOR) operations based on a 2-bit opcode.",
  "introText": "Real ALUs perform multiple operations selected by an opcode. A simple ALU might have: 00=ADD, 01=SUB, 10=AND, 11=OR. Use multiplexers to select which operation's result reaches the output. x86 and ARM ALUs have dozens of operations, but the principle is the same: compute all results in parallel, then MUX-select the correct one.",
  "physicsVisual": "alu_extended",
  "hint": "Compute ADD, AND, OR results in parallel. Use a 4:1 MUX (or tree of 2:1 MUXes) controlled by 2-bit opcode to select output. For simplicity, just implement 2 ops: opcode=0 for ADD, opcode=1 for AND.",
  "availableGates": [
    "transistor",
    "not",
    "and",
    "or",
    "nand",
    "nor",
    "xor",
    "mux2to1",
    "srLatch",
    "dFlipFlop",
    "fullAdder"
  ],
  "inputs": 3,
  "targetTruthTable": [
    {
      "in": [
        0,
        0,
        0
      ],
      "out": [
        0,
        0
      ],
      "desc": "Op=ADD: 0+0=0"
    },
    {
      "in": [
        0,
        1,
        0
      ],
      "out": [
        1,
        0
      ],
      "desc": "Op=ADD: 0+1=1"
    },
    {
      "in": [
        1,
        0,
        0
      ],
      "out": [
        1,
        0
      ],
      "desc": "Op=ADD: 1+0=1"
    },
    {
      "in": [
        1,
        1,
        0
      ],
      "out": [
        0,
        1
      ],
      "desc": "Op=ADD: 1+1=10"
    },
    {
      "in": [
        0,
        0,
        1
      ],
      "out": [
        0,
        0
      ],
      "desc": "Op=AND: 0&0=0"
    },
    {
      "in": [
        0,
        1,
        1
      ],
      "out": [
        0,
        0
      ],
      "desc": "Op=AND: 0&1=0"
    },
    {
      "in": [
        1,
        0,
        1
      ],
      "out": [
        0,
        0
      ],
      "desc": "Op=AND: 1&0=0"
    },
    {
      "in": [
        1,
        1,
        1
      ],
      "out": [
        1,
        0
      ],
      "desc": "Op=AND: 1&1=1"
    }
  ],
  "maxGates": 6,
  "xpReward": 320,
  "storyText": "ALU DESIGN PRINCIPLES: Parallel function units compute ALL operations simultaneously. A MUX tree controlled by the opcode selects which result reaches the output. Status flags (Zero, Negative, Carry, Overflow) enable conditional branching.",
  "physicsDetails": {
    "conceptCards": [
      {
        "term": "Arithmetic Logic Unit (ALU)",
        "definition": "A combinational circuit that performs arithmetic (add, subtract) and logic (AND, OR, XOR) operations on binary operands.",
        "why": "The ALU is the 'calculator' inside every CPU. All computations ultimately happen here.",
        "analogy": "Like a Swiss Army knife for numbers: multiple tools (operations) in one unit, selected by which one you pull out (opcode).",
        "latex": "Result = Operation(A, B, Opcode)",
        "html": null,
        "visuals": [
          {
            "type": "alu_detailed",
            "title": "ALU: Operation Select & Flags"
          }
        ]
      },
      {
        "term": "Opcode (Operation Code)",
        "definition": "A binary code that selects which operation the ALU performs. Different opcodes select ADD, SUB, AND, OR, etc.",
        "why": "The opcode comes from the instruction being executed—it's how software controls hardware.",
        "analogy": "Like a TV remote button: each button (opcode) selects a different channel (operation).",
        "visuals": [
          {
            "type": "multiplexer",
            "title": "Opcode-Controlled MUX"
          }
        ],
        "latex": "ALU_{Op}: 00=AND, 01=OR, 10=ADD, 11=SUB(example)",
        "html": null
      },
      {
        "term": "Status Flags",
        "definition": "Single-bit outputs indicating properties of the ALU result. Common flags include Zero (Z), Negative (N), Carry (C), and Overflow (V).",
        "why": "Flags enable 'conditional branching' (IF-statements). For example, a BEQ (Branch if Equal) instruction works by checking if the Zero flag is 1 after a subtraction.",
        "analogy": "Like warning lights on a car dashboard: they don't show the whole engine state, just a summary (like 'Low Oil') that requires action.",
        "latex": "Z = (Result == 0), N = Result[MSB], etc.",
        "html": null,
        "visuals": [
          {
            "type": "full_adder",
            "title": "Carry Flag (Cout)"
          }
        ]
      },
      {
        "term": "Superscalar Execution",
        "definition": "A CPU design that issues multiple instructions per clock cycle to parallel execution units. Achieves IPC (Instructions Per Cycle) greater than 1.",
        "why": "Modern CPUs execute 4-8 instructions/cycle using multiple ALUs, load/store units, and branch units in parallel.",
        "analogy": "Like a restaurant with multiple chefs—more orders completed per minute than a single chef.",
        "latex": "IPC = Instructions \\frac{completed}{Clock} cycles",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2772em;vertical-align:-0.345em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">Cl</span><span class=\"mord mathnormal mtight\">oc</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">co</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">pl</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">cyc</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">es</span></span></span></span>"
      },
      {
        "term": "Two's Complement Subtraction",
        "definition": "Subtraction implemented as addition: A - B = A + NOT(B) + 1. Invert B and add 1 (the 'complement').",
        "why": "This lets us use the same adder hardware for both addition and subtraction.",
        "analogy": "Like going backward by going forward on a circular track—adding the complement takes you 'backward'.",
        "latex": "A - B = A + (~B) + 1",
        "html": null,
        "visuals": [
          {
            "type": "nand_to_not",
            "title": "Invert B(NOT gate)"
          }
        ]
      },
      {
        "term": "Subtraction Terminology",
        "definition": "Minuend = the number being subtracted FROM (A in A-B). Subtrahend = the number being subtracted (B in A-B). Difference = the result.",
        "why": "These terms appear in ALU documentation and help clarify operand roles in subtraction circuits.",
        "analogy": "In 10-3=7: 10 is the minuend (what you have), 3 is the subtrahend (what you take away), 7 is the difference.",
        "latex": "Minuend - Subtrahend = Difference",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">ah</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span></span></span></span>"
      }
    ],
    "formulaCards": [
      {
        "name": "Two's Complement Subtraction",
        "variables": [
          {
            "symbol": "A",
            "meaning": "Minuend (number being subtracted from)",
            "units": "Binary"
          },
          {
            "symbol": "B",
            "meaning": "Subtrahend (number being subtracted)",
            "units": "Binary"
          },
          {
            "symbol": "\\overline{B}",
            "meaning": "Bitwise complement of B",
            "units": "Binary"
          },
          {
            "symbol": "+1",
            "meaning": "Added via carry-in of adder",
            "units": ""
          }
        ],
        "meaning": "Subtraction reuses the adder by inverting B and setting carry-in to 1.",
        "derivation": "In two's complement: -B = NOT(B) + 1. So A - B = A + (-B) = A + NOT(B) + 1.",
        "example": {
          "problem": "Calculate 5 - 3 using two's complement (4-bit).",
          "given": [
            "A = 5 = 0101",
            "B= 3 = 0011"
          ],
          "steps": [
            "\\overline{B} = \\overline{0011} = 1100",
            "A + \\overline{B} = 0101 + 1100 = 10001",
            "Add carry-in (+1): already included in sum",
            "Result (4 bits): 0010 = 2",
            "Carry out = 1 (ignore for subtraction)"
          ],
          "answer": "5 - 3 = 2 (0010 in binary)"
        },
        "latex": "A - B = A + \\overline{B} + 1",
        "html": null
      },
      {
        "name": "Zero Flag",
        "variables": [
          {
            "symbol": "Z",
            "meaning": "Zero flag (1 if result is zero)",
            "units": "Logic level"
          },
          {
            "symbol": "R_{0}\\ldotsR_{n-1}",
            "meaning": "Result bits",
            "units": "Logic levels"
          }
        ],
        "meaning": "Z is 1 only when ALL result bits are 0. This is a NOR of all bits.",
        "derivation": "If any bit is 1, the OR is 1, and NOT(1)=0. Only when all bits are 0: NOT(0)=1.",
        "example": {
          "problem": "Compute Z flag for result = 0000.",
          "given": [
            "Result = 0000"
          ],
          "steps": [
            "R_{0} OR R_{1} OR R_{2} OR R_{3} = 0|0|0|0 = 0",
            "Z = \\overline{0} = 1"
          ],
          "answer": "Z = 1 (result is zero)"
        },
        "latex": "Z = \\overline{R_{0} OR R_{1} OR \\ldots OR R_{n-1}}",
        "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0917em;vertical-align:-0.2083em;\"></span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span>"
      },
      {
        "name": "Overflow Flag (Signed)",
        "variables": [
          {
            "symbol": "V",
            "meaning": "Overflow flag (signed overflow)",
            "units": "Logic level"
          },
          {
            "symbol": "C_{in, MSB}",
            "meaning": "Carry into the MSB position",
            "units": "Logic level"
          },
          {
            "symbol": "C_{out, MSB}",
            "meaning": "Carry out of the MSB position",
            "units": "Logic level"
          }
        ],
        "meaning": "Signed overflow occurs when the sign of the result is wrong—detected by comparing carries at MSB.",
        "derivation": "Overflow happens when two positives give negative, or two negatives give positive. This creates a carry discrepancy at MSB.",
        "example": {
          "problem": "Detect overflow: 7 + 1 in 4-bit signed (should be 8, but max is 7).",
          "given": [
            "A = 0111 (7)",
            "B= 0001 (1)"
          ],
          "steps": [
            "Sum: 0111 + 0001 = 1000 (-8 in signed!)",
            "C_{in} to bit 3: 1 (carry from bit 2)",
            "C_{out} from bit 3: 0 (no carry out)",
            "V = 1 XOR 0 = 1 (OVERFLOW!)"
          ],
          "answer": "V = 1 (7 + 1 = -8 is wrong in 4-bit signed)"
        },
        "latex": "V = C_{in, MSB} XOR C_{out, MSB}",
        "html": null
      }
    ],
    "exercises": [
      {
        "question": "Using an ALU that performs A + B when Op=0 and A - B when Op=1, compute the output for A=6, B=2, Op=1.",
        "hint": "Op=1 selects the subtraction unit or mode. Compute decimal 6 - 2.",
        "answer": {
          "steps": [
            "1. Mode: Op=1 → Subtraction.",
            "2. Operation: 6 - 2 = 4.",
            "3. Binary output (4-bit): 0100."
          ],
          "answer": "0100"
        }
      },
      {
        "question": "What are the Z and N flags for result = 11111100 (8-bit)?",
        "hint": "Z: is it all zeros? N: what's the MSB?",
        "answer": "Z = 0 (not zero), N = 1 (MSB is 1, negative in signed interpretation)"
      },
      {
        "question": "How does a single adder implement both A+B and A-B?",
        "hint": "Think about what changes: B vs NOT(B), and the carry-in.",
        "answer": "For add: Adder(A, B, Cin=0). For subtract: Adder(A, NOT(B), Cin=1). XOR gates controlled by Op can invert B."
      }
    ],
    "realWorld": {
      "context": "The ALU is the computational heart of every processor—from simple microcontrollers to supercomputers.",
      "example": "Intel Skylake has 4 integer ALUs per core for superscalar execution. NVIDIA GPUs have thousands of simplified ALUs (CUDA cores).",
      "numbers": "A 64-bit ALU add takes ~1 clock cycle (0.25ns at 4GHz). ARM NEON processes 128 bits (4×32-bit) per cycle with SIMD ALUs.",
      "connection": "This level builds the ALU—the circuit that actually computes. Combined with registers and control, you have a CPU!"
    }
  }
}