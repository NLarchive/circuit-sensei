{
  "$schema": "./levels-manifest.schema.json",
  "version": "1.0.0",
  "description": "Logic Architect level manifest with variant inheritance",
  "generatedAt": "2026-01-12T14:35:23.508Z",
  "levels": [
    {
      "id": "level_00",
      "tier": "intro",
      "title": "Logic Architect: Course Overview",
      "objective": "Understand the journey ahead",
      "description": "Welcome to Logic Architect - build a computer from first principles.",
      "introText": "FROM ELECTRONS TO COMPUTATION: This course takes you on an epic journey through digital electronics. You'll start with a simple wire and end by building a CPU. Each level teaches real physics and engineering - the same knowledge used to design the chips in your phone and computer.",
      "hint": "Use the roadmap to select a level and try the easy/hard variants to practice with previous operators.",
      "isIndex": true,
      "availableGates": [],
      "inputs": 0,
      "xpReward": 0,
      "courseOverview": {
        "totalLevels": 20,
        "totalTiers": 6,
        "estimatedTime": "8-12 hours",
        "prerequisites": "None - we start from absolute basics",
        "learningOutcomes": [
          "Understand how electricity carries information",
          "Build memory elements and sequential circuits",
          "Implement a working arithmetic logic unit",
          "Comprehend the fetch-decode-execute cycle"
        ]
      },
      "tierOverview": [
        {
          "tier": "tier_1",
          "name": "The Silicon Age",
          "levels": [
            "level_01",
            "level_02",
            "level_03",
            "level_04",
            "level_05"
          ],
          "theme": "Physics to Switches to Gates",
          "description": "Learn the physical foundation: how electrons flow, how transistors switch, and how basic gates emerge from physics.",
          "difficultyRamp": "GENTLE - These levels are tutorials. Just connect components and observe. No complex design required.",
          "keyInsight": "A transistor is just a switch. All computing reduces to switching."
        },
        {
          "tier": "tier_2",
          "name": "Boolean Algebra",
          "levels": [
            "level_06",
            "level_07",
            "level_08",
            "level_09"
          ],
          "theme": "Universal Gates to Any Function",
          "description": "Discover that NAND alone can build ANY logic function. Master XOR and De Morgan's laws.",
          "difficultyRamp": "MODERATE - Start designing small circuits. Level 09 requires combining 3 gates.",
          "keyInsight": "NAND is universal. With one gate type, you can build any computer."
        },
        {
          "tier": "tier_3",
          "name": "Combinational Logic",
          "levels": [
            "level_10",
            "level_11",
            "level_12",
            "level_13"
          ],
          "theme": "Data Routing to Arithmetic",
          "description": "Build the circuits that make decisions (MUX), select addresses (decoder), and do math (adders).",
          "difficultyRamp": "CHALLENGING - Multi-gate designs. Full adder needs 5 gates working together.",
          "keyInsight": "Computers do math with XOR and AND. Addition is the foundation of all arithmetic."
        },
        {
          "tier": "tier_4",
          "name": "Sequential Logic",
          "levels": [
            "level_14",
            "level_15",
            "level_16"
          ],
          "theme": "Memory to Synchronization",
          "description": "Introduce TIME. Build circuits that remember (latches) and synchronize (flip-flops).",
          "difficultyRamp": "CONCEPTUAL LEAP - Understanding feedback and clocking is the hardest conceptual jump.",
          "keyInsight": "Feedback creates memory. Clocks create order. Together they enable computation over time."
        },
        {
          "tier": "tier_5",
          "name": "Finite State Machines",
          "levels": [
            "level_17",
            "level_18"
          ],
          "theme": "Counters to Controllers",
          "description": "Design circuits that move through defined states - the control logic inside every processor.",
          "difficultyRamp": "DESIGN INTENSIVE - You must plan state transitions before building.",
          "keyInsight": "Any sequential behavior can be modeled as states plus transitions."
        },
        {
          "tier": "tier_6",
          "name": "Computer Architecture",
          "levels": [
            "level_19",
            "level_boss"
          ],
          "theme": "ALU to CPU",
          "description": "The grand finale. Build an ALU, then combine everything into a working processor.",
          "difficultyRamp": "MASTERY - Integrate all previous knowledge. The boss level is the ultimate test.",
          "keyInsight": "A CPU is just gates plus memory plus control. You now understand how computers work."
        }
      ],
      "levelGuide": {
        "level_01": {
          "title": "The Simple Wire",
          "concept": "Current, voltage, signal propagation",
          "difficulty": "Tutorial",
          "task": "Connect input to output",
          "insight": "Electrons drift slowly, but signals travel at near light-speed."
        },
        "level_02": {
          "title": "The Transistor",
          "concept": "Semiconductors, P-N junctions, switching",
          "difficulty": "Tutorial",
          "task": "Use a transistor as a controlled switch",
          "insight": "A small signal controls a large current - the basis of amplification."
        },
        "level_03": {
          "title": "NOT Gate (Inverter)",
          "concept": "CMOS logic, complementary switching",
          "difficulty": "Tutorial",
          "task": "Build an inverter",
          "insight": "Inversion is the simplest computation - flip 0 to 1."
        },
        "level_04": {
          "title": "AND Gate",
          "concept": "Series circuits, Boolean multiplication",
          "difficulty": "Easy",
          "task": "Output 1 only when both inputs are 1",
          "insight": "Series equals AND. Both switches must close for current to flow."
        },
        "level_05": {
          "title": "OR Gate",
          "concept": "Parallel circuits, Boolean addition",
          "difficulty": "Easy",
          "task": "Output 1 when any input is 1",
          "insight": "Parallel equals OR. Any path conducts."
        },
        "level_06": {
          "title": "NAND: The Universal",
          "concept": "Universal gates, functional completeness",
          "difficulty": "Easy",
          "task": "Use the NAND gate",
          "insight": "NAND equals NOT(AND). It is the only gate type needed to build any circuit."
        },
        "level_07": {
          "title": "Logic from NAND",
          "concept": "Technology mapping, synthesis",
          "difficulty": "Easy-Medium",
          "task": "Build NOT using only NAND",
          "insight": "NAND(A,A) equals NOT(A). Tie the inputs together!"
        },
        "level_08": {
          "title": "XOR (Exclusive OR)",
          "concept": "Parity, modulo-2 arithmetic",
          "difficulty": "Medium",
          "task": "Output 1 when inputs differ",
          "insight": "XOR is addition without carry. It is the heart of error detection."
        },
        "level_09": {
          "title": "De Morgan Laws",
          "concept": "Boolean algebra, bubble pushing",
          "difficulty": "Medium",
          "task": "Build OR using only NAND gates",
          "insight": "Invert inputs, change AND to OR. This completes the universality proof."
        },
        "level_10": {
          "title": "Multiplexer (MUX)",
          "concept": "Data selection, control paths",
          "difficulty": "Medium",
          "task": "Select between two inputs based on selector",
          "insight": "MUX equals programmable routing. FPGAs use MUX-based lookup tables."
        },
        "level_11": {
          "title": "Decoder (2-to-4)",
          "concept": "Address decoding, one-hot encoding",
          "difficulty": "Medium-Hard",
          "task": "Convert 2-bit binary to 4 output lines",
          "insight": "Every memory access uses decoders to select cells."
        },
        "level_12": {
          "title": "Half Adder",
          "concept": "Binary addition, Sum and Carry",
          "difficulty": "Medium",
          "task": "Add two bits, output Sum and Carry",
          "insight": "Sum equals XOR, Carry equals AND. This is how computers add!"
        },
        "level_13": {
          "title": "Full Adder",
          "concept": "Carry propagation, ripple chains",
          "difficulty": "Hard",
          "task": "Add three bits (A, B, Carry-in)",
          "insight": "Chain full adders for multi-bit arithmetic."
        },
        "level_14": {
          "title": "SR Latch",
          "concept": "Bistability, feedback, memory",
          "difficulty": "Conceptual",
          "task": "Store and recall a bit using Set/Reset",
          "insight": "Feedback creates memory! Two stable states equals 1 bit of storage."
        },
        "level_15": {
          "title": "D Flip-Flop",
          "concept": "Edge triggering, synchronous design",
          "difficulty": "Conceptual",
          "task": "Capture D input only on clock edge",
          "insight": "All changes happen at the clock edge. This makes design predictable."
        },
        "level_16": {
          "title": "Toggle Flip-Flop",
          "concept": "Frequency division, feedback",
          "difficulty": "Medium",
          "task": "Toggle output on each clock pulse",
          "insight": "T-FF divides frequency by 2. Chain them for counters."
        },
        "level_17": {
          "title": "2-Bit Counter",
          "concept": "State machines, binary counting",
          "difficulty": "Hard",
          "task": "Count through 00, 01, 10, 11, 00",
          "insight": "A counter is the simplest FSM. Every CPU has a program counter."
        },
        "level_18": {
          "title": "Traffic Light Controller",
          "concept": "FSM design methodology",
          "difficulty": "Hard",
          "task": "Cycle through GREEN, YELLOW, RED",
          "insight": "Any sequential behavior equals states plus transitions."
        },
        "level_19": {
          "title": "Arithmetic Logic Unit",
          "concept": "Opcode selection, status flags",
          "difficulty": "Very Hard",
          "task": "Add OR subtract based on operation code",
          "insight": "The ALU is where computation happens. Flags enable conditionals."
        },
        "level_boss": {
          "title": "The CPU Datapath",
          "concept": "Von Neumann architecture, fetch-decode-execute",
          "difficulty": "Boss",
          "task": "Fetch, decode, and execute an instruction",
          "insight": "A CPU is gates plus memory plus control. You now understand computers!"
        }
      },
      "difficultyProgression": {
        "phase1_tutorials": {
          "levels": [
            "level_01",
            "level_02",
            "level_03"
          ],
          "description": "Pure observation and single connections. Just follow instructions.",
          "tip": "Do not worry about solving anything. These levels teach concepts."
        },
        "phase2_singleGate": {
          "levels": [
            "level_04",
            "level_05",
            "level_06"
          ],
          "description": "Use one gate. Understand input to output relationships.",
          "tip": "Study the truth table. Match your circuit output to it."
        },
        "phase3_multiGate": {
          "levels": [
            "level_07",
            "level_08",
            "level_09"
          ],
          "description": "Combine 2-4 gates. Plan before building.",
          "tip": "Draw the circuit on paper first. Then implement."
        },
        "phase4_systems": {
          "levels": [
            "level_10",
            "level_11",
            "level_12",
            "level_13"
          ],
          "description": "Build functional units with 4-6 gates.",
          "tip": "Break the problem into sub-problems. Build and test incrementally."
        },
        "phase5_sequential": {
          "levels": [
            "level_14",
            "level_15",
            "level_16"
          ],
          "description": "MAJOR CONCEPT SHIFT. Understand feedback and time.",
          "tip": "Focus on understanding the why before the how. Re-read explanations."
        },
        "phase6_stateMachines": {
          "levels": [
            "level_17",
            "level_18"
          ],
          "description": "Design state transition logic. Plan states first.",
          "tip": "Draw the state diagram. Label transitions. Then derive equations."
        },
        "phase7_architecture": {
          "levels": [
            "level_19",
            "level_boss"
          ],
          "description": "Integration of all skills. The ultimate challenge.",
          "tip": "This is where everything comes together. Take your time."
        }
      },
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "The Learning Journey",
            "definition": "This course progresses from physics (electrons, voltage) through abstraction layers (gates, circuits, systems) to a working computer.",
            "why": "Understanding each layer deeply prepares you for the next. Skipping ahead leads to gaps in understanding.",
            "analogy": "Like building a house: foundation (physics), framing (gates), rooms (circuits), complete home (computer)."
          },
          {
            "term": "Abstraction in Engineering",
            "definition": "Each level hides lower-level complexity. Gates hide transistors. Circuits hide gates. CPUs hide circuits.",
            "why": "Abstraction makes complex systems manageable. You do not think about electrons when coding.",
            "analogy": "Like driving a car: you use the steering wheel abstraction, not individual tire rotations."
          },
          {
            "term": "Digital vs Analog",
            "definition": "Digital uses discrete values (0 and 1). Analog uses continuous values. Digital is noise-resistant.",
            "why": "Digital circuits can regenerate signals (a slightly-off 1 becomes a perfect 1), enabling reliable computation.",
            "analogy": "Digital is like Morse code (dots and dashes), analog is like speaking (infinite variations)."
          },
          {
            "term": "The Power of Universality",
            "definition": "NAND gates alone can build ANY digital circuit. This simplifies manufacturing enormously.",
            "why": "Instead of making 10 different gate types, factories make trillions of identical NAND gates.",
            "analogy": "Like having one type of LEGO brick that can build any structure when combined properly."
          }
        ],
        "formulaCards": [
          {
            "name": "Moore's Law",
            "variables": [
              {
                "symbol": "Transistors",
                "meaning": "Number of transistors per chip",
                "units": "count"
              },
              {
                "symbol": "year",
                "meaning": "Calendar year",
                "units": "year"
              }
            ],
            "meaning": "Transistor density doubles approximately every 2 years. This exponential growth enabled modern computing.",
            "example": {
              "problem": "Estimate transistors in 2023 vs 1971",
              "given": [
                "1971: approximately 2000 transistors (Intel 4004)"
              ],
              "steps": [
                "Years elapsed: 2023 - 1971 = 52 years",
                "Doublings: \\frac{52}{2} = 26",
                "Multiplier: 2^{26} is approximately 67 million",
                "Estimate: 2000 times 67M is approximately 134 billion"
              ],
              "answer": "approximately 100+ billion transistors (Apple M2 has 20B, high-end GPUs have 80B+)"
            },
            "latex": "Transistors \\approx 2^{(year-1971)/2}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">ors</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">pp</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">ye</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1971</span></span></span></span></span></span></span></span></span><span class=\"mord\">/2</span><span class=\"mclose\">)</span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "If you complete one level per day, how long will this course take?",
            "hint": "Count the main levels: 01-19 plus boss",
            "answer": "20 days (or faster if you do multiple levels per session!)"
          },
          {
            "question": "Which tier represents the biggest conceptual jump?",
            "hint": "When do we first introduce time and memory into circuits?",
            "answer": "Tier 4 (Sequential Logic) - moving from stateless to stateful circuits is the hardest concept."
          }
        ],
        "realWorld": {
          "context": "Every electronic device you use - phone, computer, car, appliances - contains the circuits you will learn to build.",
          "example": "Your smartphone has more computing power than all of NASA had during the Apollo missions - thanks to the miniaturization and integration of these fundamental circuits.",
          "numbers": "A modern CPU executes approximately 100 billion operations per second. Each operation uses the gates you will learn: AND, OR, XOR, flip-flops, adders.",
          "connection": "By the end of this course, the magic of computers will be replaced by understanding. You will see circuits, not mysteries."
        }
      }
    },
    {
      "id": "level_01",
      "tier": "tier_1",
      "title": "The Simple Wire",
      "objective": "Connect input to output",
      "description": "The simplest circuit: a wire that connects input to output.",
      "introText": "Before gates, before transistors, there is the wire. A wire seems simple—just metal connecting two points—but it embodies fundamental physics that makes all electronics possible. In this level, you'll understand what actually happens when current flows, why signals travel fast even though electrons move slowly, and how voltage represents information.",
      "physicsVisual": "electron_flow_detailed",
      "hint": "Drag from Input to Output.",
      "availableGates": [],
      "inputs": 1,
      "targetTruthTable": [
        {
          "in": [
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1
          ],
          "out": [
            1
          ]
        }
      ],
      "maxGates": 0,
      "xpReward": 10,
      "storyText": "You've completed the simplest possible circuit—but the physics behind it is profound. The wire faithfully transmits voltage levels (HIGH/LOW) at near light-speed, even though electrons themselves barely move. This abstraction—voltage as information—is the foundation of all digital systems. Every computer, phone, and smart device relies on billions of these simple voltage transfers happening reliably.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Electric Charge (Q)",
            "definition": "A fundamental property of matter. Measured in Coulombs (C). 1 Coulomb ≈ 6.24×10¹⁸ electrons.",
            "why": "Charge is the fundamental quantity that flows to create current. It's the 'stuff' that moves.",
            "analogy": "Like a volume of water (liters). Current is the flow rate (liters/sec), but Charge is the water itself.",
            "latex": "Q = I \\times t",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span>"
          },
          {
            "term": "Energy (E)",
            "definition": "The capacity to do work. Measured in Joules (J).",
            "why": "Used to define Voltage (Energy per Charge). 1 Volt = 1 Joule / 1 Coulomb. It represents the work done to move the charge.",
            "analogy": "Like the potential energy of water at a height. It takes energy (Joules) to pump water (Charge) up to a height (Voltage).",
            "latex": "E = V \\times Q",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>"
          },
          {
            "term": "Electric Current (I)",
            "definition": "The flow of electric charge through a conductor, measured in Amperes (A). One Ampere = one Coulomb of charge passing per second.",
            "why": "Current is what actually does work in circuits—powering LEDs, spinning motors, storing data. No current flow = no circuit action.",
            "analogy": "Like water flow in a pipe. Current (Amps) is like flow rate (liters/second). More flow = more water delivered.",
            "latex": "I = \\frac{Q}{t}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2694em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9244em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Q</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>"
          },
          {
            "term": "Voltage (V)",
            "definition": "Electric potential difference—the 'pressure' that pushes charges through a circuit. Measured in Volts (V). One Volt = one Joule of energy per Coulomb of charge.",
            "why": "Voltage is how we encode information in digital circuits. HIGH voltage (~5V or 3.3V) = logic 1. LOW voltage (~0V) = logic 0.",
            "analogy": "Like water pressure difference between two tanks. Higher pressure difference = stronger push for water to flow.",
            "visuals": [
              {
                "type": "electric_field",
                "title": "Electric Field & Potential Difference"
              }
            ],
            "latex": "V = \\frac{E}{Q} (energy per charge)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3534em;vertical-align:-0.4811em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Q</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4811em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">erc</span><span class=\"mord mathnormal\">ha</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "Drift Velocity",
            "definition": "The slow average velocity (~0.1 mm/s) at which electrons actually move through a conductor when current flows.",
            "why": "This explains a key paradox: electrons move very slowly, yet circuits respond almost instantly. The signal isn't carried by individual electrons traveling fast.",
            "analogy": "Imagine a tube completely filled with marbles. Push one marble in at one end, and a marble instantly pops out the other end—even though no single marble traveled the full length.",
            "visuals": [
              {
                "type": "drift_velocity_animation",
                "title": "Charge Carriers in a Conductor"
              }
            ]
          }
          {
            "term": "Signal Propagation Speed",
            "definition": "The speed at which an electromagnetic disturbance (the 'signal') travels along a wire—typically 50-99% the speed of light.",
            "why": "This is why circuits respond 'instantly' even though electrons drift slowly. When you flip a switch, the electric field change propagates at near light-speed, pushing all electrons simultaneously.",
            "analogy": "When you push a long line of standing dominoes, the 'wave' of falling travels much faster than any single domino moves."
          }
        ],
        "formulaCards": [
          {
            "name": "Ohm's Law",
            "variables": [
              {
                "symbol": "V",
                "meaning": "Voltage across the component",
                "units": "Volts (V)"
              },
              {
                "symbol": "I",
                "meaning": "Current through the component",
                "units": "Amperes (A)"
              },
              {
                "symbol": "R",
                "meaning": "Resistance of the component",
                "units": "Ohms (Ω)"
              }
            ],
            "meaning": "Voltage, current, and resistance are linked. If you know any two, you can calculate the third. Higher resistance means less current for the same voltage.",
            "derivation": "This is an empirical law discovered by Georg Ohm in 1827. It holds for 'ohmic' materials like metals at constant temperature.",
            "example": {
              "problem": "A wire has 10Ω resistance. If 5V is applied across it, how much current flows?",
              "given": [
                "V = 5V",
                "R = 10Ω"
              ],
              "steps": [
                "Use Ohm's Law: V = I \\times R",
                "Rearrange to find I: I = \\frac{V}{R}",
                "Substitute: I = \\frac{5V}{10}Ω = 0.5A"
              ],
              "answer": "0.5 Amperes (500 mA)"
            },
            "latex": "V = I \\times R",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>"
          },
          {
            "name": "Current from Drift",
            "variables": [
              {
                "symbol": "I",
                "meaning": "Current",
                "units": "Amperes (A)"
              },
              {
                "symbol": "n",
                "meaning": "Carrier density (free electrons per m³)",
                "units": "electrons/m³"
              },
              {
                "symbol": "A",
                "meaning": "Cross-sectional area of wire",
                "units": "m²"
              },
              {
                "symbol": "v_{d}",
                "meaning": "Drift velocity of electrons",
                "units": "m/s"
              },
              {
                "symbol": "q",
                "meaning": "Charge per electron (1.6×10⁻¹⁹ C)",
                "units": "Coulombs"
              }
            ],
            "meaning": "Current depends on how many carriers there are (n), how big the wire is (A), how fast they drift (v_d), and the charge each carries (q). This explains why copper (high n) conducts well.",
            "example": {
              "problem": "Copper has n = 8.5×10²⁸ electrons/m³. A wire with area 1mm² carries 1A. What is the drift velocity?",
              "given": [
                "n = 8.5×10²⁸/m³",
                "A = 1×10⁻⁶ m²",
                "I = 1A",
                "q = 1.6×10⁻¹⁹ C"
              ],
              "steps": [
                "1. Rearrange formula: v_{d} = I / (n \\times A \\times q)",
                "2. Group numerical values & powers of 10: v_{d} = 1 / ((8.5 \\times 1 \\times 1.6) \\times (10²⁸ \\times 10⁻⁶ \\times 10⁻¹⁹))",
                "3. Add exponents: 28 - 6 - 19 = 3",
                "4. Calculate base value: 8.5 \\times 1.6 = 13.6",
                "5. Final SI result: v_{d} = 1 / (13.6 \\times 10³) = \\frac{1}{13600} ≈ 7.35 \\times 10⁻⁵ \\frac{m}{s}"
              ],
              "answer": "≈ 0.074 mm/s — electrons drift incredibly slowly (about 26 cm per hour)!"
            },
            "latex": "I = n \\times A \\times v_{d} \\times q",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "A 9V battery is connected to a light bulb with 18Ω resistance. Calculate the current flowing through the bulb.",
            "hint": "Use Ohm's Law: I = V/R",
            "answer": "I = 9V / 18Ω = 0.5A"
          },
          {
            "question": "If electrons in a USBcable drift at 0.036 mm/s, and data transfers at 480 Mbps, what enables this fast data transfer despite slow electron movement?",
            "hint": "Think about what actually carries the 'signal'—is it the electrons themselves or something else?",
            "answer": "The electromagnetic field propagates at near light-speed (~200,000 km/s). The field pushes all electrons simultaneously, so the 'signal' travels fast even though individual electrons barely move."
          },
          {
            "question": "Why does a thicker wire have lower resistance? Explain using the current formula I = n × A × v_d × q.",
            "hint": "What happens to A (cross-sectional area) when wire gets thicker?",
            "answer": {
              "steps": [
                "(1) A 1mm² wire with I = 1A has R = 5Ω.",
                "(2) If we double A to 2mm², I doubles to 2A.",
                "(3) Then R = V/(2A) = 2.5Ω, which is half the original resistance."
              ],
              "answer": "According to the formula I = n × A × v_d × q, current (I) is directly proportional to the cross-sectional area (A). This means if A doubles, I doubles (assuming n, v_d, and q remain constant). A thicker wire has a larger A, which increases the current (I) for a given drift velocity. Since Ohm's Law (V = I × R) implies R = V/I, increasing the current for a constant voltage means the resistance (R) is lower."
            }
          }
        ],
        "realWorld": {
          "context": "Every electronic device uses wires (or traces on circuit boards) to connect components. Understanding wire behavior is essential for reliable circuit design.",
          "example": "A typical USB2.0 cable carries about 500mA of current. Despite this substantial current, the electrons inside the copper wires drift at only 0.036 mm/s—slower than a snail!",
          "numbers": "The electromagnetic signal propagates at ~200,000 km/s (67% speed of light in copper). This means a signal can travel 1 meter in just 5 nanoseconds.",
          "connection": "In this level, the wire transmits a HIGH or LOW voltage from input to output. This simple voltage transfer is the foundation of ALL digital communication."
        }
      },
      "variants": {
        "easy": {
          "maxGates": 1,
          "availableGates": []
        },
        "medium": {
          "title": "Dual Wire Bus",
          "objective": "Route two parallel signals",
          "description": "Build two independent wire paths: connect Input A to Output A, and Input B to Output B simultaneously.",
          "introText": "In real circuits, signals rarely travel alone. Data buses carry multiple bits side by side, each on its own wire. This is how your computer moves bytes (8 bits) or words (32/64 bits) at once. Here you'll learn that wires are independent—signal A doesn't interfere with signal B. This parallel routing is the foundation of multi-bit data transfer in every modern processor.",
          "physicsVisual": "parallel_wires",
          "hint": "Create two separate connections. Wire 1: In_A → Out_A. Wire 2: In_B → Out_B. The signals must remain independent—this is how data buses work.",
          "inputs": 2,
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0,
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0,
                1
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                1,
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1,
                1
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 25
        },
        "hard": {
          "title": "Signal Fan-Out",
          "objective": "Distribute one signal to three outputs",
          "description": "A single input must drive three separate outputs simultaneously. This demonstrates fan-out—one source, multiple destinations.",
          "introText": "FAN-OUT is a critical concept in digital design. When one signal needs to reach multiple destinations (like a clock signal reaching every flip-flop in a chip), we must distribute it carefully. In real CMOS circuits, each additional output adds capacitive load, slowing down signal transitions. Excessive fan-out causes signal degradation and timing violations. Clock distribution trees in modern CPUs use careful buffering to drive thousands of flip-flops reliably.",
          "physicsVisual": "fan_out_tree",
          "hint": "Connect the single input to all three outputs. In this simulator, fan-out is unlimited, but in real chips, each output adds load capacitance. This is why clock trees use buffer chains.",
          "targetTruthTable": [
            {
              "in": [
                0
              ],
              "out": [
                0,
                0,
                0
              ]
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                1,
                1
              ]
            }
          ],
          "maxGates": 3,
          "xpReward": 40
        }
      }
    },
    {
      "id": "level_02",
      "tier": "tier_1",
      "title": "The Transistor",
      "objective": "Build a switch",
      "description": "A transistor lets a control signal determine if current can flow.",
      "introText": "The transistor is arguably the most important invention of the 20th century. It's an electrically-controlled switch: a small control signal determines whether a larger current can flow. Whether it's a BJT (Bipolar Junction Transistor) or a MOSFET (Field-Effect Transistor), understanding how semiconductors enable this switching action reveals why modern computers are possible.",
      "physicsVisual": "npn_transistor_detailed",
      "hint": "Base controls the flow from Collector to Emitter.",
      "availableGates": [
        "transistor"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            1
          ]
        }
      ],
      "maxGates": 1,
      "xpReward": 15,
      "storyText": "You've built a controlled switch—the fundamental building block of ALL digital logic. Every gate (AND, OR, NOT) is made of transistors. A modern CPU contains over 100 billion of these tiny switches, each turning on and off billions of times per second. The jump from vacuum tubes (hot, large, power-hungry) to transistors (cool, tiny, efficient) enabled the digital revolution.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Valence Electrons",
            "definition": "Electrons in the outermost shell of an atom that participate in chemical bonding. Silicon has 4 valence electrons, forming a crystal lattice.",
            "why": "The number of valence electrons determines how atoms bond and whether a material conducts. Silicon's 4 electrons create a stable structure that can be modified by doping.",
            "analogy": "Like hands available for handshakes. Silicon has 4 'hands', needing 4 partners to be stable."
          },
          {
            "term": "Semiconductor",
            "definition": "A material (like silicon) with conductivity between a conductor and insulator. Its conductivity can be precisely controlled by adding impurities (doping) or applying voltage.",
            "why": "Semiconductors are the foundation of all modern electronics. Unlike metals (always conduct) or insulators (never conduct), we can control when semiconductors conduct—enabling switches.",
            "analogy": "A semiconductor is like a door with an electronic lock. Unlike an open doorway (conductor) or a wall (insulator), you can control whether it's open or closed."
          },
          {
            "term": "Doping (N-type and P-type)",
            "definition": "Adding impurity atoms to pure silicon. N-type: add phosphorus (5 valence electrons) → excess free electrons (negative carriers). P-type: add boron (3 valence electrons) → electron vacancies called 'holes' (positive carriers).",
            "why": "Doping creates regions with controllable amounts of mobile charge carriers. The boundary between N and P regions (the P-N junction) is where transistor magic happens.",
            "analogy": "Imagine a parking lot. N-type = lots of extra cars (electrons) looking for spots. P-type = lots of empty parking spots (holes) waiting for cars.",
            "visuals": [
              {
                "type": "semiconductor_doping",
                "title": "Doping: N-type vs P-type"
              }
            ]
          },
          {
            "term": "P-N Junction & Depletion Region",
            "definition": "Where P-type and N-type silicon meet. Electrons diffuse from N to P, holes from P to N, leaving a 'depletion region' of immobile ions with a built-in electric field (~0.7V for silicon).",
            "why": "The depletion region acts as a controllable barrier. Apply voltage one way → barrier shrinks → current flows (forward bias). Apply voltage the other way → barrier grows → no current (reverse bias).",
            "analogy": "Like a one-way valve that opens only when you push hard enough in the right direction.",
            "visuals": [
              {
                "type": "npn_transistor_detailed",
                "title": "NPN Junctions & Carrier Injection"
              }
            ]
          },
          {
            "term": "Transistor as a Switch",
            "definition": "A transistor has three terminals: a control input (Base/Gate) and a current path (Collector-Emitter or Drain-Source). Small control signal → large current flow or blockage.",
            "why": "This is how we compute! By controlling current flow with another electrical signal (not a mechanical switch), we can build circuits that control other circuits—the essence of logic.",
            "analogy": "Like a water faucet: a small twist of your hand (control signal) controls a large water flow (main current). The hand does little work, but controls lots of water."
          },
          {
            "term": "BJT (Bipolar Junction Transistor)",
            "definition": "BJT is a current-controlled transistor. 'Bipolar' means it uses two types of charge carriers (electrons and holes). 'Junction' refers to the P-N boundaries between its three layers (Base, Collector, Emitter). A small current flowing into the Base controls a much larger current between Collector and Emitter.",
            "why": "BJTs were the first mass-produced transistors. They provide high current gain and are very fast, but they consume more power than MOSFETs because the Base needs a continuous current to stay ON.",
            "analogy": "Like a lever that requires you to keep pushing it (continuous current) to keep a heavy gate open."
          },
          {
            "term": "MOSFET (Metal-Oxide-Semiconductor FET)",
            "definition": "MOSFET is a voltage-controlled transistor. Its name describes its structure: a 'Metal' gate, an 'Oxide' insulator, and a 'Semiconductor' channel. The 'FET' (Field-Effect Transistor) part means an electric field from the gate controls current flow without needing any direct current to enter the gate itself.",
            "why": "MOSFETs are the foundation of modern digital logic. Because the gate is insulated by an oxide layer, it draws almost zero power to stay ON—allowing us to put billions of them on a single chip without overheating.",
            "analogy": "Like a light switch that stays in its position once you flip it, requiring no further energy to keep the lights on."
          },
          {
            "term": "FET (Field-Effect Transistor)",
            "definition": "A FET is a transistor in which an electric field controls the flow of current. It has three terminals: Gate (G), Source (S), and Drain (D). Applying a voltage to the Gate creates an electric field that modulates the conductivity between Source and Drain, allowing or blocking current flow.",
            "why": "FETs are the most common type of transistor in digital logic. Unlike BJTs, which are controlled by current, FETs are controlled by voltage at the Gate, making them much more power-efficient. Understanding the role of each terminal is crucial for circuit design.",
            "analogy": "Imagine a water pipe (Source to Drain) with a flexible wall. The Gate acts like a hand squeezing the pipe: when you press (apply voltage), you can stop or allow water (current) to flow.",
            "terminals": {
              "Gate (G)": "The control terminal. Voltage applied here creates an electric field that opens or closes the channel.",
              "Source (S)": "Where carriers enter the channel. This is the reference terminal for the Gate voltage.",
              "Drain (D)": "Where carriers leave the channel. Current flows from Source to Drain when the channel is open."
            }
          }
        ],
        "formulaCards": [
          {
            "name": "BJT Current Gain",
            "variables": [
              {
                "symbol": "I_{C}",
                "meaning": "Collector current (main controlled current)",
                "units": "Amperes"
              },
              {
                "symbol": "β",
                "meaning": "Current gain (typically 50-300)",
                "units": "dimensionless"
              },
              {
                "symbol": "I_{B}",
                "meaning": "Base current (small control current)",
                "units": "Amperes"
              }
            ],
            "meaning": "A tiny base current controls a much larger collector current. This 'amplification' is what makes transistors useful—small signals control large ones.",
            "example": {
              "problem": "A transistor has β = 100. If the base current is 0.1mA, what is the collector current?",
              "given": [
                "β = 100",
                "I_B= 0.1mA = 0.0001A"
              ],
              "steps": [
                "1. Convert to base units: I_{B} = 0.1mA = 0.1 \\times 10⁻³ A = 0.0001 A",
                "2. Apply gain formula: I_{C} = β \\times I_{B}",
                "3. Calculate: I_{C} = 100 \\times 0.0001 A = 0.01 A",
                "4. Result in mA: 0.01 A = 10mA"
              ],
              "answer": "I_C = 10mA — the transistor amplifies the current by 100×"
            },
            "latex": "I_{C} = β \\times I_{B}",
            "html": null
          },
          {
            "name": "Base-Emitter Turn-On Voltage",
            "variables": [
              {
                "symbol": "V_{BE}",
                "meaning": "Voltage between Base and Emitter",
                "units": "Volts"
              }
            ],
            "meaning": "For a silicon BJT to turn ON (conduct), the base must be ~0.7V higher than the emitter. This is the P-N junction's built-in voltage that must be overcome.",
            "derivation": "This 0.7V comes from the physics of the silicon P-N junction—the energy barrier that electrons must overcome to cross from N to P type material.",
            "latex": "V_{BE} ≈ 0.7V (for silicon)",
            "html": null
          },
          {
            "name": "MOSFET Threshold Voltage",
            "variables": [
              {
                "symbol": "I_{D}",
                "meaning": "Drain current",
                "units": "Amperes"
              },
              {
                "symbol": "V_{GS}",
                "meaning": "Gate-to-Source voltage",
                "units": "Volts"
              },
              {
                "symbol": "V_{th}",
                "meaning": "Threshold voltage (~0.3-0.7V)",
                "units": "Volts"
              }
            ],
            "meaning": "A MOSFET acts as an open switch until gate voltage exceeds the threshold. Then a conducting channel forms and current can flow.",
            "example": {
              "problem": "A MOSFET has V_th = 0.5V. Will it conduct if V_GS = 0.3V? What about V_GS = 1.2V?",
              "given": [
                "V_th = 0.5V"
              ],
              "steps": [
                "Compare V_{GS} to V_{th}",
                "If V_{GS} = 0.3V: 0.3V < 0.5V → OFF (no conduction)",
                "If V_{GS} = 1.2V: 1.2V > 0.5V → ON (conducts)"
              ],
              "answer": "V_GS = 0.3V → OFF; V_GS = 1.2V → ON"
            },
            "latex": "I_{D} = 0 when V_{GS} < V_{th}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\">0</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">GS</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "A transistor with β = 150 needs to supply 30mA to an LED. What minimum base current is required?",
            "hint": "Rearrange I_C = β × I_B to find I_B",
            "answer": "I_B = I_C / β = 30mA / 150 = 0.2mA"
          },
          {
            "question": "Why does a MOSFET use almost zero power at its gate compared to a BJT's base?",
            "hint": "Think about what the gate is separated by (oxide = insulator) vs the base (semiconductor junction)",
            "answer": "The MOSFET gate is insulated by oxide—no DC current flows into it. The BJT base is a semiconductor junction that requires continuous current to stay ON. This makes MOSFETs ideal for low-power circuits with billions of transistors."
          },
          {
            "question": "Why can't pure silicon be used as a practical switch material? What does doping accomplish?",
            "hint": "How many free carriers does pure silicon have at room temperature?",
            "answer": "Pure silicon has very few free carriers (~10¹⁰/cm³) so it's nearly an insulator. Doping adds ~10¹⁷ carriers/cm³—a million times more—making it conductive enough to carry useful current while still being controllable."
          }
        ],
        "realWorld": {
          "context": "Modern processors contain billions of transistors, each acting as a tiny switch that can turn on/off billions of times per second.",
          "example": "Apple's M2 chip contains 20 billion transistors, each with features just 5 nanometers wide—about 10 atoms across. These transistors switch on/off 3 billion times per second.",
          "numbers": "The first transistor (1947) was the size of a fingertip. Today's transistors are so small that 100 million fit on a pinhead. This miniaturization follows Moore's Law: transistor count doubles roughly every 2 years.",
          "connection": "In this level, you're using a transistor as a simple switch: control input determines if signal passes through. This exact principle—repeated billions of times—powers every computer."
        }
      },
      "variants": {
        "easy": {
          "availableGates": [
            "transistor"
          ]
        },
        "medium": {
          "title": "Pass Gate Logic",
          "objective": "Build a bidirectional switch",
          "description": "Create a transmission gate that can pass signals in either direction when enabled. Connect data through when control is HIGH, block when LOW.",
          "introText": "A TRANSMISSION GATE (or Pass Gate) is different from a regular transistor switch. While a standard NMOS transistor passes logic '0' well but weakens logic '1', a transmission gate (NMOS + PMOS in parallel) passes both levels perfectly. This is used in multiplexers and analog switches. Here, simulate this behavior using transistors.",
          "physicsVisual": "transmission_gate",
          "hint": "When Enable=1, output should equal Data input. When Enable=0, output is 0 (disconnected state in simulation). Use transistors strategically.",
          "maxGates": 2,
          "xpReward": 30
        },
        "hard": {
          "title": "CMOS Logic: AND-OR-INVERT (AOI)",
          "objective": "Build an AOI21 gate: OUT = NOT((A AND B) OR C)",
          "description": "Implement a compound AOI (AND-OR-INVERT) gate using only transistors. This optimized CMOS structure is faster and smaller than using separate gates.",
          "introText": "In real VLSI design, complex gates like AOI (AND-OR-INVERT) are built directly from transistors rather than cascading simpler gates. AOI21 means (A AND B) OR C, then INVERT. This single-stage design is faster than building it from separate gates because it has fewer transistor stages. Every CPU uses thousands of these optimized compound gates.",
          "physicsVisual": "cmos_aoi",
          "hint": "Build the function: OUT = NOT((A AND B) OR C). Chain transistors in series for AND, parallel for OR. Remember to invert at the end.",
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                0
              ]
            }
          ],
          "maxGates": 4,
          "xpReward": 50
        }
      }
    },
    {
      "id": "level_03",
      "tier": "tier_1",
      "title": "The Inverter (NOT)",
      "objective": "Invert the signal",
      "description": "Output the opposite of the input.",
      "introText": "The NOT gate (inverter) is the simplest logic gate: it flips HIGH to LOW, and LOW to HIGH. Its implementation reveals why CMOS (Complementary Metal-Oxide-Semiconductor) technology dominates modern electronics—the clever pairing of two different transistor types that together consume almost no power when not switching.",
      "physicsVisual": "cmos_inverter",
      "hint": "Use the NOT gate.",
      "availableGates": [
        "not"
      ],
      "inputs": 1,
      "targetTruthTable": [
        {
          "in": [
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1
          ],
          "out": [
            0
          ]
        }
      ],
      "maxGates": 1,
      "xpReward": 20,
      "storyText": "You've built an inverter—the fundamental building block for more complex gates. The CMOS inverter is elegant: it uses paired transistors that never conduct simultaneously, so it draws almost no static power. This is why your phone battery lasts all day despite having billions of transistors: they only consume power when actually switching.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "VDD and GND (Power Supply)",
            "definition": "VDD stands for 'Voltage Drain Drain' (referencing the supply connected to the Drain terminals of Field-Effect Transistors) and represents the positive supply voltage (typically 1V-5V). GND stands for 'Ground' and represents the zero-voltage reference point (0V). Together, they provide the potential difference (pressure) that powers all circuit operations.",
            "why": "Every circuit needs a power source to move charges. VDD provides the 'high' energy level, and GND provides the 'low' return path to complete the loop. All logic voltages are measured relative to GND.",
            "analogy": "Like water pressure: VDD is the elevated water tank (high potential), and GND is the drain at the bottom (zero potential). Current flows from VDD toward GND only when a switch (transistor) opens a path.",
            "latex": "Supply Voltage (V_{supply}) = VDD - GND",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ppl</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">lt</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">ppl</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">DD</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">GN</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>"
          },
          {
            "term": "CMOS (Complementary MOS)",
            "definition": "CMOS stands for 'Complementary Metal-Oxide-Semiconductor'. It represents a circuit design using paired NMOS (N-channel) and PMOS (P-channel) transistors. 'Complementary' means they work in pairs: when one is ON, the other is OFF, ensuring no direct path exists from VDD to GND.",
            "why": "This design is the secret to low-power electronics. Because one transistor in the pair is always OFF, the circuit consumes almost no power when it's not switching between states—allowing your phone battery to last much longer.",
            "analogy": "Like a door with a spring that keeps it closed. You only use energy to push it open; once you let go, it returns to a stable state without using more energy.",
            "visuals": [
              {
                "type": "cmos_inverter",
                "title": "CMOS Inverter: Pull-up / Pull-down"
              }
            ]
          },
          {
            "term": "Pull-Up and Pull-Down Networks",
            "definition": "CMOS circuits use two 'networks' of transistors: The PMOS network (P-channel MOS) 'pulls up' the output to VDD (Logic 1), and the NMOS network (N-channel MOS) 'pulls down' the output to GND (Logic 0).",
            "why": "This complementary structure ensures the output is always actively driven to a valid logic level—it's never 'floating' (unconnected) and never short-circuited.",
            "analogy": "Like a tug-of-war where only one team pulls at a time. The rope (output) is always pulled firmly to either the HIGH side or the LOW side."
          },
          {
            "term": "Capacitance (C)",
            "definition": "The ability to store charge. Measured in Farads (F). Real gates have small 'parasitic' capacitance that must be charged to change voltage.",
            "why": "Charging this capacitance takes energy and time. This causes delay and power consumption.",
            "analogy": "Like filling a bucket (capacitor) with a hose. You can't instantly fill it; it takes time.",
            "latex": "C = \\frac{Q}{V}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2694em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9244em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">Q</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>"
          },
          {
            "term": "Power (P) in Watts",
            "definition": "Rate of energy use. Measured in Watts (W). 1 Watt = 1 Joule/second.",
            "why": "Critical for battery life and cooling. Chips produce heat because they consume power.",
            "latex": "P = \\frac{E}{t}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2173em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8723em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">E</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>"
          },
          {
            "term": "Frequency (f) and Period (T)",
            "definition": "Frequency is the number of cycles per second, measured in Hertz (Hz). Period is the time for one cycle, measured in seconds (s). 1 GHz = 10⁹ Hz, and 1 ns = 10⁻⁹ s. The relationship is f = 1/T, where f is frequency in Hz and T is period in seconds. For example: If something takes 1 second per cycle, frequency = 1/1 = 1 Hz. If something takes 0.25 seconds per cycle, frequency = 1/0.25 = 4 Hz. If something takes 250 ps (250 × 10⁻¹² s) per cycle, frequency = 1/(250 × 10⁻¹²) = 4 × 10⁹ Hz = 4 GHz.",
            "why": "Determines calculation speed. Higher frequency means more processing per second. Clock period determines the duration of each 'heartbeat' of the CPU.",
            "latex": "f = \\frac{1}{T}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1901em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>"
          },
          {
            "term": "Static Power vs Dynamic Power",
            "definition": "Static power = power consumed while holding a state (ideally zero in CMOS). Dynamic power = power consumed during switching (charging/discharging capacitances).",
            "why": "CMOS's near-zero static power was revolutionary. Before CMOS, chips drew power even when idle. Now a chip can have billions of transistors but only consume power for the transistors actually switching.",
            "latex": "P_{dynamic} = C \\times V² \\times f",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathnormal mtight\">nami</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>"
          },
          {
            "term": "Noise Margin",
            "definition": "The 'safety buffer' between what a gate outputs as HIGH/LOW and what the next gate requires as a valid HIGH/LOW input. Larger margin = more immunity to electrical noise.",
            "why": "Real circuits have noise (crosstalk, power supply ripple, etc.). Noise margins ensure that small disturbances don't flip bits incorrectly—critical for reliable computing.",
            "analogy": "Like requiring 'definitely hot' (>80°C) or 'definitely cold' (<20°C) instead of exact temperatures. The gap (20-80°C) is where we're uncertain, so we avoid it."
          },
          {
            "term": "Vacuum Tubes (Historical Switch)",
            "definition": "Before transistors, computers used vacuum tubes: heated cathodes emit electrons (thermionic emission) and a control grid modulates the electron flow to an anode.",
            "why": "Vacuum tubes proved that electrical signals can control other electrical signals (gain/switching), but they were hot, large, fragile, and power-hungry. CMOS replaces them with tiny solid-state devices.",
            "analogy": "Like controlling airflow with a valve in a hollow pipe: the grid is the valve, the electron stream is the airflow.",
            "visuals": [
              {
                "type": "vacuum_tube",
                "title": "Thermionic Emission (Historical Switch)"
              }
            ]
          }
        ],
        "formulaCards": [
          {
            "name": "CMOS Dynamic Power",
            "variables": [
              {
                "symbol": "P",
                "meaning": "Power dissipated during switching",
                "units": "Watts (W)"
              },
              {
                "symbol": "C",
                "meaning": "Load capacitance (gate + wiring)",
                "units": "Farads (F)"
              },
              {
                "symbol": "V",
                "meaning": "Supply voltage",
                "units": "Volts (V)"
              },
              {
                "symbol": "f",
                "meaning": "Switching frequency",
                "units": "Hertz (Hz)"
              }
            ],
            "meaning": "Power consumption scales with voltage SQUARED. This is why CPUs use lower voltages (1V instead of 5V) to save power. It also scales linearly with frequency—faster clocks = more power.",
            "example": {
              "problem": "A gate has C = 10fF, V = 1V, switches at f = 1GHz. Calculate power.",
              "given": [
                "C = 10×10⁻¹⁵ F",
                "V = 1V",
                "f = 10⁹ Hz"
              ],
              "steps": [
                "1. Convert units to Base SI: C = 10fF = 10 \\times 10⁻¹⁵ F; f = 1GHz = 10⁹ Hz",
                "2. Apply formula P = C \\times V² \\times f",
                "3. Substitute: P = (10 \\times 10⁻¹⁵ F) \\times (1V)² \\times (10⁹ Hz)",
                "4. Multiply powers of 10: P = 10 \\times 1 (1²) \\times 10⁻¹⁵⁺⁹ = 10 \\times 10⁻⁶ W",
                "5. Convert to microwatts: 10 \\times 10⁻⁶ W = 10 μW"
              ],
              "answer": "10 μW per gate. Scaling up: 10 billion gates (10¹⁰) × 10 μW = 100,000 W or 100 kW. (Note: In real chips, an 'activity factor' reduces this as not all gates switch at once)."
            },
            "latex": "P = C \\times V² \\times f",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>"
          },
          {
            "name": "CMOS Static Power (Ideal)",
            "variables": [],
            "meaning": "In an ideal CMOS circuit, one transistor is always OFF, blocking any DC current path from VDD to GND. Real circuits have tiny leakage currents, but static power is vastly less than older technologies.",
            "derivation": "When input is LOW: PMOS ON (connects VDD to output), NMOS OFF (blocks path to GND). When input is HIGH: NMOS ON, PMOS OFF. There's never a complete path from VDD to GND.",
            "latex": "P_{static} ≈ 0",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>"
          },
          {
            "name": "Noise Margin (HIGH)",
            "variables": [
              {
                "symbol": "NM_{H}",
                "meaning": "Noise margin for HIGH signals",
                "units": "Volts"
              },
              {
                "symbol": "V_{OH}",
                "meaning": "Output HIGH voltage (minimum guaranteed)",
                "units": "Volts"
              },
              {
                "symbol": "V_{IH}",
                "meaning": "Input HIGH threshold (minimum required)",
                "units": "Volts"
              }
            ],
            "meaning": "The output must be at least V_OH, but the next gate only needs V_IH to recognize HIGH. The difference is safety margin—noise up to this amount won't cause errors.",
            "example": {
              "problem": "If V_OH = 4.4V and V_IH = 3.5V, what is the noise margin for HIGH?",
              "given": [
                "V_OH = 4.4V",
                "V_IH = 3.5V"
              ],
              "steps": [
                "NM_{H} = V_{OH} - V_{IH}",
                "NM_{H} = 4.4V - 3.5V = 0.9V"
              ],
              "answer": "0.9V of noise margin—signals can be corrupted by up to 0.9V and still be read correctly"
            },
            "latex": "NM_{H} = V_{OH} - V_{IH}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "A chip has 1 billion gates, each with C = 5fF, running at 3GHz with V = 0.8V. Estimate the total dynamic power consumption.",
            "hint": "Calculate per-gate power, then multiply by number of active gates (assume 30% switch per cycle)",
            "answer": {
              "steps": [
                "Step 1: Convert all values to SI units. C = 5 fF = 5 × 10⁻¹⁵ F; V = 0.8 V; f = 3 GHz = 3 × 10⁹ Hz.",
                "Step 2: Calculate per-gate power. P = C × V² × f = (5 × 10⁻¹⁵ F) × (0.8 V)² × (3 × 10⁹ Hz) = (5 × 0.64 × 3) × 10⁻¹⁵ × 10⁹ W = 9.6 × 10⁻⁶ W = 9.6 μW per gate.",
                "Step 3: Find number of active gates. 1 billion gates × 30% activity = 10⁹ × 0.3 = 3 × 10⁸ gates.",
                "Step 4: Calculate total power. Total = (3 × 10⁸) × (9.6 × 10⁻⁶ W) = 2,880 W = 2.88 kW."
              ],
              "answer": "2.88 kW"
            }
          },
          {
            "question": "Why do lower supply voltages dramatically reduce power consumption?",
            "hint": "Look at how V appears in the power formula",
            "answer": {
              "steps": [],
              "answer": "Power ∝ V². Halving voltage (5V→2.5V) reduces power by 4×, not 2×. This is why modern CPUs use ~1V instead of the 5V of early computers."
            }
          },
          {
            "question": "Complete the truth table for a NOT gate: Input=0 → Output=? Input=1 → Output=?",
            "hint": "The output is always the opposite of the input",
            "answer": {
              "steps": [],
              "answer": "Input=0 → Output=1; Input=1 → Output=0"
            }
          }
        ],
        "realWorld": {
          "context": "The CMOS inverter revolutionized electronics by enabling low-power chips with billions of transistors.",
          "example": "ENIAC (1945) used 17,468 vacuum tubes and consumed 150 kilowatts—enough to power 100 homes. A modern smartphone chip has 15 billion transistors but uses less than 5 watts.",
          "numbers": "This represents a 10-billion-fold improvement in transistors-per-watt over 80 years. The CMOS inverter's complementary design—where only one transistor conducts at a time—is the key enabler.",
          "connection": "In this level, you're using a NOT gate—the simplest CMOS circuit. Every complex processor is built from combinations of these basic inverters and similar gates."
        }
      },
      "variants": {
        "easy": {
          "availableGates": [
            "transistor",
            "not"
          ]
        },
        "medium": {
          "title": "Double Negation",
          "objective": "Prove NOT(NOT(A)) = A",
          "description": "Apply two NOT gates in series to demonstrate the double negation law. This fundamental identity is used in Boolean algebra simplification.",
          "introText": "DOUBLE NEGATION is a fundamental identity in Boolean algebra and propositional logic. Two inversions cancel out: ¬(¬A) = A. In circuits, this seems wasteful—why add two inverters just to get the original signal? But in 'bubble pushing' optimization, recognizing these pairs lets us eliminate unnecessary gates and reduce both power and delay.",
          "physicsVisual": "double_negation",
          "hint": "Connect Input → NOT → NOT → Output. Both test cases should show that the output equals the input, proving double negation.",
          "availableGates": [
            "transistor",
            "not"
          ],
          "targetTruthTable": [
            {
              "in": [
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 30
        },
        "hard": {
          "title": "Controlled Inverter",
          "objective": "Invert signal when enabled",
          "description": "Build a circuit that outputs NOT(A) when Enable=1, and outputs 0 when Enable=0. This is a gated inverter used in bus drivers.",
          "introText": "In bus architectures, multiple devices share the same wires but only one can drive at a time. A TRI-STATE BUFFER or GATED INVERTER solves this: when not enabled, the output is effectively disconnected (simulated here as 0). When enabled, it drives the inverted signal. This controlled output prevents bus contention in shared communication lines.",
          "physicsVisual": "tristate_inverter",
          "hint": "When En=0, output is 0 regardless of A. When En=1, output = NOT(A). Combine NOT and transistor logic: use Enable to gate the inverted signal.",
          "availableGates": [
            "transistor",
            "not"
          ],
          "inputs": 2,
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ]
            }
          ],
          "maxGates": 3,
          "xpReward": 50
        }
      }
    },
    {
      "id": "level_04",
      "tier": "tier_1",
      "title": "AND Gate",
      "objective": "Both inputs must be HIGH",
      "description": "Output 1 only if Input A AND Input B are 1.",
      "introText": "The AND gate outputs HIGH only when ALL its inputs are HIGH. Think of it as a series of requirements—everything must be true for the output to be true. Physically, this is like switches in series: current only flows if every switch is closed.",
      "physicsVisual": "series_circuit_detailed",
      "hint": "Connect both inputs to the AND gate.",
      "availableGates": [
        "and"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            1
          ]
        }
      ],
      "maxGates": 1,
      "xpReward": 25,
      "storyText": "You've mastered the AND gate—the 'both must agree' gate. AND gates are everywhere in computing: checking if multiple conditions are true, masking specific bits in data, controlling when actions should happen. Combined with OR and NOT, AND can express any Boolean function.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Series Circuit",
            "definition": "Components connected end-to-end so current must flow through ALL of them. If any component fails (opens), the entire current path breaks.",
            "why": "A series circuit is a direct physical analogy for AND logic: current can only flow (output = 1) if every switch in the chain is closed. If even one switch is open, the path is broken and no current flows (output = 0). This means all conditions must be true for the result to be true—just like AND logic in electronics and computing.",
            "analogy": "Like a chain of doors you must pass through—if ANY door is locked, you can't reach the end.",
            "visuals": [
              {
                "type": "series_circuit_detailed",
                "title": "Series Path: AND (Both Must Conduct)"
              }
            ]
          },
          {
            "term": "Boolean AND Operation",
            "definition": "A logical operation that outputs TRUE (1) only when ALL inputs are TRUE. Written as A·B, A∧B, or A AND B.",
            "why": "AND is one of three fundamental operations (with OR and NOT) that can express any computable function. It's essential for decision-making in circuits.",
            "latex": "Y = A \\cdot B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "term": "Truth Table",
            "definition": "A table listing ALL possible input combinations and their corresponding outputs. For n inputs, there are 2^n rows.",
            "why": "Truth tables completely define a logic function. They're the specification that your circuit must match. For AND with 2 inputs: 4 rows (00→0, 01→0, 10→0, 11→1).",
            "analogy": "Like a lookup table: given inputs, look up the correct output."
          },
          {
            "term": "Basic Logic Gate Truth Tables",
            "definition": "Complete truth tables for the fundamental logic gates that form the foundation of all digital circuits.",
            "why": "These six gates (AND, OR, NOT, NAND, NOR, XOR) can express any Boolean function. Their truth tables are the building blocks for understanding and designing digital logic.",
            "tables": {
              "AND": {
                "symbol": "∧",
                "alt_symbols": [
                  "·",
                  "&"
                ],
                "table": [
                  {
                    "A": 0,
                    "B": 0,
                    "Y": 0
                  },
                  {
                    "A": 0,
                    "B": 1,
                    "Y": 0
                  },
                  {
                    "A": 1,
                    "B": 0,
                    "Y": 0
                  },
                  {
                    "A": 1,
                    "B": 1,
                    "Y": 1
                  }
                ]
              },
              "OR": {
                "symbol": "∨",
                "alt_symbols": [
                  "+"
                ],
                "table": [
                  {
                    "A": 0,
                    "B": 0,
                    "Y": 0
                  },
                  {
                    "A": 0,
                    "B": 1,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "B": 0,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "B": 1,
                    "Y": 1
                  }
                ]
              },
              "NOT": {
                "symbol": "¬",
                "alt_symbols": [
                  "~",
                  "′"
                ],
                "table": [
                  {
                    "A": 0,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "Y": 0
                  }
                ]
              },
              "NAND": {
                "symbol": "⊼",
                "alt_symbols": [
                  "↑"
                ],
                "table": [
                  {
                    "A": 0,
                    "B": 0,
                    "Y": 1
                  },
                  {
                    "A": 0,
                    "B": 1,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "B": 0,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "B": 1,
                    "Y": 0
                  }
                ]
              },
              "NOR": {
                "symbol": "⊽",
                "alt_symbols": [
                  "↓"
                ],
                "table": [
                  {
                    "A": 0,
                    "B": 0,
                    "Y": 1
                  },
                  {
                    "A": 0,
                    "B": 1,
                    "Y": 0
                  },
                  {
                    "A": 1,
                    "B": 0,
                    "Y": 0
                  },
                  {
                    "A": 1,
                    "B": 1,
                    "Y": 0
                  }
                ]
              },
              "XOR": {
                "symbol": "⊕",
                "alt_symbols": [
                  "⊻"
                ],
                "table": [
                  {
                    "A": 0,
                    "B": 0,
                    "Y": 0
                  },
                  {
                    "A": 0,
                    "B": 1,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "B": 0,
                    "Y": 1
                  },
                  {
                    "A": 1,
                    "B": 1,
                    "Y": 0
                  }
                ]
              }
            }
          },
          {
            "term": "Bit Masking",
            "definition": "A technique using bitwise operations to manipulate individual bits within binary data. AND masks extract bits, OR masks set bits, XOR masks toggle bits, and shifts move bit positions.",
            "why": "Bit masking is fundamental to digital systems: CPUs use it for data extraction, flag management, and arithmetic. It's the hardware implementation of bitwise operators in programming languages, enabling efficient data manipulation at the transistor level.",
            "operations": {
              "AND (&)": {
                "purpose": "Extract or clear specific bits",
                "example": "data & mask keeps bits where mask=1, clears where mask=0",
                "use_case": "Extracting fields from packed data structures"
              },
              "AND for checking": {
                "purpose": "Check if a specific bit is set (1) at a position",
                "example": "If (data & mask) is not zero, the bit was 1; if zero, the bit was 0.",
                "use_case": "Testing flags, conditions, or extracting a single bit value"
              },
              "OR (|)": {
                "purpose": "Set specific bits to 1",
                "example": "data | mask forces bits to 1 where mask=1",
                "use_case": "Setting flags or combining bit fields"
              },
              "OR for masking": {
                "purpose": "Ensure certain bits are set to 1 regardless of their previous value",
                "example": "data | mask sets bits to 1 where mask=1, leaves others unchanged.",
                "use_case": "Turning on features, combining options"
              },
              "XOR (^)": {
                "purpose": "Toggle specific bits",
                "example": "data ^ mask flips bits where mask=1",
                "use_case": "Error detection (parity) and encryption"
              },
              "XOR for masking": {
                "purpose": "Flip (toggle) bits at specific positions",
                "example": "data ^ mask changes bits from 0 to 1 or 1 to 0 where mask=1.",
                "use_case": "Toggling options, switching states"
              },
              "NOT (~)": {
                "purpose": "Invert all bits",
                "example": "~data flips every bit (0→1, 1→0)",
                "use_case": "Two's complement negation and bit inversion"
              },
              "SHIFT (<<, >>)": {
                "purpose": "Move bits left or right",
                "example": "data << n multiplies by 2^n, data >> n divides by 2^n",
                "use_case": "Multiplication/division by powers of 2, bit field positioning"
              }
            },
            "explanation": "Bit masking uses bitwise operations to manipulate or check individual bits. To check if a specific bit is set, use AND with a mask that has a 1 in the target position. If the result is not zero, that bit was 1; if zero, the bit was 0. OR can be used to force bits to 1, and XOR can be used to toggle bits. NOT inverts all bits. SHIFT moves bits left or right. These operations are essential for controlling and reading individual bits in digital systems.",
            "formulas": {
              "AND (&)": "result = data & mask; e.g., 10110101 & 00010000 = 00010000 (extracts bit 4)",
              "OR (|)": "result = data | mask; e.g., 10110101 | 00010000 = 10110101 (sets bit 4 to 1)",
              "XOR (^)": "result = data ^ mask; e.g., 10110101 ^ 00010000 = 10100101 (toggles bit 4)",
              "NOT (~)": "result = ~data; e.g., ~10110101 = 01001010 (inverts all bits)",
              "SHIFT LEFT (<<)": "result = data << n; e.g., 10110101 << 1 = 01101010 (shifts left by 1, multiplies by 2)",
              "SHIFT RIGHT (>>)": "result = data >> n; e.g., 10110101 >> 1 = 01011010 (shifts right by 1, divides by 2)"
            },
            "applications": [
              "Extracting specific bits from registers or memory",
              "Setting/clearing status flags in CPU control registers",
              "Implementing arithmetic operations (multiplication by powers of 2)",
              "Data compression and encoding schemes",
              "Hardware-level encryption and error correction"
            ],
            "hardware_connection": "Every bitwise operation corresponds to parallel logic gates operating on each bit simultaneously. An 8-bit AND operation uses 8 AND gates in parallel, executing in a single clock cycle.",
            "latex": "bit = (data AND mask)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "SI Prefixes for Time",
            "definition": "Standard prefixes for small time units: ms (milli) = 10⁻³s, μs (micro) = 10⁻⁶s, ns (nano) = 10⁻⁹s, ps (pico) = 10⁻¹²s.",
            "why": "Modern circuits switch in nanoseconds or picoseconds. 1 GHz = 1 ns period. Understanding these scales is essential for timing analysis.",
            "latex": "1 second = 10³ ms = 10⁶ μs = 10⁹ ns = 10¹² ps",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\">seco</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">μ</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">9</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">12</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">s</span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "Series Resistance",
            "variables": [
              {
                "symbol": "R_{total}",
                "meaning": "Total resistance of series combination",
                "units": "Ohms (Ω)"
              },
              {
                "symbol": "R_{1}, R_{2}",
                "meaning": "Individual resistor values",
                "units": "Ohms (Ω)"
              }
            ],
            "meaning": "In series, resistances ADD. More resistors in series = harder for current to flow = higher total resistance.",
            "example": {
              "problem": "Three resistors of 100Ω, 220Ω, and 330Ω are in series. What is the total resistance?",
              "given": [
                "R₁ = 100Ω",
                "R₂ = 220Ω",
                "R₃ = 330Ω"
              ],
              "steps": [
                "R_{total} = R_{1} + R_{2} + R_{3}",
                "R_{total} = 100 + 220 + 330 = 650Ω"
              ],
              "answer": "650Ω"
            },
            "latex": "R_{total} = R_{1} + R_{2} + R_{3} + \\ldots",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.123em;\"></span><span class=\"minner\">…</span></span></span></span>"
          },
          {
            "name": "Propagation Delay",
            "variables": [
              {
                "symbol": "t_{pd}",
                "meaning": "Propagation delay (time for output to change)",
                "units": "seconds"
              },
              {
                "symbol": "R_{on}",
                "meaning": "Transistor's on-resistance",
                "units": "Ohms (Ω)"
              },
              {
                "symbol": "C_{load}",
                "meaning": "Capacitance being charged/discharged",
                "units": "Farads (F)"
              }
            ],
            "meaning": "Output doesn't change instantly—it takes time to charge/discharge parasitic capacitances. This is governed by the RC time constant (τ = R × C), where R is resistance and C is capacitance; τ gives the characteristic time for a capacitor to charge or discharge and therefore limits how fast the circuit can switch. When a logic function is implemented with multiple stages in series (for example, an AND implemented as a NAND gate followed by an inverter), the total propagation delay is the sum of each stage's delays: t_pd(total) = t_pd(NAND) + t_pd(INV).",
            "example": {
              "problem": "A gate has R_on = 1kΩ and C_load = 10fF. Estimate the propagation delay.",
              "given": [
                "R_on = 1000Ω",
                "C_load = 10×10⁻¹⁵ F"
              ],
              "steps": [
                "t_{pd} = R_{on} \\times C_{load}",
                "t_{pd} = 1000 \\times 10\\times10⁻¹⁵ = 10\\times10⁻¹² s = 10ps"
              ],
              "answer": "~10 picoseconds"
            },
            "latex": "t_{pd} = R_{on} \\times C_{load}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "name": "Maximum Frequency",
            "variables": [
              {
                "symbol": "f_{max}",
                "meaning": "Maximum operating frequency",
                "units": "Hertz (Hz)"
              },
              {
                "symbol": "t_{pd}",
                "meaning": "Total propagation delay through the path",
                "units": "seconds"
              }
            ],
            "meaning": "You can't clock a circuit faster than signals can propagate. The slowest path (critical path) determines maximum frequency.",
            "example": {
              "problem": "If propagation delay is 250ps, what is the maximum frequency?",
              "given": [
                "t_pd = 250ps = 250 × 10⁻¹² s"
              ],
              "steps": [
                "1. Apply formula f_{max} = \\frac{1}{t_{pd}}",
                "2. Substitute: f_{max} = 1 / (250 \\times 10⁻¹² s)",
                "3. Calculate in Hz: \\frac{1}{250} \\times 10¹² = 0.004 \\times 10¹² = 4 \\times 10⁹ Hz",
                "4. Convert to GHz: 4 \\times 10⁹ Hz = 4 GHz"
              ],
              "answer": "4 GHz"
            },
            "latex": "f_{max} = \\frac{1}{t_{pd}}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">ma</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3932em;vertical-align:-0.5481em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3488em;margin-left:0em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2901em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5481em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "Complete the AND truth table: A=0,B=0→? A=0,B=1→? A=1,B=0→? A=1,B=1→?",
            "hint": "AND outputs 1 only when both inputs are 1",
            "answer": "00→0, 01→0, 10→0, 11→1"
          },
          {
            "question": "You have an 8-bit byte = 10110101. You want to extract only bit 4 (counting from 0). What mask do you AND with?",
            "hint": "The mask should have a 1 only in position 4 (which is 2^4 = 16 in decimal, or 00010000 in binary)",
            "answer": {
              "steps": [
                "Bit 4 means the mask has a 1 only at position 4: 00010000 (binary) = 0x10 (hex) = 16 (decimal).",
                "Apply AND: 10110101 AND 00010000 keeps only bit 4 and clears all other bits.",
                "Result is 00010000, which means bit 4 was 1 in the original byte."
              ],
              "answer": "00010000 (binary) = 0x10 (hex) = 16 (decimal)"
            }
          },
          {
            "question": "A CMOS AND gate is built from a NAND + inverter. If NAND delay is 50ps and inverter delay is 30ps, what is the AND gate's propagation delay?",
            "hint": "Delays in series ADD",
            "answer": "t_pd(AND) = t_pd(NAND) + t_pd(INV) = 50ps + 30ps = 80ps"
          }
        ],
        "realWorld": {
          "context": "AND gates are used whenever multiple conditions must all be true before taking action.",
          "example": "When your CPU executes 'if (x > 5 && y < 10)', it uses AND logic to combine the two conditions. Both must be true for the if-block to execute.",
          "numbers": "A modern CPU performs billions of AND operations per second. A 64-bit comparison uses 64 parallel AND gates to check all bits simultaneously.",
          "connection": "In this level, you're implementing A AND \\bar{B}. This exact operation happens millions of times in a single web page load—checking conditions, masking data, validating inputs."
        }
      },
      "variants": {
        "easy": {
          "availableGates": [
            "transistor",
            "not",
            "and"
          ]
        },
        "medium": {
          "title": "3-Input AND (Cascade)",
          "objective": "All three inputs must be HIGH",
          "description": "Build a 3-input AND gate using 2-input AND gates. Output is 1 only when A AND B AND C are all 1.",
          "introText": "Most logic libraries provide only 2-input gates. To handle more inputs, we CASCADE them: first compute (A AND B), then AND that result with C. This is equivalent to A·B·C due to the associative property of AND. Understanding gate cascading is essential for building complex logic from simple components.",
          "physicsVisual": "cascade_and",
          "hint": "Chain two AND gates: first AND takes A and B, second AND takes that result and C. Total output is A·B·C.",
          "availableGates": [
            "transistor",
            "not",
            "and"
          ],
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 35
        },
        "hard": {
          "title": "Build NAND Gate",
          "objective": "Create NAND using AND and NOT",
          "description": "NAND (NOT-AND) outputs 0 only when both inputs are 1. Build it by inverting an AND gate's output. This prepares you for Level 06 where you'll learn NAND is universal!",
          "introText": "The NAND GATE is arguably the most important gate in computing history. In 1913, Henry Sheffer proved that NAND alone can build ANY logic circuit—it's 'functionally complete.' Early computers like the Apollo Guidance Computer (1966) used only NOR gates for simplicity. Modern chips use NAND-based logic for efficiency. Here you'll build NAND from AND and NOT, understanding why NAND = NOT(A AND B).",
          "physicsVisual": "nand_construction",
          "hint": "NAND = NOT(AND). First compute A AND B, then invert the result with NOT. The output is 0 only when BOTH inputs are 1.",
          "availableGates": [
            "transistor",
            "not",
            "and"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                1
              ],
              "desc": "0 NAND 0 = 1"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                1
              ],
              "desc": "0 NAND 1 = 1"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                1
              ],
              "desc": "1 NAND 0 = 1"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ],
              "desc": "1 NAND 1 = 0 (the only 0 case)"
            }
          ],
          "maxGates": 2,
          "xpReward": 50
        }
      }
    },
    {
      "id": "level_05",
      "tier": "tier_1",
      "title": "OR Gate",
      "objective": "Any input is HIGH",
      "description": "Output 1 if Input A OR Input B is 1.",
      "introText": "The OR gate outputs HIGH when ANY of its inputs is HIGH. Think of it as alternatives—if this OR that is true, the output is true. Physically, this is like switches in parallel: current can flow through any available path.",
      "physicsVisual": "parallel_circuit_detailed",
      "hint": "Connect both inputs to the OR gate.",
      "availableGates": [
        "or"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            1
          ]
        }
      ],
      "maxGates": 1,
      "xpReward": 25,
      "storyText": "You've mastered the OR gate—the 'any will do' gate. With AND, OR, and NOT, you can build ANY digital circuit. OR gates are used for aggregating conditions (any interrupt triggers service), creating redundancy (any path works), and setting bits in data.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Parallel Circuit",
            "definition": "Components connected side-by-side so current can flow through ANY path. Even if some paths fail (open), current can still flow through the remaining ones.",
            "why": "Parallel connection IS OR logic physically: current flows (output=1) if Path_A OR Path_B OR... any path conducts.",
            "analogy": "Like multiple doors to a room—if ANY door is open, you can enter.",
            "visuals": [
              {
                "type": "parallel_circuit_detailed",
                "title": "Parallel Paths: OR (Any Can Conduct)"
              }
            ]
          },
          {
            "term": "Boolean OR Operation",
            "definition": "A logical operation that outputs TRUE (1) when AT LEAST ONE input is TRUE. Written as A+B, A∨B, or A OR B.",
            "why": "OR is inclusive: even if both inputs are true, output is still true (1+1=1 in Boolean algebra, not 2!). This differs from everyday 'or' which often means 'one but not both'.",
            "formula": "Y = A + B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "term": "Kirchhoff's Current Law (KCL)",
            "definition": "At any node (junction) in a circuit, the sum of currents entering equals the sum of currents leaving. Current is conserved.",
            "why": "KCL explains why parallel circuits work: currents from multiple branches combine at a junction. More paths = more total current capability.",
            "formula": "ΣI_{in} = ΣI_{out}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0556em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">Σ</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">in</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0556em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">Σ</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "term": "Fan-In and Fan-Out",
            "definition": "Fan-in = number of inputs a gate accepts. Fan-out = number of gate inputs one output can reliably drive.",
            "why": "Each additional input (fan-in) adds transistors and delay. Each additional load (fan-out) adds capacitance, slowing the driver. Both affect circuit speed.",
            "analogy": "Fan-in: how many people can vote on a decision. Fan-out: how many people one person can effectively communicate with."
          }
        ],
        "formulaCards": [
          {
            "name": "Parallel Resistance",
            "formula": "\\frac{1}{R_{total}} = \\frac{1}{R_{1}} + \\frac{1}{R_{2}} + \\frac{1}{R_{3}} + \\ldots",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.296em;vertical-align:-0.4509em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3488em;margin-left:-0.0077em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1512em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4509em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2902em;vertical-align:-0.4451em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4451em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2902em;vertical-align:-0.4451em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4451em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2902em;vertical-align:-0.4451em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8451em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3173em;\"><span style=\"top:-2.357em;margin-left:-0.0077em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\">3</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4451em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.123em;\"></span><span class=\"minner\">…</span></span></span></span>",
            "variables": [
              {
                "symbol": "R_{total}",
                "meaning": "Total resistance of parallel combination",
                "units": "Ohms (Ω)"
              },
              {
                "symbol": "R_{1}, R_{2}",
                "meaning": "Individual resistor values",
                "units": "Ohms (Ω)"
              }
            ],
            "meaning": "In parallel, resistances combine reciprocally. Total is LESS than the smallest individual resistor. More paths = easier for current = lower resistance.",
            "example": {
              "problem": "Two resistors of 100Ω and 100Ω are in parallel. What is the total resistance?",
              "given": [
                "R₁ = 100Ω",
                "R₂ = 100Ω"
              ],
              "steps": [
                "\\frac{1}{R_{total}} = \\frac{1}{R_{1}} + \\frac{1}{R_{2}}",
                "\\frac{1}{R_{total}} = \\frac{1}{100} + \\frac{1}{100} = \\frac{2}{100} = \\frac{1}{50}",
                "R_{total} = 50Ω"
              ],
              "answer": "50Ω — half of either individual resistor"
            }
          },
          {
            "name": "KCL at a Node",
            "formula": "I_{1} + I_{2} + \\ldots = I_{out}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>",
            "variables": [
              {
                "symbol": "I_{1}, I_{2}",
                "meaning": "Currents entering the node",
                "units": "Amperes (A)"
              },
              {
                "symbol": "I_{out}",
                "meaning": "Current leaving the node",
                "units": "Amperes (A)"
              }
            ],
            "meaning": "Charge is conserved. If 2A flows in from one branch and 3A from another, 5A must flow out.",
            "example": {
              "problem": "A junction has three wires. Wire A brings 2A, Wire B brings 3A. Wire C carries current away. How much flows through C?",
              "given": [
                "I_A = 2A",
                "I_B = 3A"
              ],
              "steps": [
                "1. By KCL, total current in must equal total current out.",
                "2. Equation: I_{in} = I_{out}",
                "3. Substitute: I_{A} + I_{B} = I_{C}",
                "4. Calculate: 2A + 3A = 5A"
              ],
              "answer": "5A flows through wire C"
            }
          },
          {
            "name": "Delay with Fan-Out",
            "formula": "t = t_{0} + t_{load} \\times FO",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">FO</span></span></span></span>",
            "variables": [
              {
                "symbol": "t",
                "meaning": "Total propagation delay",
                "units": "seconds"
              },
              {
                "symbol": "t_{0}",
                "meaning": "Intrinsic gate delay (zero fan-out)",
                "units": "seconds"
              },
              {
                "symbol": "t_{load}",
                "meaning": "Additional delay per unit load",
                "units": "seconds"
              },
              {
                "symbol": "FO",
                "meaning": "Fan-out (number of loads driven)",
                "units": "count"
              }
            ],
            "meaning": "More loads = more capacitance to charge = slower. Delay grows linearly with fan-out. Solutions: add buffers, use larger driver transistors.",
            "example": {
              "problem": "A gate has t₀=20ps and t_load=5ps. If it drives 4 gates, what is the delay?",
              "given": [
                "t₀ = 20ps",
                "t_load = 5ps",
                "FO = 4"
              ],
              "steps": [
                "1. Apply formula t = t_{0} + t_{load} \\times FO",
                "2. Note multiplication order: t = 20ps + (5ps \\times 4)",
                "3. Calculate product: t = 20ps + 20ps",
                "4. Result: 40ps"
              ],
              "answer": "40ps — fan-out doubled the delay"
            }
          }
        ],
        "exercises": [
          {
            "question": "Complete the OR truth table: A=0,B=0→? A=0,B=1→? A=1,B=0→? A=1,B=1→?",
            "hint": "OR outputs 1 when AT LEAST ONE input is 1",
            "answer": "00→0, 01→1, 10→1, 11→1"
          },
          {
            "question": "Two 200Ω resistors are in parallel. A third 200Ω resistor is in series with this parallel combination. What is the total resistance?",
            "hint": "First calculate parallel (1/R_p = 1/R1 + 1/R2), then add the series resistor (R_total = R_p + R_series)",
            "answer": {
              "steps": [
                "1. Parallel block: 1/R_p = 1/200 + 1/200 = 2/200 → R_p = 100Ω.",
                "2. Add series: R_total = 100Ω + 200Ω = 300Ω."
              ],
              "answer": "300Ω"
            }
          },
          {
            "question": "How does OR differ from XOR when both inputs are 1?",
            "hint": "OR is 'inclusive or' — at least one. XOR is 'exclusive or' — exactly one.",
            "answer": "OR(1,1) = 1 (at least one is true). XOR(1,1) = 0 (not exactly one is true)."
          }
        ],
        "realWorld": {
          "context": "OR gates aggregate multiple conditions or signals into a single output.",
          "example": "An interrupt controller uses OR logic: CPU_interrupt = IRQ0 OR IRQ1 OR IRQ2... If ANY device requests service, the CPU is interrupted.",
          "numbers": "Modern CPUs have 256+ interrupt sources. OR trees aggregate these into a single interrupt line, with priority logic determining which to service first.",
          "connection": "In this level, you're implementing A OR B. This operation is used billions of times per second to aggregate signals and detect 'any true' conditions."
        }
      },
      "variants": {
        "easy": {
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or"
          ]
        },
        "medium": {
          "title": "3-Input OR (Cascade)",
          "objective": "Any of three inputs HIGH",
          "description": "Build a 3-input OR gate using 2-input OR gates. Output is 1 when A OR B OR C is 1.",
          "introText": "Just like AND, OR gates can be cascaded due to the associative property: A+B+C = (A+B)+C. This is essential for building interrupt controllers where ANY of multiple signals should trigger a response, or alarm systems where ANY sensor can activate the alert.",
          "physicsVisual": "cascade_or",
          "hint": "Chain two OR gates: first OR takes A and B, second OR takes that result and C. Any single HIGH input produces HIGH output.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or"
          ],
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 35
        },
        "hard": {
          "title": "Majority Gate (2-of-3 Voting)",
          "objective": "Output 1 when majority of inputs are 1",
          "description": "Build a 3-input majority gate: output is 1 when at least 2 of the 3 inputs are 1. This is the fundamental voting circuit used in fault-tolerant systems.",
          "introText": "The MAJORITY GATE is a cornerstone of FAULT-TOLERANT computing. NASA's Space Shuttle (1981-2011) used triple-redundant computers that voted on every decision—if two agreed, that result was used, even if one computer failed. This '2-of-3 voting' principle protects aircraft, nuclear plants, and medical devices. The Boolean expression is: OUT = (A·B) + (B·C) + (A·C). When ANY two inputs agree on HIGH, the output is HIGH.",
          "physicsVisual": "majority_gate",
          "hint": "Majority = (A AND B) OR (B AND C) OR (A AND C). Build three AND gates (one per pair: AB, BC, AC), then combine with two OR gates: ((AB OR BC) OR AC).",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or"
          ],
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "0 votes: minority"
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "1 vote: minority"
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                0
              ],
              "desc": "1 vote: minority"
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "2 votes: MAJORITY"
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "1 vote: minority"
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                1
              ],
              "desc": "2 votes: MAJORITY"
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                1
              ],
              "desc": "2 votes: MAJORITY"
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "3 votes: MAJORITY"
            }
          ],
          "maxGates": 5,
          "xpReward": 60
        }
      }
    },
    {
      "id": "level_06",
      "tier": "tier_2",
      "title": "NAND: The Universal",
      "objective": "Understand NAND",
      "description": "NAND (Not AND) is a universal gate.",
      "introText": "The NAND gate is special: it's UNIVERSAL, meaning you can build ANY other logic gate using only NANDs. This isn't just theoretically interesting—it's why NAND is the dominant gate in chip manufacturing. A NAND gate is the most efficient structure in CMOS technology.",
      "physicsVisual": "nand_universal_detailed",
      "hint": "It is an AND gate followed by a NOT gate.",
      "availableGates": [
        "nand"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            0
          ]
        }
      ],
      "maxGates": 1,
      "xpReward": 30,
      "storyText": "You've encountered the universal gate! The mathematical proof of NAND's universality revolutionized digital design. Instead of needing factories to make AND, OR, and NOT gates separately, we can make only NAND gates and combine them to build any function. This simplicity enabled the integrated circuit revolution.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Universal Gate",
            "definition": "A gate type that can implement ANY Boolean function using only that gate type. NAND and NOR are the only two-input universal gates.",
            "why": "Universality means one manufacturing process, one cell type, simpler design tools. This dramatically reduced the cost and complexity of chip production.",
            "analogy": "Like having Lego blocks that can build anything—you don't need a separate factory for each shape.",
            "visuals": [
              {
                "type": "nand_universal_detailed",
                "title": "NAND is Universal"
              }
            ]
          },
          {
            "term": "Functional Completeness",
            "definition": "A set of operations is functionally complete if every possible Boolean function can be expressed using only those operations.",
            "why": "Proving {NAND} is complete: build NOT with NAND(A,A), build AND with NAND(NAND(A,B),NAND(A,B)), build OR with NAND(NAND(A,A),NAND(B,B)). Since {AND,OR,NOT} is complete, NAND is complete.",
            "visuals": [
              {
                "type": "nand_to_not",
                "title": "Building NOT from NAND"
              }
            ],
            "latex": "\\overline{A} = NAND(A,A)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "CMOS NAND Implementation",
            "definition": "A NAND gate uses 2 NMOS transistors in series (pull-down) + 2 PMOS transistors in parallel (pull-up). Only 4 transistors total.",
            "why": "NAND requires FEWER transistors than AND (which needs NAND + inverter = 6 transistors). This efficiency is why synthesis tools prefer NAND-based implementations.",
            "analogy": "Building an AND gate is like building a NAND and then immediately un-doing it with an inverter—wasteful.",
            "visuals": [
              {
                "type": "cmos_inverter",
                "title": "CMOS Transistor Structure"
              }
            ]
          },
          {
            "term": "Standard Cell Library",
            "definition": "A pre-designed collection of logic gates (NAND2, NAND3, NOR2, INV, etc.) that chip designers use as building blocks.",
            "why": "Libraries are characterized for timing, power, and area. Synthesis tools automatically map designs to these cells, preferring NAND because it's fastest and smallest in CMOS.",
            "analogy": "Like a catalog of pre-approved parts. Designers pick from the catalog rather than designing each transistor."
          }
        ],
        "formulaCards": [
          {
            "name": "NAND Boolean Expression",
            "variables": [
              {
                "symbol": "A, B",
                "meaning": "Input signals (0 or 1)",
                "units": "binary"
              },
              {
                "symbol": "A, B",
                "meaning": "Complements (inverted inputs)",
                "units": "binary"
              }
            ],
            "meaning": "NAND is 'NOT-AND': it outputs 0 only when both inputs are 1. By De Morgan's law, this equals OR of the inverted inputs.",
            "example": {
              "problem": "Verify NAND(1,1) using the Boolean expression",
              "given": [
                "A = 1",
                "B = 1"
              ],
              "steps": [
                "NAND(A, B) = \\overline{A AND B}",
                "A AND B = 1 AND 1 = 1",
                "\\overline{1} = 0"
              ],
              "answer": "NAND(1,1) = 0 ✓"
            },
            "latex": "NAND(A, B) = \\overline{A \\cdot B} = \\bar{A} + \\bar{B}",
            "html": null
          },
          {
            "name": "NOT from NAND",
            "variables": [
              {
                "symbol": "A",
                "meaning": "Input signal",
                "units": "binary"
              }
            ],
            "meaning": "Tie both NAND inputs together. NAND(A,A) = NOT(A AND A) = NOT(A). This is the simplest universality demonstration.",
            "example": {
              "problem": "Build NOT(1) using NAND",
              "given": [
                "A = 1"
              ],
              "steps": [
                "NAND(1, 1) = \\overline{1 AND 1} = \\overline{1} = 0"
              ],
              "answer": "NOT(1) = 0 ✓"
            },
            "latex": "\\overline{A} = NAND(A, A)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "name": "Transistor Count Comparison",
            "latex": "NAND = 4T, AND = 6T, OR = 6T, NOR = 4T",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">6</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">6</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">NOR</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>",
            "variables": [
              {
                "symbol": "T",
                "meaning": "Transistor count",
                "units": "transistors"
              }
            ],
            "meaning": "NAND and NOR are the smallest 2-input gates in CMOS (4 transistors each). AND and OR require an extra inverter stage (6 total). This is why synthesis prefers NAND/NOR.",
            "derivation": "NAND: 2 NMOS series + 2 PMOS parallel = 4T. AND: NAND + INV = 4T + 2T = 6T."
          }
        ],
        "exercises": [
          {
            "question": "Complete the NAND truth table: A=0, B=0→? A=0, B=1→? A=1, B=0→? A=1, B=1→?",
            "hint": "NAND is NOT(AND). First compute AND, then invert.",
            "answer": "00→1, 01→1, 10→1, 11→0 (only 11 gives 0)"
          },
          {
            "question": "How would you build an AND gate using only NAND gates?",
            "hint": "AND = NOT(NAND). How do you build NOT from NAND?",
            "answer": {
              "steps": [
                "First NAND: N1 = NAND(A, B).",
                "Use NAND as an inverter by tying inputs: AND(A, B) = NAND(N1, N1)."
              ],
              "answer": "AND(A, B) = NAND(NAND(A, B), NAND(A, B))"
            }
          },
          {
            "question": "A chip needs 1 million AND gates. Using direct AND (6T each) vs NAND-based AND (8T with two NANDs), which uses fewer transistors overall? Consider that standalone NAND is 4T.",
            "hint": "Direct AND = 6T. NAND-based AND = 4T + 4T = 8T. But what if you could optimize the NAND-based version?",
            "answer": "Direct: 6M transistors. NAND-based: 8M. BUT synthesis tools optimize across gates, often eliminating redundant inversions when chaining, making NAND chains more efficient in practice."
          }
        ],
        "realWorld": {
          "context": "NAND gates are the foundation of NAND Flash memory, used in SSDs, USB drives, and smartphones.",
          "example": "NAND Flash stores bits using floating-gate transistors connected in a NAND-like series configuration. A 1TB SSD contains about 8 trillion such cells.",
          "numbers": "Modern 3D NAND stacks 128+ layers vertically. Each cell stores 3-4 bits (TLC/QLC) by distinguishing 8-16 voltage levels.",
          "connection": "In this level, you're using a single NAND gate. This same gate type—scaled to trillions—stores all the data in your computer's SSD."
        }
      },
      "variants": {
        "easy": {
          "introText": "The NAND gate is special: it's UNIVERSAL, meaning you can build ANY other logic gate using only NANDs.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand"
          ]
        },
        "medium": {
          "title": "NOR: The Other Universal",
          "objective": "Build NOR gate",
          "description": "NOR (NOT OR) is the dual universal gate to NAND. Output is 1 only when both inputs are 0.",
          "introText": "While NAND is famous, NOR is equally powerful as a universal gate. In fact, the Apollo Guidance Computer (1969) was built ENTIRELY from NOR gates! NOR outputs TRUE only when ALL inputs are FALSE. Like NAND, you can build any other gate from NOR alone—a different but equivalent path to computational universality.",
          "physicsVisual": "nor_universal",
          "hint": "NOR = NOT(A OR B). Output is 1 only when A=0 AND B=0. Build it from an OR gate followed by NOT.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 55
        },
        "hard": {
          "title": "NAND Universality Proof",
          "objective": "Build NOT, AND, OR from NAND only",
          "description": "Prove NAND is universal by building all three basic gates (NOT, AND, OR) using only NAND gates. Three outputs: NOT_A, A_AND_B, A_OR_B.",
          "introText": "FUNCTIONAL COMPLETENESS is a cornerstone theorem of digital logic. A gate is 'universal' if it can implement any Boolean function. You'll now prove NAND's universality by constructing NOT(A), A AND B, and A OR B from NAND alone. This means ANY digital circuit—from calculators to CPUs—could be built from NAND gates only!",
          "physicsVisual": "nand_universality",
          "hint": "Three circuits sharing inputs A,B: (1) NOT_A = NAND(A,A), (2) AND = NAND(NAND(A,B), NAND(A,B)), (3) OR = NAND(NAND(A,A), NAND(B,B)). Total: 5 NANDs.",
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                1,
                0,
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                1,
                0,
                1
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0,
                0,
                1
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0,
                1,
                1
              ]
            }
          ],
          "maxGates": 5,
          "xpReward": 85
        }
      }
    },
    {
      "id": "level_07",
      "tier": "tier_2",
      "title": "Logic from NAND",
      "objective": "Build NOT using NAND",
      "description": "Prove universality by creating a NOT gate.",
      "introText": "LOGIC SYNTHESIS & TECHNOLOGY MAPPING: When you write code in an HDL (Hardware Description Language) like Verilog or VHDL, a 'synthesis tool' converts your abstract logic into a netlist of physical gates. This process, called technology mapping, ensures your design is optimized for a specific manufacturing process.",
      "physicsVisual": "nand_to_not",
      "hint": "Tie both inputs of a NAND gate together.",
      "availableGates": [
        "nand"
      ],
      "inputs": 1,
      "targetTruthTable": [
        {
          "in": [
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1
          ],
          "out": [
            0
          ]
        }
      ],
      "maxGates": 1,
      "xpReward": 40,
      "storyText": "SYNTHESIS OPTIMIZATION: Logic synthesis tools convert RTL (Register-Transfer Level) descriptions into optimized gate-level designs. This involves minimizing Boolean expressions, mapping to the most efficient gates available (like NAND/NOR), and performing timing analysis to ensure the circuit runs at its target frequency.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Logic Synthesis",
            "definition": "The automated process of converting a high-level Hardware Description Language (HDL) like Verilog or VHDL into a gate-level netlist of physical transistors and logic gates.",
            "why": "It allows designers to work at a high level of abstraction, managing complexity that would be impossible to handle by manually drawing billions of transistors.",
            "analogy": "Like a compiler for hardware: it translates high-level code (like C++ or Python) into low-level machine instructions (gate netlists).",
            "latex": null,
            "html": null,
            "visuals": [
              {
                "type": "nand_universal",
                "title": "Logic Synthesis to NAND Gates"
              }
            ]
          },
          {
            "term": "Technology Mapping",
            "definition": "Converting technology-independent logic into specific cells from a foundry's standard cell library.",
            "why": "Each foundry has different transistor characteristics. Mapping optimizes for the target process.",
            "analogy": "Like choosing which LEGO pieces to use—same structure, different available bricks.",
            "latex": null,
            "html": null,
            "visuals": [
              {
                "type": "cmos_inverter",
                "title": "CMOS Technology Implementation"
              }
            ]
          },
          {
            "term": "Universality Proof (NOT from NAND)",
            "definition": "Demonstrating that NAND can create any logic function by first showing it can create NOT: NAND(A,A) = NOT(A).",
            "why": "If we can build NOT, AND, and OR from NAND, we can build ANY Boolean function.",
            "analogy": "Like proving you can cook any meal if you have salt, heat, and water—the fundamentals.",
            "visuals": [
              {
                "type": "nand_to_not",
                "title": "NOT from NAND (Tie Inputs)"
              }
            ],
            "latex": "NAND(A,A) = \\overline{A AND A} = \\overline{A}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">AA</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">A</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span>"
          },
          {
            "term": "Standard Cell Library",
            "definition": "A collection of pre-designed, pre-characterized logic gates (NAND2, NOR3, INV, etc.) provided by the foundry.",
            "why": "Each cell is optimized for the process and comes with timing, power, and area data.",
            "analogy": "Like a catalog of pre-made furniture—you pick pieces that fit your design.",
            "latex": null,
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "NOT from NAND Identity",
            "variables": [
              {
                "symbol": "A",
                "meaning": "Input signal",
                "units": "Logic level (0 or 1)"
              },
              {
                "symbol": "NAND(A,A)",
                "meaning": "NAND gate with both inputs tied together",
                "units": "Logic level"
              }
            ],
            "meaning": "When both inputs of a NAND gate receive the same signal, the output is the inverse of that signal.",
            "derivation": "NAND(A,A) = NOT(A AND A) = NOT(A) since A AND A = A by idempotency.",
            "example": {
              "problem": "What is the output of NAND(1,1)?",
              "given": [
                "A = 1",
                "NAND(A,A) = NOT(A AND A)"
              ],
              "steps": [
                "NAND(1,1) = \\overline{1 AND 1}",
                "1 AND 1 = 1",
                "\\overline{1} = 0"
              ],
              "answer": "Output = 0 (matches NOT gate behavior: NOT(1) = 0)"
            },
            "latex": "\\overline{A} = NAND(A, A)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "name": "Synthesis Area Cost",
            "variables": [
              {
                "symbol": "Area",
                "meaning": "Total chip area used by gates",
                "units": "μm²"
              },
              {
                "symbol": "W",
                "meaning": "Transistor width",
                "units": "μm"
              },
              {
                "symbol": "L",
                "meaning": "Transistor length (channel length)",
                "units": "nm"
              }
            ],
            "meaning": "Chip area is proportional to the sum of all transistor areas. Fewer, smaller transistors = cheaper chip.",
            "derivation": "Each transistor occupies W×L area plus routing overhead. Total area sums all transistors.",
            "example": {
              "problem": "Compare area: NOT from NAND vs dedicated inverter.",
              "given": [
                "NAND gate = 4 transistors",
                "Dedicated INV = 2 transistors",
                "Same W and L"
              ],
              "steps": [
                "NAND-as-inverter area = 4 \\times W \\times L",
                "Dedicated inverter area = 2 \\times W \\times L",
                "Ratio = \\frac{4}{2} = 2\\times"
              ],
              "answer": "NAND-as-inverter uses 2× the area of a dedicated inverter, but in NAND-only libraries this is the only option."
            },
            "latex": "Area ∝ \\Sigma(W \\times L)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∝</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mclose\">)</span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "If NAND(A,A) = NOT(A), what is NAND(0,0)?",
            "hint": "Apply the identity: NAND(0,0) = NOT(0 AND 0) = NOT(0).",
            "answer": "NAND(0,0) = NOT(0) = 1"
          },
          {
            "question": "A synthesis tool reports your design uses 50 NAND2 gates (4 transistors each) and 20 inverters (2 transistors each). Total transistor count?",
            "hint": "Multiply gates by transistors per gate, then add.",
            "answer": {
              "steps": [
                "1. NAND transistors: 50 gates × 4T/gate = 200T.",
                "2. NOT transistors: 20 gates × 2T/gate = 40T.",
                "3. Total: 200T + 40T = 240 transistors."
              ],
              "answer": "240 transistors"
            }
          },
          {
            "question": "Why does the synthesis tool prefer NAND-based implementations over AND-based?",
            "hint": "Think about transistor count: AND = NAND + inverter.",
            "answer": "AND requires NAND + inverter (4+2=6 transistors), while NAND alone is 4 transistors. NAND is inherently more efficient in CMOS."
          }
        ],
        "realWorld": {
          "context": "Modern chip design relies entirely on automated synthesis and technology mapping.",
          "example": "Synopsys Design Compiler, Cadence Genus, and open-source Yosys are synthesis tools used to convert RTL to gates.",
          "numbers": "A modern CPU has 10-50 billion transistors. Synthesis tools process this in hours, optimizing for area, speed, and power.",
          "connection": "This level teaches the first step of universality: building NOT from NAND—the foundation for all other logic."
        }
      },
      "variants": {
        "easy": {
          "introText": "LOGIC SYNTHESIS & TECHNOLOGY MAPPING: When you write code in an HDL, a synthesis tool converts your abstract logic into physical gates.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor"
          ]
        },
        "medium": {
          "title": "AND from NAND",
          "objective": "Build AND using only NAND gates",
          "description": "Reconstruct the AND function using only NAND gates. This is the inverse operation: A NAND B, then invert.",
          "introText": "AND from NAND is straightforward but important: NAND is NOT-AND, so AND is NOT-NAND. This 'double negation' pattern appears everywhere in synthesis. When you write Verilog code, the synthesis tool often maps your logic to NAND-based standard cells, performing exactly these transformations automatically.",
          "physicsVisual": "nand_to_and",
          "hint": "Use two NANDs: first computes A NAND B, second inverts it (NAND(X,X) = NOT X). Result: NOT(NOT(A AND B)) = A AND B.",
          "inputs": 2,
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 55
        },
        "hard": {
          "title": "XOR from NAND Only",
          "objective": "Build XOR using only NAND gates",
          "description": "The classic 4-NAND XOR circuit. This is how XOR was built in early TTL chips and remains an important synthesis pattern.",
          "introText": "The 4-NAND XOR is a famous circuit in digital design history. Before dedicated XOR gates existed in standard cell libraries, this was THE way to implement XOR in NAND-based chips. The construction is elegant: compute A NAND B once, then use it with A and B separately, and NAND those results. Understanding this pattern helps you reason about gate-level optimization.",
          "physicsVisual": "nand_to_xor_4gate",
          "hint": "Step 1: X = A NAND B. Step 2: Y = A NAND X. Step 3: Z = B NAND X. Step 4: Out = Y NAND Z. Total: 4 NANDs for perfect XOR.",
          "inputs": 2,
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ]
            }
          ],
          "maxGates": 4,
          "xpReward": 75
        }
      }
    },
    {
      "id": "level_08",
      "tier": "tier_2",
      "title": "XOR (Exclusive OR)",
      "objective": "Output 1 if inputs differ",
      "description": "Strictly one or the other, not both.",
      "introText": "EXCLUSIVE OR & MODULO-2 ARITHMETIC: XOR performs addition modulo 2: 0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0 (no carry). This makes XOR the heart of binary addition and the foundation of error detection, cryptography, and data recovery.",
      "physicsVisual": "xor_gate_detailed",
      "hint": "A OR B, but NOT (A AND B).",
      "availableGates": [
        "and",
        "or",
        "not"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            0
          ]
        }
      ],
      "maxGates": 4,
      "xpReward": 50,
      "storyText": "XOR IMPLEMENTATION OPTIONS: XOR can be built as (A·NOT(B)) + (NOT(A)·B) using 2 ANDs, 2 NOTs, 1 OR (5 gates, 14 transistors). Alternative: (A+B)·NOT(A·B) uses fewer gates. In CMOS, the optimal XOR uses 8-12 transistors depending on drive strength requirements.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Exclusive OR (XOR)",
            "definition": "A logic gate that outputs 1 if and only if exactly one of its inputs is 1. Outputs 0 when inputs are the same.",
            "why": "XOR detects difference between two bits—essential for comparison, error detection, and arithmetic.",
            "analogy": "Like a disagreement detector: outputs TRUE when two people disagree, FALSE when they agree.",
            "visuals": [
              {
                "type": "xor_gate_detailed",
                "title": "XOR: Difference / Parity"
              }
            ],
            "latex": "A \\oplus B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "term": "Modulo-2 Arithmetic",
            "definition": "Addition where 1+1=0 (wraps around). XOR performs this naturally: 0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0.",
            "why": "Forms the basis of binary addition (ignoring carry) and polynomial arithmetic in error detection.",
            "analogy": "Like clock arithmetic: 11:00 + 2 hours = 1:00 (wraps around). Binary wraps at 2.",
            "latex": "(a + b) mod 2",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">d</span><span class=\"mord\">2</span></span></span></span>",
            "visuals": [
              {
                "type": "half_adder",
                "title": "XOR in Binary Addition"
              }
            ]
          },
          {
            "term": "Self-Inverse Property",
            "definition": "XOR is its own inverse: A ⊕ B ⊕ B = A. XORing twice with the same value returns the original.",
            "why": "This property enables encryption (XOR with key), error correction, and data swapping without temp variable.",
            "analogy": "Like a light switch: flip twice and you're back where you started.",
            "latex": "A \\oplus B \\oplus B = A",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>"
          },
          {
            "term": "Parity Bit",
            "definition": "A single bit added to data to make the total number of 1s even (even parity) or odd (odd parity).",
            "why": "If a single bit flips during transmission, the parity changes, detecting the error.",
            "analogy": "Like a checksum: add up all digits and check if the sum is even or odd.",
            "visuals": [
              {
                "type": "counter_detailed",
                "title": "Parity Bit Sweep"
              }
            ],
            "latex": "Parity = B_{0} \\oplus B_{1} \\oplus B_{2} \\oplus \\ldots \\oplus B_{n}",
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "XOR Boolean Expression (Sum of Products)",
            "variables": [
              {
                "symbol": "A, B",
                "meaning": "Input signals",
                "units": "Logic level (0 or 1)"
              },
              {
                "symbol": "\\bar{A}, \\bar{B}",
                "meaning": "Complement (NOT) of A and B",
                "units": "Logic level"
              },
              {
                "symbol": "\\cdot",
                "meaning": "AND operation",
                "units": ""
              },
              {
                "symbol": "+",
                "meaning": "OR operation",
                "units": ""
              }
            ],
            "meaning": "XOR is true when A is 1 and B is 0, OR when A is 0 and B is 1. Either one, but not both.",
            "derivation": "From the definition: output 1 when inputs differ. Case 1: A=1, B=0 → A·\\bar{B}=1. Case 2: A=0, B=1 → \\bar{A}·B=1.",
            "example": {
              "problem": "Calculate 1 ⊕ 0 using the formula.",
              "given": [
                "A = 1",
                "B = 0",
                "A ⊕ B = (A · \\bar{B}) + (\\bar{A} · B)"
              ],
              "steps": [
                "\\bar{B} = \\overline{0} = 1, \\bar{A} = \\overline{1} = 0",
                "A \\cdot \\bar{B} = 1 \\cdot 1 = 1",
                "\\bar{A} \\cdot B = 0 \\cdot 0 = 0",
                "(A \\cdot \\bar{B}) + (\\bar{A} \\cdot B) = 1 + 0 = 1"
              ],
              "answer": "1 ⊕ 0 = 1"
            },
            "latex": "A \\oplus B = (A \\cdot \\bar{B}) + (\\bar{A} \\cdot B)",
            "html": null
          },
          {
            "name": "XOR Alternate Form (Product of Sums)",
            "variables": [
              {
                "symbol": "A + B",
                "meaning": "A OR B",
                "units": "Logic level"
              },
              {
                "symbol": "\\bar{A} + \\bar{B}",
                "meaning": "NOT-A OR NOT-B = NAND(A, B)",
                "units": "Logic level"
              }
            ],
            "meaning": "XOR is true when (A or B is true) AND (not both are true). Combines OR with NAND.",
            "derivation": "De Morgan: (\\bar{A} + \\bar{B}) = NOT(A · B). So XOR = (A OR B) AND (NOT both true).",
            "example": {
              "problem": "Calculate 1 ⊕ 1 using the alternate form.",
              "given": [
                "A = 1",
                "B = 1"
              ],
              "steps": [
                "A + B = 1 + 1 = 1",
                "\\bar{A} + \\bar{B} = 0 + 0 = 0",
                "(A + B) \\cdot (\\bar{A} + \\bar{B}) = 1 \\cdot 0 = 0"
              ],
              "answer": "1 ⊕ 1 = 0 (same inputs → output 0)"
            },
            "latex": "A \\oplus B = (A + B) \\cdot (\\bar{A} + \\bar{B})",
            "html": null
          },
          {
            "name": "Gate Count Formula",
            "variables": [
              {
                "symbol": "gates",
                "meaning": "Number of each gate type",
                "units": "count"
              },
              {
                "symbol": "transistors_per_{gate}",
                "meaning": "NOT=2, NAND/NOR=4, AND/OR=6",
                "units": "count"
              }
            ],
            "meaning": "Total transistor count determines chip area and cost. Fewer transistors = cheaper, smaller chip.",
            "derivation": "Each gate type has a fixed transistor count in CMOS. Sum across all gates.",
            "example": {
              "problem": "XOR built with 2 ANDs, 2 NOTs, 1 OR. Total transistors?",
              "given": [
                "AND = 6 transistors",
                "NOT = 2 transistors",
                "OR = 6 transistors"
              ],
              "steps": [
                "2 ANDs = 2 \\times 6 = 12 transistors",
                "2 NOTs = 2 \\times 2 = 4 transistors",
                "1 OR = 1 \\times 6 = 6 transistors",
                "Total = 12 + 4 + 6 = 22 transistors"
              ],
              "answer": "22 transistors (note: dedicated XOR cell uses only 8-12)"
            },
            "latex": "Transistors = \\Sigma(gates \\times transistors_{per}_{gate})",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">ors</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord\"><span class=\"mord mathnormal\">s</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">e</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "Complete the XOR truth table: 0⊕0=?, 0⊕1=?, 1⊕0=?, 1⊕1=?",
            "hint": "Output 1 when inputs are different, 0 when same.",
            "answer": "0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0"
          },
          {
            "question": "If a message 1011 has even parity bit P = 1⊕0⊕1⊕1 = 1, and you receive 1001 with P=1, is there an error?",
            "hint": "Recalculate parity of received data and compare.",
            "answer": "Received parity: 1⊕0⊕0⊕1 = 0 ≠ 1. Error detected!"
          },
          {
            "question": "Using XOR's self-inverse property, encrypt 'A' (binary 01000001) with key 11110000, then decrypt.",
            "hint": "Encrypt: data ⊕ key. Decrypt: ciphertext ⊕ key.",
            "answer": "Encrypt: 01000001 ⊕ 11110000 = 10110001. Decrypt: 10110001 ⊕ 11110000 = 01000001 = 'A'"
          }
        ],
        "realWorld": {
          "context": "XOR is the workhorse of data integrity and security systems worldwide.",
          "example": "CRC (Cyclic Redundancy Check) in Ethernet, USB, and SSDs use XOR chains. RAID-5 uses XOR for parity: P = D₁ \\oplus D₂ \\oplus D₃.",
          "numbers": "A 1 TB RAID-5 array with 4 disks stores 3 TB data + XOR parity. If any disk fails, data is recovered via XOR.",
          "connection": "This level teaches XOR—the gate that enables error detection, encryption, and the binary adder you'll build soon."
        }
      },
      "variants": {
        "easy": {
          "introText": "EXCLUSIVE OR & MODULO-2 ARITHMETIC: XOR performs addition modulo 2.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor"
          ]
        },
        "medium": {
          "title": "XNOR: Equality Detector",
          "objective": "Output 1 when inputs are equal",
          "description": "XNOR (Exclusive NOR) outputs 1 when both inputs are the same (both 0 or both 1). It's the equality comparator.",
          "introText": "XNOR is XOR's complement—it's true when inputs are EQUAL. This makes it a 1-bit equality comparator! Chaining multiple XNORs (one per bit) with an AND gate creates a multi-bit equality checker. CPUs use this pattern to compare register values and determine branch conditions.",
          "physicsVisual": "xnor_equality",
          "hint": "XNOR = NOT(XOR) = NOT((A AND NOT B) OR (NOT A AND B)). Alternatively: (A AND B) OR (NOT A AND NOT B).",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 5,
          "xpReward": 60
        },
        "hard": {
          "title": "Parity Generator (3-bit)",
          "objective": "Output 1 if odd number of inputs are 1",
          "description": "Build a 3-input parity generator using XOR gates. This is the basis of all error-detection codes.",
          "introText": "PARITY CHECKING is the simplest error detection method in computing. A parity bit tells you if the number of 1s is odd or even. Memory systems, communication protocols, and storage devices all use parity. XOR naturally computes parity: XOR(A,B,C) = 1 when an odd number of inputs are 1. This is why XOR is called 'modulo-2 addition'.",
          "physicsVisual": "parity_generator",
          "hint": "Chain XOR gates: (A XOR B) XOR C. XOR is associative, so order doesn't matter. The result is the parity of all three bits.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor"
          ],
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 2,
          "xpReward": 75
        }
      }
    },
    {
      "id": "level_09",
      "tier": "tier_2",
      "title": "De Morgan Laws",
      "objective": "Build OR using NANDs",
      "description": "Invert inputs to swap AND/OR logic.",
      "introText": "DE MORGAN'S THEOREMS & BUBBLE PUSHING: Augustus De Morgan (1847) proved two fundamental theorems that relate AND, OR, and NOT. These laws enable 'bubble pushing'—a schematic technique that transforms gates while preserving function.",
      "physicsVisual": "de_morgan_detailed",
      "hint": "Invert A, Invert B, then NAND them.",
      "availableGates": [
        "nand"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            1
          ]
        }
      ],
      "maxGates": 3,
      "xpReward": 60,
      "storyText": "BUBBLE PUSHING IN PRACTICE: When analyzing or optimizing circuits, bubble pushing transforms gates while preserving function. Rules: (1) Push bubbles through gate by changing AND↔OR, (2) Bubbles on all inputs can move to output (or vice versa), (3) Two bubbles cancel.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "De Morgan's First Theorem",
            "definition": "The complement of a product equals the sum of complements: NOT(A AND B) = NOT(A) OR NOT(B).",
            "why": "Transforms AND operations into OR operations with inversions—enables gate substitution.",
            "analogy": "\"It's NOT raining AND sunny\" = \"It's NOT raining OR it's NOT sunny\"—either condition breaks the combo.",
            "visuals": [
              {
                "type": "de_morgan",
                "title": "De Morgan's First Law"
              }
            ],
            "latex": "\\overline{A \\cdot B} = \\overline{A} + \\overline{B}",
            "html": null
          },
          {
            "term": "De Morgan's Second Theorem",
            "definition": "The complement of a sum equals the product of complements: NOT(A OR B) = NOT(A) AND NOT(B).",
            "why": "Transforms OR operations into AND operations with inversions—the dual of the first theorem.",
            "analogy": "\"NOT (coffee OR tea)\" = \"NOT coffee AND NOT tea\"—you want neither.",
            "latex": "\\overline{A + B} = \\overline{A} \\cdot \\overline{B}",
            "html": null
          },
          {
            "term": "Bubble Pushing",
            "definition": "A schematic technique where inversion 'bubbles' can be moved through gates by swapping AND↔OR.",
            "why": "Simplifies circuit analysis and enables conversion between NAND-only and NOR-only implementations.",
            "analogy": "Like algebraic manipulation—moving negatives around an equation while keeping it balanced.",
            "latex": null,
            "html": null,
            "visuals": [
              {
                "type": "nand_universal",
                "title": "Gate Transformations"
              }
            ]
          },
          {
            "term": "NAND-to-OR Conversion",
            "definition": "A NAND gate with inverted inputs behaves as an OR gate: NOT(NOT(A) AND NOT(B)) = A OR B.",
            "why": "Proves NAND universality for OR—combined with NOT from NAND, any function is possible.",
            "analogy": "Disguising a NAND as an OR by flipping the inputs.",
            "visuals": [
              {
                "type": "parallel_circuit",
                "title": "OR via Parallel Paths"
              }
            ],
            "latex": "NAND(\\overline{A}, \\overline{B}) = A + B",
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "De Morgan's First Law",
            "variables": [
              {
                "symbol": "A \\cdot B",
                "meaning": "A AND B",
                "units": "Logic level"
              },
              {
                "symbol": "\\overline{A}",
                "meaning": "NOT A (complement)",
                "units": "Logic level"
              },
              {
                "symbol": "\\overline{B}",
                "meaning": "NOT B (complement)",
                "units": "Logic level"
              }
            ],
            "meaning": "To negate an AND, negate each input and change AND to OR. The NAND is the negated AND.",
            "derivation": "Proof by truth table: NOT(A·B) and (\\overline{A}+\\overline{B}) produce identical outputs for all input combinations.",
            "example": {
              "problem": "Apply De Morgan to simplify NOT(1 · 1).",
              "given": [
                "A = 1",
                "B = 1",
                "NOT(A · B) = \\overline{A} + \\overline{B}"
              ],
              "steps": [
                "Direct: \\overline{1 \\cdot 1} = \\overline{1} = 0",
                "De Morgan: \\overline{A} + \\overline{B} = \\overline{1} + \\overline{1} = 0 + 0 = 0",
                "Both methods give 0 ✓"
              ],
              "answer": "NOT(1 · 1) = 0, verified by De Morgan"
            },
            "latex": "\\overline{A \\cdot B} = \\overline{A} + \\overline{B}",
            "html": null
          },
          {
            "name": "De Morgan's Second Law",
            "variables": [
              {
                "symbol": "A + B",
                "meaning": "A OR B",
                "units": "Logic level"
              },
              {
                "symbol": "\\overline{A} \\cdot \\overline{B}",
                "meaning": "NOT-A AND NOT-B",
                "units": "Logic level"
              }
            ],
            "meaning": "To negate an OR, negate each input and change OR to AND. The NOR is the negated OR.",
            "derivation": "This is the dual of the first law. Can be derived by substituting \\overline{A} for A and \\overline{B} for B in law 1.",
            "example": {
              "problem": "Apply De Morgan to NOT(0 + 0).",
              "given": [
                "A = 0",
                "B = 0"
              ],
              "steps": [
                "Direct: \\overline{0 + 0} = \\overline{0} = 1",
                "De Morgan: \\overline{A} \\cdot \\overline{B} = \\overline{0} \\cdot \\overline{0} = 1 \\cdot 1 = 1",
                "Both methods give 1 ✓"
              ],
              "answer": "NOT(0 + 0) = 1, verified by De Morgan"
            },
            "latex": "\\overline{A + B} = \\overline{A} \\cdot \\overline{B}",
            "html": null
          },
          {
            "name": "OR from NAND (This Level)",
            "latex": "A + B = NAND(NAND(A,A), NAND(B,B))",
            "html": null,
            "variables": [
              {
                "symbol": "NAND(A,A)",
                "meaning": "NOT(A) - inverter from NAND",
                "units": "Logic level"
              },
              {
                "symbol": "NAND(NOT A, NOT B)",
                "meaning": "NOT(NOT A AND NOT B) = A OR B by De Morgan",
                "units": "Logic level"
              }
            ],
            "meaning": "First invert both inputs (using NAND as NOT), then NAND the results to get OR.",
            "derivation": "NAND(NOT A, NOT B) = NOT(NOT A · NOT B) = NOT(NOT(A + B)) = A + B by double negation and De Morgan.",
            "example": {
              "problem": "Compute 0 OR 1 using only NAND gates.",
              "given": [
                "A = 0",
                "B = 1"
              ],
              "steps": [
                "Step 1: NAND(0,0) = NOT(0) = 1",
                "Step 2: NAND(1,1) = NOT(1) = 0",
                "Step 3: NAND(1,0) = NOT(1 AND 0) = NOT(0) = 1"
              ],
              "answer": "0 OR 1 = 1 (using 3 NAND gates)"
            }
          }
        ],
        "exercises": [
          {
            "question": "Apply De Morgan's first law to simplify NOT(X · Y · Z). (Hint: it extends to 3+ inputs)",
            "hint": "NOT(A · B · C) = NOT(A) + NOT(B) + NOT(C)",
            "answer": "NOT(X · Y · Z) = NOT(X) + NOT(Y) + NOT(Z)"
          },
          {
            "question": "Convert the expression (A + B) to use only NAND gates. How many NANDs needed?",
            "hint": "NOT(A) = NAND(A,A). Then NAND the inverted inputs.",
            "answer": "3 NANDs: NAND(A,A), NAND(B,B), then NAND those two outputs."
          },
          {
            "question": "Using bubble pushing, redraw AND(A,B) as an equivalent NOR-based circuit.",
            "hint": "AND = NOT(NOT(A) OR NOT(B)) = NOR(NOT(A), NOT(B)). So: 2 inverters into a NOR.",
            "answer": "AND(A,B) = NOR(NOT(A), NOT(B)) = NOR with inverted inputs (3 gates if NOT is separate, or 1 NOR with bubble inputs)"
          }
        ],
        "realWorld": {
          "context": "De Morgan's laws are fundamental to digital design optimization and verification.",
          "example": "Synthesis tools use De Morgan transformations to convert logic to NAND-only or NOR-only forms, depending on which is faster in the target technology.",
          "numbers": "In a 7nm process, NAND2 delay is ~10ps, NOR2 is ~12ps. De Morgan helps choose the faster form.",
          "connection": "This level proves OR can be built from NAND—combined with NOT (level 07), we can build any Boolean function from NANDs alone."
        }
      },
      "variants": {
        "easy": {
          "introText": "DE MORGAN'S THEOREMS & BUBBLE PUSHING: Augustus De Morgan proved two fundamental theorems that relate AND, OR, and NOT.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor"
          ]
        },
        "medium": {
          "title": "De Morgan: NOR to AND",
          "objective": "Build AND using NOR gates only",
          "description": "Apply De Morgan's theorem in reverse: build an AND gate using only NOR gates.",
          "introText": "De Morgan's second theorem states: NOT(A OR B) = NOT(A) AND NOT(B). Rearranging: A AND B = NOT(NOT(A) OR NOT(B)). Using NOR as NOT (NOR(X,X)=NOT(X)), we can build AND from NOR. The Apollo Guidance Computer used exactly this technique—every AND was built from three NOR gates!",
          "physicsVisual": "nor_to_and",
          "hint": "Invert A (NOR(A,A)), invert B (NOR(B,B)), then NOR those results. The output is A AND B.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "xpReward": 70
        },
        "hard": {
          "title": "3-Variable De Morgan",
          "objective": "Prove NOT(A·B·C) = A'+B'+C'",
          "description": "Extend De Morgan's theorem to three variables. Build a circuit that outputs NOT(A AND B AND C) using only OR and NOT gates.",
          "introText": "De Morgan's theorems extend to any number of variables: NOT(A·B·C·...·N) = A'+B'+C'+...+N'. This 'bubble pushing' technique is critical in circuit optimization. Synthesis tools use it to convert between AND-OR and NAND-NOR implementations, choosing whichever is faster or smaller for the target technology.",
          "physicsVisual": "de_morgan_3var",
          "hint": "NOT(A AND B AND C) = (NOT A) OR (NOT B) OR (NOT C). Use three NOT gates and two OR gates.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor"
          ],
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                0
              ]
            }
          ],
          "maxGates": 5,
          "xpReward": 90
        }
      }
    },
    {
      "id": "level_10",
      "tier": "tier_3",
      "title": "Multiplexer (MUX)",
      "objective": "Select input based on selector",
      "description": "If Sel=0, Out=A. If Sel=1, Out=B.",
      "introText": "MULTIPLEXERS & DATA ROUTING: A 2:1 MUX selects between 2 data inputs using 1 select line. MUXes are data routers—they choose which input to pass through without modifying the data. In CPUs, MUXes select which register feeds the ALU.",
      "physicsVisual": "multiplexer_detailed",
      "hint": "(A AND NOT S) OR (B AND S)",
      "availableGates": [
        "and",
        "or",
        "not"
      ],
      "inputs": 3,
      "targetTruthTable": [
        {
          "in": [
            0,
            0,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1,
            0
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1,
            0,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            1,
            0
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            0,
            0,
            1
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            0,
            1,
            1
          ],
          "out": [
            1
          ]
        },
        {
          "in": [
            1,
            0,
            1
          ],
          "out": [
            0
          ]
        },
        {
          "in": [
            1,
            1,
            1
          ],
          "out": [
            1
          ]
        }
      ],
      "maxGates": 4,
      "xpReward": 70,
      "storyText": "MUX-BASED COMPUTATION: FPGAs use 4-input or 6-input LOOKUP TABLES (LUTs)—essentially MUXes—as their basic logic element. Any 4-variable Boolean function is stored in 16 SRAM cells connected to a 16:1 MUX.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Multiplexer (MUX)",
            "definition": "A combinational circuit that selects one of N data inputs and routes it to the output, based on select lines.",
            "why": "MUXes are the building blocks of data routing—used in CPUs, memory systems, and FPGAs.",
            "analogy": "Like a railroad switch: one track in, select which of two tracks to continue on.",
            "visuals": [
              {
                "type": "multiplexer_detailed",
                "title": "MUX: Select One Data Path"
              }
            ],
            "latex": "Out = (A \\cdot \\bar{S}) + (B\\cdot S)",
            "html": null
          },
          {
            "term": "Select Lines",
            "definition": "Control inputs that determine which data input is passed to the output. n select lines can choose among 2ⁿ inputs.",
            "why": "Binary encoding of selection is efficient—2 bits can select from 4 inputs, 3 bits from 8, etc.",
            "analogy": "Like a TV remote: channel number (select) determines which signal (data) you see.",
            "visuals": [
              {
                "type": "decoder",
                "title": "Binary Selection Decoding"
              }
            ],
            "latex": "Inputs = 2^{select lines}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8491em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">se</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">ec</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">tl</span><span class=\"mord mathnormal mtight\">in</span><span class=\"mord mathnormal mtight\">es</span></span></span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "term": "Lookup Table (LUT)",
            "definition": "A memory-based implementation where any Boolean function's truth table is stored and indexed by inputs.",
            "why": "LUTs enable programmable logic—FPGAs use them to implement any function by just changing the stored values.",
            "analogy": "Like a cheat sheet: instead of calculating, you look up pre-computed answers.",
            "latex": "LUT size = 2ⁿ bits for n inputs",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">LU</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">ze</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">nin</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span></span></span></span>",
            "visuals": [
              {
                "type": "series_circuit",
                "title": "LUT Cell Array"
              }
            ]
          },
          {
            "term": "Data Path vs Control Path",
            "definition": "Data path moves and processes data (MUXes, ALU). Control path decides which operations to perform.",
            "why": "Separating data and control simplifies design—MUXes are the connection between the two.",
            "analogy": "Data path is the highway; control path is the traffic lights deciding which cars go where.",
            "latex": null,
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "2:1 MUX Boolean Equation",
            "variables": [
              {
                "symbol": "A",
                "meaning": "Data input 0 (selected when S=0)",
                "units": "Logic level"
              },
              {
                "symbol": "B",
                "meaning": "Data input 1 (selected when S=1)",
                "units": "Logic level"
              },
              {
                "symbol": "S",
                "meaning": "Select input",
                "units": "Logic level"
              },
              {
                "symbol": "\\bar{S}",
                "meaning": "NOT S (complement of select)",
                "units": "Logic level"
              }
            ],
            "meaning": "When S=0, the A·S̄ term passes A through. When S=1, the B·S term passes B through. Only one term is active at a time.",
            "derivation": "When S=0: Out = (A·1) + (B·0) = A. When S=1: Out = (A·0) + (B·1) = B.",
            "example": {
              "problem": "What is the output when A=1, B=0, S=0?",
              "given": [
                "A = 1",
                "B = 0",
                "S = 0"
              ],
              "steps": [
                "\\bar{S} = \\overline{0} = 1",
                "A \\cdot \\bar{S} = 1 \\cdot 1 = 1",
                "B \\cdot S = 0 \\cdot 0 = 0",
                "Out = 1 + 0 = 1"
              ],
              "answer": "Out = 1 (input A is passed through when S=0)"
            },
            "latex": "Out = (A \\cdot \\bar{S}) + (B \\cdot S)",
            "html": null
          },
          {
            "name": "MUX Scaling Formula",
            "variables": [
              {
                "symbol": "n",
                "meaning": "Number of select lines",
                "units": "count"
              },
              {
                "symbol": "2^{n}",
                "meaning": "Number of data inputs the MUX can select from",
                "units": "count"
              }
            ],
            "meaning": "Each additional select line doubles the number of inputs. 1 select → 2 inputs, 2 selects → 4 inputs, etc.",
            "derivation": "Binary encoding: n bits can represent 2ⁿ unique values, each selecting a different input.",
            "example": {
              "problem": "How many select lines for a 16:1 MUX?",
              "given": [
                "Data inputs = 16",
                "Data inputs = 2^n"
              ],
              "steps": [
                "16 = 2^{n}",
                "log_{2}(16) = n",
                "n = 4"
              ],
              "answer": "4 select lines for a 16:1 MUX"
            },
            "latex": "Data Inputs = 2^{n}, where n = select lines",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">se</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">tl</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">es</span></span></span></span>"
          },
          {
            "name": "Gate Count for 2:1 MUX",
            "latex": "Gates = 2 AND + 1 OR + 1 NOT = 4 gates",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">NOT</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span></span></span></span>",
            "variables": [
              {
                "symbol": "AND",
                "meaning": "AND gates (one for each data input)",
                "units": "count"
              },
              {
                "symbol": "OR",
                "meaning": "OR gate to combine the AND outputs",
                "units": "count"
              },
              {
                "symbol": "NOT",
                "meaning": "Inverter for the select signal",
                "units": "count"
              }
            ],
            "meaning": "A 2:1 MUX requires 4 gates minimum. Larger MUXes can be built hierarchically.",
            "derivation": "From the equation: (A AND NOT S) OR (B AND S) needs 1 AND for each term, 1 OR to combine, and 1 NOT for S̄.",
            "example": {
              "problem": "Transistor count for a 2:1 MUX using basic gates?",
              "given": [
                "AND = 6 transistors",
                "OR = 6 transistors",
                "NOT = 2 transistors"
              ],
              "steps": [
                "2 ANDs = 2 \\times 6 = 12",
                "1 OR = 6",
                "1 NOT = 2",
                "Total = 12 + 6 + 2 = 20"
              ],
              "answer": "20 transistors (transmission gate MUX uses only 4)"
            }
          }
        ],
        "exercises": [
          {
            "question": "Complete the 2:1 MUX output for: A=0, B=1, S=1",
            "hint": "When S=1, output follows B.",
            "answer": "Out = (0·0) + (1·1) = 0 + 1 = 1 (B is selected)"
          },
          {
            "question": "An 8:1 MUX has how many select lines and data inputs?",
            "hint": "8 = 2^n, solve for n.",
            "answer": "3 select lines, 8 data inputs (since 2³ = 8)"
          },
          {
            "question": "To implement a 3-input Boolean function using a MUX, what size MUX is needed?",
            "hint": "For n-input function, you need a 2^n:1 MUX with function outputs connected to data inputs.",
            "answer": "An 8:1 MUX (2³ = 8). Connect the 8 truth table outputs to data inputs, and the 3 function inputs to select lines."
          }
        ],
        "realWorld": {
          "context": "MUXes are everywhere in digital systems—from simple data selection to implementing entire processors.",
          "example": "FPGAs use 6-input LUTs (64:1 MUXes) as basic logic elements. A Xilinx Virtex UltraScale+ has 4 million LUTs.",
          "numbers": "In a CPU, the register file read port is a 32:1 MUX (5 select bits choose 1 of 32 registers). ARM Cortex-A76 has 160+ MUXes just in the issue stage.",
          "connection": "This level introduces data routing—the MUX pattern appears in every level of computer architecture."
        }
      },
      "variants": {
        "easy": {
          "introText": "MULTIPLEXERS & DATA ROUTING: A 2:1 MUX selects between 2 data inputs using 1 select line.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ]
        },
        "medium": {
          "title": "MUX as Universal Gate",
          "objective": "Implement AND using a 2:1 MUX",
          "description": "Prove that a MUX can implement any Boolean function. Start by building an AND gate using only a 2:1 multiplexer.",
          "introText": "SHANNON'S EXPANSION THEOREM proves that a MUX is universal: any function F(A,B,...) can be built by using one variable as the selector and the remaining functions as data inputs. For AND: if Sel=A, when A=0 output should be 0, when A=1 output should be B. Thus: MUX(0, B, A) = A AND B. FPGAs exploit this—their LUTs (Look-Up Tables) are just big multiplexers!",
          "physicsVisual": "mux_as_and",
          "hint": "Connect: Data0 = 0, Data1 = B, Sel = A. When A=0, output is Data0=0. When A=1, output is Data1=B. This is A AND B!",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ],
          "inputs": 2,
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ]
            }
          ],
          "maxGates": 1,
          "xpReward": 85
        },
        "hard": {
          "title": "4:1 MUX from 2:1 MUXes",
          "objective": "Build a 4-input multiplexer",
          "description": "Construct a 4:1 MUX using three 2:1 MUXes. Select one of four data inputs using two select lines.",
          "introText": "Larger multiplexers are built hierarchically from smaller ones. A 4:1 MUX needs 2 select bits (S1,S0) to choose among 4 inputs (D0,D1,D2,D3). The classic construction uses two 2:1 MUXes controlled by S0 (selecting between D0/D1 and D2/D3), then a final 2:1 MUX controlled by S1 to pick the winner. This tree structure is how CPUs build their register file read ports.",
          "physicsVisual": "mux_4to1_tree",
          "hint": "Layer 1: MUX1 selects D0 or D1 (using S0), MUX2 selects D2 or D3 (using S0). Layer 2: MUX3 selects between MUX1 and MUX2 outputs (using S1).",
          "availableGates": [
            "mux2to1"
          ],
          "inputs": 6,
          "targetTruthTable": [
            {
              "in": [
                1,
                0,
                0,
                0,
                0,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                0,
                0,
                0,
                0,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                1,
                0,
                0,
                0,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                0,
                0,
                0,
                0,
                1
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                0,
                1,
                0,
                1,
                0
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                0,
                0,
                0,
                1,
                0
              ],
              "out": [
                0
              ]
            },
            {
              "in": [
                0,
                0,
                0,
                1,
                1,
                1
              ],
              "out": [
                1
              ]
            },
            {
              "in": [
                0,
                0,
                0,
                0,
                1,
                1
              ],
              "out": [
                0
              ]
            }
          ],
          "maxGates": 3,
          "xpReward": 100
        }
      }
    },
    {
      "id": "level_11",
      "tier": "tier_3",
      "title": "Decoder (2-to-4)",
      "objective": "Activate 1 of 4 outputs",
      "description": "Convert binary number to a specific line.",
      "introText": "ADDRESS DECODING & MEMORY ARCHITECTURE: A decoder converts an n-bit binary number into one of 2ⁿ output lines. Only ONE output is active at a time—this is one-hot encoding. In memory systems, decoders select which cell to read or write.",
      "physicsVisual": "decoder_detailed",
      "hint": "00->Out0, 01->Out1, 10->Out2, 11->Out3",
      "availableGates": [
        "and",
        "not"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            1,
            0,
            0,
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            0,
            1,
            0,
            0
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            0,
            0,
            1,
            0
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            0,
            0,
            0,
            1
          ]
        }
      ],
      "maxGates": 6,
      "xpReward": 80,
      "storyText": "MEMORY HIERARCHY & DECODERS: Your computer has a memory hierarchy: CPU Registers (32-64, addressed by 5-6 bits), L1 Cache (32KB, 15 bits), RAM (16GB, 34 bits). Each level uses decoders to select the right storage location.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "MSB and LSB",
            "definition": "MSB (Most Significant Bit) = the leftmost bit, representing the largest value (2^(n-1)). LSB (Least Significant Bit) = the rightmost bit, representing the smallest value (2^0 = 1).",
            "why": "Bit position matters! In 1010, MSB=1 (value 8), LSB=0 (value 0). Knowing MSB/LSB helps understand binary numbers and circuit bit ordering.",
            "analogy": "Like decimal: in 1234, the '1' is most significant (thousands place), '4' is least significant (ones place).",
            "latex": "Value = MSB \\times 2^{n-1} + \\ldots + LSB \\times 2^{0}",
            "html": null
          },
          {
            "term": "Decoder",
            "definition": "A combinational circuit that converts an n-bit binary input into one of 2ⁿ output lines, activating exactly one output.",
            "why": "Decoders translate binary addresses into physical selection signals—essential for memory and device access.",
            "analogy": "Like a hotel elevator: you press floor 7 (binary input), and only the 7th floor light turns on (one-hot output).",
            "latex": "n inputs → 2ⁿ outputs",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">nin</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8588em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span></span></span></span>",
            "visuals": [
              {
                "type": "decoder_detailed",
                "title": "Decoder: One-Hot Line Select"
              }
            ]
          },
          {
            "term": "One-Hot Encoding",
            "definition": "A representation where exactly one bit is '1' and all others are '0'. Each output line corresponds to one input combination.",
            "why": "One-hot signals are easy to use as enable lines—no further decoding needed.",
            "analogy": "Like a piano where only one key can be pressed at a time.",
            "latex": "For value i: bit i = 1, all others = 0",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">ers</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>",
            "visuals": [
              {
                "type": "parallel_circuit",
                "title": "One-Hot Parallel Lines"
              }
            ]
          },
          {
            "term": "Minterm",
            "definition": "A product (AND) of all input variables where each variable appears once, either complemented or uncomplemented.",
            "why": "Each decoder output is a minterm of the inputs—this is the mathematical foundation of decoders.",
            "analogy": "Like a combination lock: every dial must be in exactly the right position.",
            "visuals": [
              {
                "type": "nand_universal",
                "title": "Minterm Products"
              }
            ],
            "latex": "m_{0} = \\bar{A}\\cdot\\bar{B}, m_{1} = \\bar{A}\\cdot B, m_{2} = A\\cdot\\bar{B}, m_{3} = A\\cdot B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8201em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0145em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0701em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0145em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>"
          },
          {
            "term": "Address Decoding",
            "definition": "The process of using binary address bits to select a specific memory location or peripheral device.",
            "why": "CPUs generate addresses; decoders convert them to physical selection signals.",
            "analogy": "Like a postal system: zip code (address) determines which post office (decoder output) handles your mail.",
            "latex": null,
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "2-to-4 Decoder Outputs",
            "variables": [
              {
                "symbol": "A, B",
                "meaning": "Input bits (A is MSB, B is LSB)",
                "units": "Logic level"
              },
              {
                "symbol": "NOT A, NOT B",
                "meaning": "Complements of A and B",
                "units": "Logic level"
              },
              {
                "symbol": "Y_{0}-Y_{3}",
                "meaning": "Output lines (exactly one is HIGH)",
                "units": "Logic level"
              }
            ],
            "meaning": "Each output is the AND of the input combination that selects it. Y₀ is selected by 00, Y₁ by 01, etc.",
            "derivation": "For Y₂ (input=10): A must be 1 (use A), B must be 0 (use \\bar{B}). So Y₂ = A·\\bar{B}.",
            "example": {
              "problem": "Which output is active for input AB = 11?",
              "given": [
                "A = 1",
                "B = 1"
              ],
              "steps": [
                "Y_{0} = \\bar{A}\\cdot\\bar{B} = 0\\cdot0 = 0",
                "Y_{1} = \\bar{A}\\cdot B = 0\\cdot1 = 0",
                "Y_{2} = A\\cdot\\bar{B} = 1\\cdot0 = 0",
                "Y_{3} = A\\cdot B = 1\\cdot1 = 1"
              ],
              "answer": "Y₃ is active (output = 0001 in [Y₀,Y₁,Y₂,Y₃] notation)"
            },
            "latex": "Y_{0} = \\bar{A}\\cdot\\bar{B}, Y_{1} = \\bar{A}\\cdot B, Y_{2} = A\\cdot\\bar{B}, Y_{3} = A\\cdot B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8201em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0145em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0701em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">A</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1111em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0145em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span>"
          },
          {
            "name": "Decoder Scaling",
            "latex": "Outputs = 2ⁿ, Gates = n NOT + 2ⁿ AND",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">NOT</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>",
            "variables": [
              {
                "symbol": "n",
                "meaning": "Number of input bits",
                "units": "count"
              },
              {
                "symbol": "2ⁿ",
                "meaning": "Number of output lines",
                "units": "count"
              },
              {
                "symbol": "NOT",
                "meaning": "Inverters for each input",
                "units": "gates"
              },
              {
                "symbol": "AND",
                "meaning": "One AND gate per output",
                "units": "gates"
              }
            ],
            "meaning": "A decoder with n inputs needs n inverters (for complements) and 2ⁿ AND gates (one per output).",
            "derivation": "Each output is a unique minterm requiring all n variables in a specific form.",
            "example": {
              "problem": "How many gates for a 3-to-8 decoder?",
              "given": [
                "n = 3 inputs"
              ],
              "steps": [
                "NOT gates = 3 (one per input)",
                "AND gates = 2³ = 8 (one per output)",
                "Total = 3 + 8 = 11 gates"
              ],
              "answer": "11 gates (3 NOT + 8 AND)"
            }
          },
          {
            "name": "Memory Address Decoding",
            "variables": [
              {
                "symbol": "A_{high}",
                "meaning": "High-order address bits (row selection)",
                "units": "bits"
              },
              {
                "symbol": "A_{low}",
                "meaning": "Low-order address bits (column selection)",
                "units": "bits"
              },
              {
                "symbol": "Row Decoder",
                "meaning": "Selects one of 2^k rows",
                "units": ""
              },
              {
                "symbol": "Column Decoder",
                "meaning": "Selects one of 2^m columns",
                "units": ""
              }
            ],
            "meaning": "2D decoding splits the address into row and column parts, reducing decoder size from 2^(k+m) to 2^k + 2^m.",
            "derivation": "Instead of one huge decoder, use two smaller ones and their outputs intersect at one cell.",
            "example": {
              "problem": "A 64KBSRAM uses 16-bit addresses. With 2D decoding (8 row bits, 8 column bits), how many decoder outputs total?",
              "given": [
                "16-bit address",
                "8 row bits",
                "8 column bits"
              ],
              "steps": [
                "Row decoder: 2⁸ = 256 outputs",
                "Column decoder: 2⁸ = 256 outputs",
                "Total = 256 + 256 = 512 decoder outputs",
                "Compare to 1D: 2¹⁶ = 65536 outputs!"
              ],
              "answer": "512 decoder outputs (vs 65536 for 1D decoding)"
            },
            "latex": "Cell Selected = Row Decoder(A_{high}) AND Column Decoder(A_{low})",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">llS</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">Deco</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">hi</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">mn</span><span class=\"mord mathnormal\">Deco</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02691em;\">w</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "For a 2-to-4 decoder, write the Boolean expression for output Y₁.",
            "hint": "Y₁ is active when input = 01 (A=0, B=1).",
            "answer": "Y₁ = \\bar{A} · B (NOT-A AND B)"
          },
          {
            "question": "How many outputs does a 4-to-16 decoder have? How many AND gates?",
            "hint": "Outputs = 2^n. Each output needs one AND gate.",
            "answer": "16 outputs, 16 AND gates (each is a 4-input AND)"
          },
          {
            "question": "A 1MBSRAM has 20-bit addresses. With 10 row bits and 10 column bits, how many total decoder outputs?",
            "hint": "Row decoder = 2^10, Column decoder = 2^10.",
            "answer": "2^10 + 2^10 = 1024 + 1024 = 2048 total decoder outputs"
          }
        ],
        "realWorld": {
          "context": "Decoders are fundamental to memory systems—every byte you access requires address decoding.",
          "example": "DDR5 memory uses hierarchical decoders: chip select → bank group → bank → row → column.",
          "numbers": "A 64GBDDR5 module has 512 billion memory cells. Row decoders activate one of 65536 wordlines; column decoders select from 8192 columns per bank.",
          "connection": "This level teaches address decoding—the circuit that turns binary addresses into physical selections in every memory system."
        }
      },
      "variants": {
        "easy": {
          "introText": "ADDRESS DECODING & MEMORY ARCHITECTURE: A decoder converts an n-bit binary number into one of 2ⁿ output lines.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ]
        },
        "medium": {
          "title": "Decoder with Enable",
          "objective": "Add an Enable control to decoder",
          "description": "Build a 2-to-4 decoder that only activates outputs when Enable=1. When Enable=0, all outputs are 0.",
          "introText": "In memory systems, CHIP SELECT (Enable) lines allow multiple chips to share the same address/data bus. Only the enabled chip responds to addresses; others remain high-impedance. Your decoder should output the normal pattern when EN=1, but all zeros when EN=0. This is essential for memory banking and I/O port addressing.",
          "physicsVisual": "decoder_enable",
          "hint": "Take your 2-to-4 decoder and AND each output with the Enable signal. This 'gates' the entire decoder.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ],
          "inputs": 3,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0,
                0,
                0,
                0
              ],
              "desc": "A=00, EN=0: disabled"
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                0,
                0,
                0,
                0
              ],
              "desc": "A=01, EN=0: disabled"
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                0,
                0,
                0,
                0
              ],
              "desc": "A=10, EN=0: disabled"
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0,
                0,
                0,
                0
              ],
              "desc": "A=11, EN=0: disabled"
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                1,
                0,
                0,
                0
              ],
              "desc": "A=00, EN=1: Out0"
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0,
                1,
                0,
                0
              ],
              "desc": "A=01, EN=1: Out1"
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0,
                0,
                1,
                0
              ],
              "desc": "A=10, EN=1: Out2"
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                0,
                0,
                0,
                1
              ],
              "desc": "A=11, EN=1: Out3"
            }
          ],
          "maxGates": 10,
          "xpReward": 95
        },
        "hard": {
          "title": "Priority Encoder",
          "objective": "Find highest-priority active input",
          "description": "Build a 4-to-2 priority encoder: output the binary index of the highest-numbered active input. If input 3 is high, output 11. Input 2 high (and 3 low) outputs 10, etc.",
          "introText": "A PRIORITY ENCODER is the inverse of a decoder with a twist: when multiple inputs are active, it reports only the highest-priority one. This is critical in interrupt controllers—when multiple devices request attention, the CPU must service the highest-priority interrupt first. RISC-V and ARM interrupt controllers use this exact logic.",
          "physicsVisual": "priority_encoder",
          "hint": "For 4 inputs (I3,I2,I1,I0), output bits are: Out1 = I3 OR I2, Out0 = I3 OR (I1 AND NOT I2). The highest active input wins.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ],
          "inputs": 4,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0,
                0
              ],
              "out": [
                0,
                0
              ],
              "desc": "No input: default 00"
            },
            {
              "in": [
                0,
                0,
                0,
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "I0 only: output 00"
            },
            {
              "in": [
                0,
                0,
                1,
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "I1 only: output 01"
            },
            {
              "in": [
                0,
                0,
                1,
                1
              ],
              "out": [
                0,
                1
              ],
              "desc": "I1,I0: I1 wins, output 01"
            },
            {
              "in": [
                0,
                1,
                0,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "I2 only: output 10"
            },
            {
              "in": [
                0,
                1,
                0,
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "I2,I0: I2 wins, output 10"
            },
            {
              "in": [
                0,
                1,
                1,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "I2,I1: I2 wins, output 10"
            },
            {
              "in": [
                0,
                1,
                1,
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "I2,I1,I0: I2 wins, output 10"
            },
            {
              "in": [
                1,
                0,
                0,
                0
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3 only: output 11"
            },
            {
              "in": [
                1,
                0,
                0,
                1
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3,I0: I3 wins, output 11"
            },
            {
              "in": [
                1,
                0,
                1,
                0
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3,I1: I3 wins, output 11"
            },
            {
              "in": [
                1,
                0,
                1,
                1
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3,I1,I0: I3 wins, output 11"
            },
            {
              "in": [
                1,
                1,
                0,
                0
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3,I2: I3 wins, output 11"
            },
            {
              "in": [
                1,
                1,
                0,
                1
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3,I2,I0: I3 wins, output 11"
            },
            {
              "in": [
                1,
                1,
                1,
                0
              ],
              "out": [
                1,
                1
              ],
              "desc": "I3,I2,I1: I3 wins, output 11"
            },
            {
              "in": [
                1,
                1,
                1,
                1
              ],
              "out": [
                1,
                1
              ],
              "desc": "All inputs: I3 wins, output 11"
            }
          ],
          "xpReward": 115
        }
      }
    },
    {
      "id": "level_12",
      "tier": "tier_3",
      "title": "Half Adder",
      "objective": "Add 2 bits",
      "description": "Calculate Sum and Carry for two inputs.",
      "introText": "BINARY ARITHMETIC FUNDAMENTALS: In base-2, addition follows: 0+0=0, 0+1=1, 1+0=1, 1+1=10 (0 with carry 1). The Half Adder computes Sum and Carry for two single bits—the foundation of all computer arithmetic.",
      "physicsVisual": "half_adder_detailed",
      "hint": "Sum is XOR, Carry is AND.",
      "availableGates": [
        "xor",
        "and"
      ],
      "inputs": 2,
      "targetTruthTable": [
        {
          "in": [
            0,
            0
          ],
          "out": [
            0,
            0
          ]
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            1,
            0
          ]
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            1,
            0
          ]
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            0,
            1
          ]
        }
      ],
      "maxGates": 2,
      "xpReward": 90,
      "storyText": "HALF ADDER LIMITATIONS: The half adder only works for the LSB where there's no incoming carry. For bit position 1 and beyond, we need full adders. The critical path is through the XOR (typically 2 gate delays).",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Binary Addition",
            "definition": "Addition in base-2 where each digit is 0 or 1. When sum exceeds 1, a carry is generated to the next bit position.",
            "why": "All computer arithmetic ultimately reduces to binary addition. Understanding it is fundamental.",
            "analogy": "Like decimal addition (0-9), but simpler: only 0 and 1. When you run out of digits, carry to the next column.",
            "visuals": [
              {
                "type": "electron_flow",
                "title": "Signal Addition"
              }
            ],
            "latex": "1 + 1 = 10_{2} \\text{ (binary)} = 2_{10} \\text{ (decimal)}",
            "html": null
          },
          {
            "term": "Half Adder",
            "definition": "A circuit that adds two single-bit inputs (A, B) and produces a Sum and a Carry output.",
            "why": "The half adder is the building block—it handles the simplest case of binary addition.",
            "analogy": "Like adding two single-digit numbers in decimal, getting a result and possibly a carry.",
            "visuals": [
              {
                "type": "half_adder_detailed",
                "title": "Half Adder: Sum & Carry"
              }
            ],
            "latex": "Sum = A \\oplus B, Carry = A \\cdot B",
            "html": null
          },
          {
            "term": "Sum Output",
            "definition": "The result of adding A and B in the current bit position (ignoring carry). Sum is 1 when inputs differ.",
            "why": "The sum represents the 'ones place' of the addition result for this bit position.",
            "analogy": "Like the rightmost digit when you add: 7+5=12, the sum digit is 2.",
            "visuals": [
              {
                "type": "xor_gate",
                "title": "XOR for Sum"
              }
            ],
            "latex": "Sum = A \\oplus B \\text{ (XOR)}",
            "html": null
          },
          {
            "term": "Carry Output",
            "definition": "A signal indicating the addition overflowed the current bit. Carry is 1 only when both inputs are 1.",
            "why": "The carry must propagate to the next higher bit position to get the correct total.",
            "analogy": "Like 'carrying the 1' in decimal: 7+5=12, carry the 1 to the tens place.",
            "latex": "Carry = A \\cdot B \\text{ (AND)}",
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "Half Adder Sum",
            "variables": [
              {
                "symbol": "A",
                "meaning": "First input bit",
                "units": "Logic level (0 or 1)"
              },
              {
                "symbol": "B",
                "meaning": "Second input bit",
                "units": "Logic level (0 or 1)"
              },
              {
                "symbol": "Sum",
                "meaning": "Result bit (before carry)",
                "units": "Logic level"
              },
              {
                "symbol": "\\oplus",
                "meaning": "XOR operation",
                "units": ""
              }
            ],
            "meaning": "Sum is 1 when exactly one input is 1. This matches modulo-2 addition: 1+1=0 (carry handled separately).",
            "derivation": "From binary addition: 0+0=0, 0+1=1, 1+0=1, 1+1=0 (with carry). This is exactly XOR's truth table.",
            "example": {
              "problem": "Calculate Sum for A=1, B=1.",
              "given": [
                "A = 1",
                "B = 1"
              ],
              "steps": [
                "Sum = A \\oplus B",
                "Sum = 1 \\oplus 1",
                "Sum = 0 (XOR: same inputs → 0)"
              ],
              "answer": "Sum = 0 (the '0' in binary '10')"
            },
            "latex": "Sum = A \\oplus B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "name": "Half Adder Carry",
            "variables": [
              {
                "symbol": "A",
                "meaning": "First input bit",
                "units": "Logic level"
              },
              {
                "symbol": "B",
                "meaning": "Second input bit",
                "units": "Logic level"
              },
              {
                "symbol": "Carry",
                "meaning": "Overflow bit to next position",
                "units": "Logic level"
              },
              {
                "symbol": "\\cdot",
                "meaning": "AND operation",
                "units": ""
              }
            ],
            "meaning": "Carry is 1 only when both inputs are 1 (the only case where 1+1=2 overflows a single bit).",
            "derivation": "Only 1+1 generates a carry. All other cases (0+0, 0+1, 1+0) fit in one bit.",
            "example": {
              "problem": "Calculate Carry for A=1, B=1.",
              "given": [
                "A = 1",
                "B= 1"
              ],
              "steps": [
                "Carry = A \\cdot B",
                "Carry = 1 \\cdot 1",
                "Carry = 1"
              ],
              "answer": "Carry = 1 (the '1' in binary '10')"
            },
            "latex": "Carry = A \\cdot B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">rry</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "name": "Binary Addition Result",
            "variables": [
              {
                "symbol": "A, B",
                "meaning": "Input bits",
                "units": "0 or 1"
              },
              {
                "symbol": "Carry",
                "meaning": "High bit of result",
                "units": "0 or 1"
              },
              {
                "symbol": "Sum",
                "meaning": "Low bit of result",
                "units": "0 or 1"
              }
            ],
            "meaning": "The complete result combines carry (worth 2) and sum (worth 1). Result ranges from 0 to 2.",
            "derivation": "In a 2-bit result: Carry is bit 1 (value 2), Sum is bit 0 (value 1). Total = 2×Carry + Sum.",
            "example": {
              "problem": "Verify 1+1=2 using Sum and Carry.",
              "given": [
                "A = 1",
                "B = 1",
                "Sum = 0",
                "Carry = 1"
              ],
              "steps": [
                "Result = (Carry \\times 2) + Sum",
                "Result = (1 \\times 2) + 0",
                "Result = 2"
              ],
              "answer": "1 + 1 = 2 ✓ (binary: 10)"
            },
            "latex": "A + B = (Carry \\times 2) + Sum",
            "html": null
          }
        ],
        "exercises": [
          {
            "question": "Complete the half adder outputs for A=0, B=1.",
            "hint": "Sum = A \\oplus B, Carry = A \\cdot B.",
            "answer": "Sum = 0 ⊕ 1 = 1, Carry = 0 · 1 = 0. Result: Sum=1, Carry=0"
          },
          {
            "question": "How many gates does a half adder need? What types?",
            "hint": "Look at the formulas: Sum uses XOR, Carry uses AND.",
            "answer": "2 gates: 1 XOR gate (for Sum) + 1 AND gate (for Carry)"
          },
          {
            "question": "Using half adders, can you add 3 bits (A, B, C)? Why or why not?",
            "hint": "A half adder has no carry input. What happens to the carry from the first addition?",
            "answer": "No—a half adder can't accept a carry input. To add A+B+C, you need a FULL adder that accepts carry-in. (Next level!)"
          }
        ],
        "realWorld": {
          "context": "The half adder is the first step toward building arithmetic circuits—the foundation of calculators and CPUs.",
          "example": "A simple 4-function calculator uses adders for +, subtraction via two's complement (also addition), and multiplication (repeated addition).",
          "numbers": "A half adder uses ~12 transistors (XOR≈8 + AND≈4). An 8-bit adder needs 8 full adder stages, totaling ~200 transistors.",
          "connection": "This level introduces binary addition with the simplest circuit. Next, you'll build a full adder that chains to create multi-bit adders."
        }
      },
      "variants": {
        "easy": {
          "introText": "BINARY ARITHMETIC FUNDAMENTALS: In base-2, addition follows: 0+0=0, 0+1=1, 1+0=1, 1+1=10.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ]
        },
        "medium": {
          "title": "Half Subtractor",
          "objective": "Subtract 2 bits (Difference and Borrow)",
          "description": "Build a circuit that computes A - B, outputting the Difference and Borrow bits.",
          "introText": "The HALF SUBTRACTOR is the subtraction counterpart to the Half Adder. It computes A minus B: Difference = A XOR B (same as addition!), but Borrow = (NOT A) AND B (borrow occurs when B is 1 but A is 0). Understanding subtraction is key to building ALUs that handle both addition and subtraction.",
          "physicsVisual": "half_subtractor",
          "hint": "Difference = A XOR B (identical to Sum). Borrow = (NOT A) AND B. You need one XOR, one NOT, and one AND gate.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0,
                0
              ]
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                1,
                1
              ]
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                1,
                0
              ]
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0,
                0
              ]
            }
          ],
          "maxGates": 3,
          "xpReward": 100
        },
        "hard": {
          "title": "Apollo NOR Half Adder",
          "objective": "Build Half Adder using NOR gates only",
          "description": "The Apollo Guidance Computer used ONLY NOR gates. Build a Half Adder (Sum and Carry) using exclusively NOR gates.",
          "introText": "The APOLLO GUIDANCE COMPUTER (AGC) that landed humans on the Moon contained about 5,600 NOR gates and NOTHING else. Engineers at MIT built every function—adders, registers, memory—from this single gate type. Now you'll recreate their work: build a Half Adder from NOR gates alone. This is living digital history!",
          "physicsVisual": "apollo_nor_adder",
          "hint": "Sum (XOR) from NOR needs 4-5 gates. Carry (AND) from NOR needs 3 gates. NOT X = X NOR X. Build NOT, then OR (by De Morgan), then work toward XOR and AND.",
          "availableGates": [
            "nor"
          ],
          "maxGates": 7,
          "xpReward": 125
        }
      }
    },
    {
      "id": "level_13",
      "tier": "tier_3",
      "title": "Full Adder",
      "objective": "Add 3 bits (A, B, Cin)",
      "description": "The building block of multi-bit addition.",
      "introText": "FULL ADDER & CARRY PROPAGATION: A Full Adder accepts three inputs (A, B, Carry_in) and produces Sum and Carry_out. This enables chaining adders to build multi-bit arithmetic units—the foundation of every CPU's ALU.",
      "physicsVisual": "full_adder_detailed",
      "hint": "Use two Half Adders logic.",
      "availableGates": [
        "xor",
        "and",
        "or"
      ],
      "inputs": 3,
      "targetTruthTable": [
        {
          "in": [
            0,
            0,
            0
          ],
          "out": [
            0,
            0
          ]
        },
        {
          "in": [
            0,
            0,
            1
          ],
          "out": [
            1,
            0
          ]
        },
        {
          "in": [
            0,
            1,
            0
          ],
          "out": [
            1,
            0
          ]
        },
        {
          "in": [
            0,
            1,
            1
          ],
          "out": [
            0,
            1
          ]
        },
        {
          "in": [
            1,
            0,
            0
          ],
          "out": [
            1,
            0
          ]
        },
        {
          "in": [
            1,
            0,
            1
          ],
          "out": [
            0,
            1
          ]
        },
        {
          "in": [
            1,
            1,
            0
          ],
          "out": [
            0,
            1
          ]
        },
        {
          "in": [
            1,
            1,
            1
          ],
          "out": [
            1,
            1
          ]
        }
      ],
      "maxGates": 5,
      "xpReward": 100,
      "storyText": "ADDER ARCHITECTURES: (1) RIPPLE-CARRY: Simple, O(n) delay. (2) CARRY-LOOKAHEAD (CLA): Parallel carries, O(log n) delay. (3) CARRY-SELECT: Speculate both carry values, MUX the result. Modern CPUs use hybrid architectures balancing speed and area.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Full Adder",
            "definition": "A circuit that adds three single-bit inputs (A, B, Carry-in) and produces Sum and Carry-out.",
            "why": "Full adders can be chained to create n-bit adders—the carry-out of one stage becomes carry-in of the next.",
            "analogy": "Like adding a column in multi-digit addition: you add the two digits PLUS any carry from the previous column.",
            "visuals": [
              {
                "type": "full_adder_detailed",
                "title": "Full Adder: Carry Propagate"
              }
            ],
            "latex": "Sum = A \\oplus B \\oplus Cin, Cout = (A\\cdot B) + (Cin\\cdot (A\\oplus B))",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">in</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">in</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">))</span></span></span></span>"
          },
          {
            "term": "Carry-In (Cin)",
            "definition": "The carry bit from the previous (lower) bit position. This is what distinguishes a full adder from a half adder.",
            "why": "In multi-bit addition, each bit position must account for overflow from the previous position.",
            "analogy": "The '1' you wrote above the next column when doing longhand addition.",
            "latex": "Cin comes from previous stage's Cout",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9463em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">co</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">es</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">ss</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span></span></span></span>",
            "visuals": [
              {
                "type": "half_adder",
                "title": "Carry Chain"
              }
            ]
          },
          {
            "term": "Generate (G)",
            "definition": "A condition where a carry is produced regardless of the incoming carry. Occurs when both A and B are 1.",
            "why": "Generate signals enable carry-lookahead: we can compute carries without waiting for ripple.",
            "analogy": "Like two tall people standing together—they'll reach the ceiling regardless of what's below them.",
            "visuals": [
              {
                "type": "parallel_circuit",
                "title": "Generate: Both Inputs High"
              }
            ],
            "latex": "G = A \\cdot B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "term": "Propagate (P)",
            "definition": "A condition where an incoming carry passes through to the output. Occurs when exactly one of A or B is 1.",
            "why": "Propagate signals determine whether a carry chain continues or stops at each stage.",
            "analogy": "Like a relay runner—if you receive the baton (carry), you pass it on.",
            "visuals": [
              {
                "type": "series_circuit",
                "title": "Propagate: Carry Flow"
              }
            ],
            "latex": "P = A \\oplus B",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>"
          },
          {
            "term": "Big O Notation",
            "definition": "A mathematical notation describing how performance scales with input size n. O(n) = linear (doubles with n), O(log n) = logarithmic (grows slowly), O(1) = constant.",
            "why": "Used to compare adder architectures: ripple-carry is O(n) delay (slow for large n), carry-lookahead is O(log n) (much faster).",
            "analogy": "O(n): reading every page of a book. O(log n): using the index to find a topic. O(1): knowing exactly which page.",
            "latex": "64-bit: O(n)=64 stages, O(log n)=6 stages",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">64</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">64</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">es</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">6</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">es</span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "Full Adder Sum",
            "variables": [
              {
                "symbol": "A",
                "meaning": "First input bit",
                "units": "Logic level"
              },
              {
                "symbol": "B",
                "meaning": "Second input bit",
                "units": "Logic level"
              },
              {
                "symbol": "Cin",
                "meaning": "Carry-in from previous stage",
                "units": "Logic level"
              },
              {
                "symbol": "Sum",
                "meaning": "Result bit for this position",
                "units": "Logic level"
              }
            ],
            "meaning": "Sum is 1 when an odd number of inputs are 1. This is 3-input XOR (modulo-2 sum).",
            "derivation": "Counting 1s: 0,2 ones → Sum=0; 1,3 ones → Sum=1. This matches XOR behavior.",
            "example": {
              "problem": "Calculate Sum for A=1, B=1, Cin=1.",
              "given": [
                "A = 1",
                "B = 1",
                "Cin = 1"
              ],
              "steps": [
                "Sum = A \\oplus B \\oplus Cin",
                "Sum = 1 \\oplus 1 \\oplus 1",
                "Sum = 0 \\oplus 1 (first XOR)",
                "Sum = 1"
              ],
              "answer": "Sum = 1 (three 1s sum to 11₂, the 1's place is 1)"
            },
            "latex": "Sum = A \\oplus B \\oplus Cin",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">in</span></span></span></span>"
          },
          {
            "name": "Full Adder Carry-Out",
            "variables": [
              {
                "symbol": "A \\cdot B",
                "meaning": "Generate term: carry created when both inputs are 1",
                "units": "Logic level"
              },
              {
                "symbol": "A \\oplus B",
                "meaning": "Propagate term: indicates carry can pass through",
                "units": "Logic level"
              },
              {
                "symbol": "Cin \\cdot (A \\oplus B)",
                "meaning": "Carry propagated from input",
                "units": "Logic level"
              }
            ],
            "meaning": "Carry-out occurs if a carry is generated (A·B=1) OR if a carry is propagated (Cin=1 and A⊕B=1).",
            "derivation": "Cout=1 when 2 or 3 inputs are 1: either both A,B are 1 (generate), or Cin=1 and exactly one of A,B is 1 (propagate).",
            "example": {
              "problem": "Calculate Cout for A=0, B=1, Cin=1.",
              "given": [
                "A = 0",
                "B = 1",
                "Cin = 1"
              ],
              "steps": [
                "A \\cdot B = 0 \\cdot 1 = 0 (no generate)",
                "A \\oplus B = 0 \\oplus 1 = 1 (propagate active)",
                "Cin \\cdot (A \\oplus B) = 1 \\cdot 1 = 1 (carry propagates)",
                "Cout = 0 + 1 = 1"
              ],
              "answer": "Cout = 1 (carry propagates through)"
            },
            "latex": "Cout = (A \\cdot B) + (Cin \\cdot (A \\oplus B))",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">in</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">))</span></span></span></span>"
          },
          {
            "name": "Ripple-Carry Adder Delay",
            "variables": [
              {
                "symbol": "n",
                "meaning": "Number of bits",
                "units": "count"
              },
              {
                "symbol": "t_{carry}",
                "meaning": "Delay for carry to propagate through one full adder",
                "units": "nanoseconds"
              }
            ],
            "meaning": "In a ripple-carry adder, the worst case has the carry propagating through all n stages sequentially.",
            "derivation": "Each stage must wait for the previous carry. Worst case: Cin propagates from bit 0 to bit n-1.",
            "example": {
              "problem": "What's the delay of a 64-bit ripple-carry adder if each carry takes 50ps?",
              "given": [
                "n = 64 bits",
                "t_carry = 50ps = 50 × 10⁻¹² s"
              ],
              "steps": [
                "1. Apply formula Delay = n \\times t_{carry}",
                "2. Substitute: Delay = 64 \\times 50ps",
                "3. Calculate: 64 \\times 50 = 3200ps",
                "4. Convert to ns: 3200ps = 3.2ns (@ 1ns = 1000ps)"
              ],
              "answer": "3.2ns (too slow for modern 4GHz CPUs with 250ps cycle time!)"
            },
            "latex": "Delay = n \\times t_{carry}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">De</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">a</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">rry</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "Complete the full adder outputs for A=1, B=0, Cin=1.",
            "hint": "Sum = A ⊕ B ⊕ Cin. Cout = (A·B) + (Cin·(A⊕B)).",
            "answer": "Sum = 1⊕0⊕1 = 0. Cout = (1·0) + (1·(1⊕0)) = 0 + 1·1 = 1. Result: Sum=0, Cout=1"
          },
          {
            "question": "How many gates does a full adder need minimum? (Hint: 2 XOR, 2 AND, 1 OR)",
            "hint": "Sum uses 2 XORs. Cout uses 2 ANDs and 1 OR.",
            "answer": "5 gates: 2 XOR (for Sum) + 2 AND + 1 OR (for Cout)"
          },
          {
            "question": "For an 8-bit ripple-carry adder, how many full adders are needed? What's the worst-case carry chain length?",
            "hint": "One full adder per bit. Carry can ripple through all stages.",
            "answer": "8 full adders. Worst case: carry ripples through all 8 stages (e.g., adding 11111111 + 00000001)."
          }
        ],
        "realWorld": {
          "context": "Full adders are the building blocks of all arithmetic in computers—from simple calculators to supercomputers.",
          "example": "A 64-bit Intel Core ALU uses Kogge-Stone or Brent-Kung adders (parallel prefix) instead of ripple-carry for speed.",
          "numbers": "Kogge-Stone achieves O(log₂64)=6 logic levels instead of 64 ripple stages. But it uses thousands of gates vs ~320 for ripple-carry.",
          "connection": "This level completes the adder foundation. Chaining full adders creates the arithmetic unit that makes computers compute."
        }
      },
      "variants": {
        "easy": {
          "introText": "FULL ADDER & CARRY PROPAGATION: A Full Adder accepts three inputs (A, B, Carry_in) and produces Sum and Carry_out.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ]
        },
        "medium": {
          "title": "Full Subtractor",
          "objective": "Subtract with Borrow-in",
          "description": "Build a Full Subtractor: compute A - B - Bin, outputting Difference and Borrow-out.",
          "introText": "The FULL SUBTRACTOR handles borrowing from previous stages, just as the Full Adder handles carries. Difference = A XOR B XOR Bin. Borrow-out = ((NOT A) AND B) OR ((NOT A) AND Bin) OR (B AND Bin). This cascades to build multi-bit subtractors for signed arithmetic.",
          "physicsVisual": "full_subtractor",
          "hint": "Diff = A XOR B XOR Bin. Bout = ((NOT A) AND (B OR Bin)) OR (B AND Bin). Two XOR gates for Diff, then logic gates for Bout.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0,
                0
              ]
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                1,
                1
              ]
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1,
                1
              ]
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0,
                1
              ]
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                1,
                0
              ]
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0,
                0
              ]
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0,
                0
              ]
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1,
                1
              ]
            }
          ],
          "maxGates": 7,
          "xpReward": 115
        },
        "hard": {
          "title": "2-Bit Ripple Carry Adder",
          "objective": "Add two 2-bit numbers",
          "description": "Build a 2-bit adder by chaining a Half Adder and a Full Adder. Inputs: A1A0 + B1B0 → S1S0 + Cout.",
          "introText": "A RIPPLE CARRY ADDER chains single-bit adders: the carry-out of each stage becomes the carry-in of the next. While simple, this creates a 'critical path' where carry must ripple through every stage—the bottleneck that led to innovations like Carry-Lookahead and Carry-Select adders. Understanding ripple carry is essential before optimizing.",
          "physicsVisual": "ripple_carry_2bit",
          "hint": "Stage 0: Half Adder for A0+B0 → S0, C0. Stage 1: Full Adder for A1+B1+C0 → S1, Cout. Total output is 3 bits: Cout, S1, S0.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1"
          ],
          "inputs": 4,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0,
                0
              ],
              "out": [
                0,
                0,
                0
              ],
              "desc": "00+00=000"
            },
            {
              "in": [
                0,
                0,
                0,
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "00+01=001"
            },
            {
              "in": [
                0,
                0,
                1,
                0
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "00+10=010"
            },
            {
              "in": [
                0,
                0,
                1,
                1
              ],
              "out": [
                0,
                1,
                1
              ],
              "desc": "00+11=011"
            },
            {
              "in": [
                0,
                1,
                0,
                0
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "01+00=001"
            },
            {
              "in": [
                0,
                1,
                0,
                1
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "01+01=010"
            },
            {
              "in": [
                0,
                1,
                1,
                0
              ],
              "out": [
                0,
                1,
                1
              ],
              "desc": "01+10=011"
            },
            {
              "in": [
                0,
                1,
                1,
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "01+11=100"
            },
            {
              "in": [
                1,
                0,
                0,
                0
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "10+00=010"
            },
            {
              "in": [
                1,
                0,
                0,
                1
              ],
              "out": [
                0,
                1,
                1
              ],
              "desc": "10+01=011"
            },
            {
              "in": [
                1,
                0,
                1,
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "10+10=100"
            },
            {
              "in": [
                1,
                0,
                1,
                1
              ],
              "out": [
                1,
                0,
                1
              ],
              "desc": "10+11=101"
            },
            {
              "in": [
                1,
                1,
                0,
                0
              ],
              "out": [
                0,
                1,
                1
              ],
              "desc": "11+00=011"
            },
            {
              "in": [
                1,
                1,
                0,
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "11+01=100"
            },
            {
              "in": [
                1,
                1,
                1,
                0
              ],
              "out": [
                1,
                0,
                1
              ],
              "desc": "11+10=101"
            },
            {
              "in": [
                1,
                1,
                1,
                1
              ],
              "out": [
                1,
                1,
                0
              ],
              "desc": "11+11=110"
            }
          ],
          "maxGates": 8,
          "xpReward": 135
        }
      }
    },
    {
      "id": "level_14",
      "tier": "tier_4",
      "title": "SR Latch",
      "objective": "Store a bit",
      "description": "Create a feedback loop to remember state.",
      "introText": "BISTABLE CIRCUITS & MEMORY ELEMENTS: The SR (Set-Reset) Latch is the simplest memory element. It uses positive feedback: the output feeds back to reinforce itself. This creates two stable states—the foundation of all digital memory.",
      "physicsVisual": "sr_latch_detailed",
      "hint": "Cross-couple two NOR or NAND gates (simulated here).",
      "availableGates": [
        "srLatch"
      ],
      "inputs": 2,
      "targetSequence": [
        {
          "in": [
            1,
            0
          ],
          "out": [
            1,
            0
          ],
          "desc": "SET: S=1, R=0"
        },
        {
          "in": [
            0,
            0
          ],
          "out": [
            1,
            0
          ],
          "desc": "HOLD: S=0, R=0"
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            0,
            1
          ],
          "desc": "RESET: S=0, R=1"
        },
        {
          "in": [
            0,
            0
          ],
          "out": [
            0,
            1
          ],
          "desc": "HOLD: S=0, R=0"
        }
      ],
      "xpReward": 100,
      "storyText": "SRAM (Static Random-Access Memory) uses 6 transistors per bit: 2 cross-coupled inverters (4T) for storage + 2 access transistors for reading/writing. DRAM (Dynamic RAM) uses only 1 transistor and 1 capacitor, making it much denser but requiring constant refreshing.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "SR Latch (Set-Reset)",
            "definition": "A bistable circuit with two inputs: Set (S) and Reset (R). Activating S makes the output 1; activating R makes it 0. When both are inactive, the circuit 'remembers' its previous state.",
            "why": "This is the 'Hello World' of digital memory. It's the first time a circuit's output depends not just on its current inputs, but on its history.",
            "analogy": "Like a simple toggle switch for a lamp that has separate buttons for 'ON' and 'OFF'. If you don't press either, the lamp stays in its current state.",
            "visuals": [
              {
                "type": "sr_latch_detailed",
                "title": "SR Latch: Feedback = Memory"
              }
            ],
            "latex": "Q = NOR(R, \\bar{Q}), \\bar{Q} = NOR(S, Q)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0701em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">NOR</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">NOR</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "Bistable Multivibrator",
            "definition": "A circuit with two stable states that can remain in either state indefinitely. The SR latch is the simplest example.",
            "why": "Bistability is the foundation of digital memory—without it, circuits would forget instantly.",
            "analogy": "Like a ball in a valley between two hills—it will rest in one valley or the other, not in between.",
            "latex": "",
            "html": null,
            "visuals": [
              {
                "type": "sr_latch",
                "title": "Bistable States"
              }
            ]
          },
          {
            "term": "Positive Feedback",
            "definition": "When output feeds back to reinforce itself. In the SR latch, if Q=1, the feedback keeps Q at 1.",
            "why": "Positive feedback creates the bistability—once in a state, the latch 'wants' to stay there.",
            "analogy": "Like microphone feedback: the speaker output feeds into the microphone, amplifying itself.",
            "visuals": [
              {
                "type": "electron_flow",
                "title": "Feedback Loop"
              }
            ],
            "latex": "Q reinforces Q (through \\bar{Q} gate)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0701em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">orces</span><span class=\"mord mathnormal\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ug</span><span class=\"mord mathnormal\">h</span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "Forbidden State (S=R=1)",
            "definition": "When both Set and Reset are active, the outputs are undefined and may oscillate when released.",
            "why": "This is a race condition—when S and R both go to 0, the latch may settle unpredictably or oscillate.",
            "analogy": "Like telling someone 'go forward' and 'go backward' simultaneously—contradictory commands.",
            "latex": "S=R=1: Q=\\bar{Q}=0 (invalid), then race when released",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0145em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">ce</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">se</span><span class=\"mord mathnormal\">d</span></span></span></span>"
          },
          {
            "term": "Race Condition",
            "definition": "A timing hazard where the circuit's outcome depends on which signal arrives first. In the SR latch, releasing S=R=1 simultaneously creates unpredictable behavior.",
            "why": "Race conditions cause non-deterministic bugs. Proper design avoids them through timing constraints or circuit structure.",
            "analogy": "Like two people trying to go through a door at exactly the same time—who goes first is unpredictable."
          }
        ],
        "formulaCards": [
          {
            "name": "NOR-based SR Latch",
            "variables": [
              {
                "symbol": "S",
                "meaning": "Set input (active HIGH)",
                "units": "Logic level"
              },
              {
                "symbol": "R",
                "meaning": "Reset input (active HIGH)",
                "units": "Logic level"
              },
              {
                "symbol": "Q",
                "meaning": "Output (stored state)",
                "units": "Logic level"
              },
              {
                "symbol": "\\bar{Q}",
                "meaning": "Complement output",
                "units": "Logic level"
              }
            ],
            "meaning": "Each output is a NOR of the opposite input and the other output. Cross-coupling creates feedback.",
            "derivation": "When S=1: Q̄=NOR(1,Q)=0, then Q=NOR(0,0)=1. The 1 propagates and latches.",
            "example": {
              "problem": "Trace the SET operation: S=1, R=0, initial Q=0.",
              "given": [
                "S = 1",
                "R = 0",
                "Initial Q = 0",
                "Initial Q̄ = 1"
              ],
              "steps": [
                "\\bar{Q} = NOR(S, Q) = NOR(1, 0) = 0",
                "Q = NOR(R, \\bar{Q}) = NOR(0, 0) = 1",
                "New stable state: Q=1, \\bar{Q}=0"
              ],
              "answer": "Q transitions from 0 to 1 (SET operation complete)"
            },
            "latex": "Q = NOR(R, \\bar{Q}), \\bar{Q} = NOR(S, Q)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0701em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">NOR</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">NOR</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "name": "Hold Condition",
            "variables": [
              {
                "symbol": "S",
                "meaning": "Set input",
                "units": "Logic level"
              },
              {
                "symbol": "R",
                "meaning": "Reset input",
                "units": "Logic level"
              },
              {
                "symbol": "Q_{next}",
                "meaning": "Output after operation",
                "units": "Logic level"
              },
              {
                "symbol": "Q_{current}",
                "meaning": "Output before operation",
                "units": "Logic level"
              }
            ],
            "meaning": "When neither S nor R is active, the latch holds its current state indefinitely. This is MEMORY.",
            "derivation": "If S=R=0 and Q=1,Q̄=0: Q=NOR(0,0)=1, Q̄=NOR(0,1)=0. Stable!",
            "example": {
              "problem": "Show that Q=1 is stable when S=R=0.",
              "given": [
                "S = 0",
                "R = 0",
                "Current Q = 1",
                "Current Q̄ = 0"
              ],
              "steps": [
                "Q = NOR(R, \\bar{Q}) = NOR(0, 0) = 1 (unchanged)",
                "\\bar{Q} = NOR(S, Q) = NOR(0, 1) = 0 (unchanged)",
                "Both outputs stable → HOLD confirmed"
              ],
              "answer": "State Q=1, Q̄=0 is self-maintaining when S=R=0"
            },
            "latex": "S=0, R=0 → Q_{next} = Q_{current}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">rre</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "name": "SRAM Cell (6T)",
            "latex": "Cell = 4T (latch) + 2T (access)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">ccess</span><span class=\"mclose\">)</span></span></span></span>",
            "variables": [
              {
                "symbol": "4T",
                "meaning": "4 transistors forming cross-coupled inverters (the latch)",
                "units": "transistors"
              },
              {
                "symbol": "2T",
                "meaning": "2 access transistors connecting latch to bitlines",
                "units": "transistors"
              },
              {
                "symbol": "6T",
                "meaning": "Total transistors per bit",
                "units": "transistors"
              }
            ],
            "meaning": "SRAM uses a latch for storage (4T) plus access transistors (2T) for read/write control.",
            "derivation": "Each inverter = 2T. Two cross-coupled inverters = 4T. Two NMOS access transistors = 2T. Total = 6T.",
            "example": {
              "problem": "How many transistors for 1KB of SRAM?",
              "given": [
                "1KB = 1024 bytes = 8192 bits",
                "6T per bit"
              ],
              "steps": [
                "Transistors = bits \\times \\frac{6T}{bit}",
                "Transistors = 8192 \\times 6",
                "Transistors = 49,152"
              ],
              "answer": "~49,000 transistors for 1KB of SRAM"
            }
          }
        ],
        "exercises": [
          {
            "question": "Trace the RESET operation: S=0, R=1, initial Q=1.",
            "hint": "Apply NOR equations step by step.",
            "answer": {
              "steps": [
                "Start from the initial condition: Q = 1, so Q̄ = 0.",
                "Compute Q = NOR(R, Q̄) = NOR(1, 0) = 0.",
                "Compute Q̄ = NOR(S, Q) = NOR(0, 0) = 1."
              ],
              "answer": "Q=0, Q̄=1 (RESET complete)"
            }
          },
          {
            "question": "Why is S=R=1 called the 'forbidden' state?",
            "hint": "Calculate what happens to Q and Q̄ when S=R=1.",
            "answer": "When S=R=1: Q=NOR(1,Q̄)=0 and Q̄=NOR(1,Q)=0. Both outputs are 0, violating Q=NOT(Q̄). When S,R both go to 0, race condition occurs."
          },
          {
            "question": "Compare SRAM (6T) vs DRAM (1T1C) density. For 64Mb, how many transistors each?",
            "hint": "64Mb = 64 million bits. DRAM uses 1 transistor + 1 capacitor per bit.",
            "answer": {
              "steps": [
                "SRAM: 64M bits × 6 transistors/bit = 384M transistors.",
                "DRAM: 64M bits × 1 transistor/bit = 64M transistors (plus 64M capacitors).",
                "Compare: 384M / 64M = 6×, so DRAM is ~6× denser by transistor count."
              ],
              "answer": "SRAM: 384M transistors; DRAM: 64M transistors (+ 64M capacitors)"
            }
          }
        ],
        "realWorld": {
          "context": "The SR latch is the foundation of all digital memory—from CPU registers to cache to flip-flops.",
          "example": "CPU registers use latch-based flip-flops (derived from SR latches) to hold instruction operands and results.",
          "numbers": "A Ryzen 9 CPU has ~4MB of L2 cache (SRAM). At 6T/bit, that's 4M × 8 × 6 = 192 million transistors just for L2 cache.",
          "connection": "This level introduces memory—the ability to store and recall information. Every computer relies on this fundamental capability."
        }
      },
      "variants": {
        "easy": {
          "introText": "BISTABLE CIRCUITS & MEMORY ELEMENTS: The SR (Set-Reset) Latch is the simplest memory element.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch"
          ],
          "maxGates": 1
        },
        "medium": {
          "title": "Gated SR Latch",
          "objective": "Control when latch responds",
          "description": "Add an Enable signal to the SR Latch. The latch should only respond to S/R inputs when Enable=1; when Enable=0, it holds its state.",
          "introText": "The GATED SR LATCH adds time control to memory. Without gating, the latch responds instantly to any input change—this causes race conditions and glitches. By adding Enable (later called 'Clock'), we decide exactly WHEN the latch should listen. This is the first step toward synchronous design, where all memory elements update together on clock edges.",
          "physicsVisual": "gated_sr_latch",
          "hint": "Gate S and R with AND gates: S_gated = S AND Enable, R_gated = R AND Enable. Feed these into the SR Latch. When Enable=0, both gated signals are 0 (HOLD mode).",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch"
          ],
          "inputs": 3,
          "targetSequence": [
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "EN=1, S=1, R=0: SET"
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "EN=0, S=0, R=1: HOLD (ignore R)"
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0,
                1
              ],
              "desc": "EN=1, S=0, R=1: RESET"
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "EN=0, S=1, R=0: HOLD (ignore S)"
            }
          ],
          "maxGates": 3,
          "xpReward": 115
        },
        "hard": {
          "title": "D Latch from Gates",
          "objective": "Build a D Latch from scratch",
          "description": "Construct a D Latch using basic gates and an SR Latch. The D Latch eliminates the forbidden S=R=1 state by deriving S and R from a single Data input.",
          "introText": "The D LATCH is the workhorse of digital memory. It captures Data when Enable is high and holds it when Enable is low. The key insight: S = D AND Enable, R = (NOT D) AND Enable. This ensures S and R are never both 1 simultaneously. The D Latch is the basis of register files and forms half of the D Flip-Flop.",
          "physicsVisual": "d_latch_construction",
          "hint": "Generate S = D AND Enable, R = (NOT D) AND Enable. Feed S and R to the SR Latch. When Enable=0, both S and R are 0 (HOLD). When Enable=1, D=1 sets, D=0 resets.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch"
          ],
          "targetSequence": [
            {
              "in": [
                1,
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "D=1, EN=1: Capture HIGH"
            },
            {
              "in": [
                0,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "D=0, EN=0: HOLD (stay HIGH)"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0,
                1
              ],
              "desc": "D=0, EN=1: Capture LOW"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "D=1, EN=0: HOLD (stay LOW)"
            }
          ],
          "maxGates": 4,
          "xpReward": 135
        }
      }
    },
    {
      "id": "level_15",
      "tier": "tier_4",
      "title": "D Flip-Flop",
      "objective": "Sync with Clock",
      "description": "Store Data (D) only on the Clock edge.",
      "introText": "EDGE-TRIGGERED FLIP-FLOPS & SYNCHRONOUS DESIGN: The D Flip-Flop samples input D only on the clock edge. This makes digital design predictable: all changes happen at defined moments, synchronized across the entire chip.",
      "physicsVisual": "dff_timing",
      "hint": "The output only changes when Clock goes 0->1.",
      "availableGates": [
        "dFlipFlop"
      ],
      "inputs": 2,
      "targetSequence": [
        {
          "in": [
            1,
            0
          ],
          "out": [
            0,
            1
          ],
          "desc": "Init: D=1, CLK=0"
        },
        {
          "in": [
            1,
            1
          ],
          "out": [
            1,
            0
          ],
          "desc": "Clock Rise: Sample D=1"
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            1,
            0
          ],
          "desc": "D change: Hold Q=1"
        },
        {
          "in": [
            0,
            0
          ],
          "out": [
            1,
            0
          ],
          "desc": "Clock Fall: Hold Q=1"
        },
        {
          "in": [
            0,
            1
          ],
          "out": [
            0,
            1
          ],
          "desc": "Clock Rise: Sample D=0"
        }
      ],
      "xpReward": 120,
      "storyText": "CLOCK DISTRIBUTION: A modern CPU clock must reach billions of flip-flops within picoseconds of each other. PLLs (Phase-Locked Loops) are used to multiply low-frequency reference oscillators up to the multi-GHz clock speeds used by modern processors.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "D Flip-Flop (Data)",
            "definition": "A memory element that captures its input 'D' only on the active edge of the clock (usually the rising edge). The output 'Q' then holds this value until the next clock edge occurs.",
            "why": "Edge-triggering enables synchronous design—all state changes across a billion-transistor chip happen at the exact same moment, ensuring data is stable before it's used.",
            "analogy": "Like a camera: the input 'D' is the scene, and the clock edge is the shutter click. The resulting photo (Q) captures that one moment regardless of how the scene changes afterward.",
            "latex": "Q(next) = D (at clock edge)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">oc</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "dff_timing",
                "title": "DFF Timing: Sample on Rising Edge"
              }
            ]
          },
          {
            "term": "Edge Triggering",
            "definition": "The flip-flop responds only during the transition of the clock signal (0→1 for positive edge), not while clock is high or low.",
            "why": "Edge triggering prevents multiple captures during a clock period—output changes exactly once per cycle.",
            "analogy": "Like a turnstile: it lets you through only during the moment you push, not while you're holding it.",
            "latex": "Trigger on CLK: 0→1 (rising edge)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">gg</span><span class=\"mord mathnormal\">ero</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "electric_field",
                "title": "Field Flip on Rising Edge"
              }
            ]
          },
          {
            "term": "Setup Time (t_su)",
            "definition": "The minimum time D must be stable BEFORE the clock edge for reliable capture.",
            "why": "The internal logic needs time to propagate D to the capture point before the clock arrives.",
            "analogy": "Like arriving at the train station before the train departs—too late and you miss it.",
            "visuals": [
              {
                "type": "sr_latch",
                "title": "Internal Capture Timing"
              }
            ],
            "latex": "D stable for t_{su} before clock edge",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Ds</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">ab</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">u</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">orec</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">oc</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span></span></span></span>"
          },
          {
            "term": "Hold Time (t_h)",
            "definition": "The minimum time D must remain stable AFTER the clock edge.",
            "why": "The capture logic needs D to remain stable while it's being latched internally.",
            "analogy": "Like holding still after a camera flash—move too soon and the photo blurs.",
            "latex": "D stable for t_{h} after clock edge",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Ds</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">ab</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">erc</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">oc</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span></span></span></span>"
          },
          {
            "term": "Metastability",
            "definition": "An unstable state where a flip-flop's output is neither clearly 0 nor 1, oscillating or taking extra time to resolve. Occurs when setup/hold times are violated.",
            "why": "Metastability can cause system failures. Synchronizer chains (2-3 flip-flops) give extra time for resolution.",
            "analogy": "Like a ball balanced on a hill's peak—it will eventually fall to one side, but takes time.",
            "latex": "Resolution time determines reliability",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">esolution</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">time</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">determines</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">reliability</span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "Maximum Clock Frequency",
            "variables": [
              {
                "symbol": "f_{max}",
                "meaning": "Maximum clock frequency",
                "units": "Hz (GHz for modern CPUs)"
              },
              {
                "symbol": "t_{cq}",
                "meaning": "Clock-to-Q delay (FF output delay)",
                "units": "picoseconds"
              },
              {
                "symbol": "t_{logic}",
                "meaning": "Combinational logic delay between FFs",
                "units": "picoseconds"
              },
              {
                "symbol": "t_{su}",
                "meaning": "Setup time of receiving FF",
                "units": "picoseconds"
              }
            ],
            "meaning": "The clock period must be long enough for data to propagate from one FF through logic to the next FF's input.",
            "derivation": "Data must: (1) exit source FF (t_cq), (2) traverse logic (t_logic), (3) arrive before destination FF setup (t_su).",
            "example": {
              "problem": "Calculate max frequency for: t_cq=50ps, t_logic=150ps, t_su=50ps.",
              "given": [
                "t_cq = 50ps",
                "t_logic = 150ps",
                "t_su = 50ps"
              ],
              "steps": [
                "Period = t_{cq} + t_{logic} + t_{su}",
                "Period = 50 + 150 + 50 = 250ps",
                "f_{max} = \\frac{1}{250ps} = 4GHz"
              ],
              "answer": "f_max = 4GHz"
            },
            "latex": "f_{max} = 1 / (t_{cq} + t_{logic} + t_{su})",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">ma</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\">1/</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">q</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">s</span><span class=\"mord mathnormal mtight\">u</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "name": "Hold Time Requirement",
            "variables": [
              {
                "symbol": "t_{cq}",
                "meaning": "Source FF clock-to-Q delay",
                "units": "picoseconds"
              },
              {
                "symbol": "t_{logic}",
                "meaning": "Minimum logic delay (could be 0 for direct connection)",
                "units": "picoseconds"
              },
              {
                "symbol": "t_{h}",
                "meaning": "Destination FF hold time",
                "units": "picoseconds"
              }
            ],
            "meaning": "Data must not arrive at the destination FF too quickly—it must hold stable for t_h after the clock edge.",
            "derivation": "If new data arrives before hold time expires, it corrupts the previous capture. Delay must be > t_h.",
            "example": {
              "problem": "Is hold time met if t_cq=30ps, t_logic=0ps (wire), t_h=25ps?",
              "given": [
                "t_cq = 30ps",
                "t_logic = 0ps",
                "t_h = 25ps"
              ],
              "steps": [
                "Data arrival delay = t_{cq} + t_{logic} = 30 + 0 = 30ps",
                "Hold requirement = t_{h} = 25ps",
                "30ps > 25ps? Yes"
              ],
              "answer": "Hold time is met (30ps > 25ps). Safe!"
            },
            "latex": "t_{cq} + t_{logic} > t_{h}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">c</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">q</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">c</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "name": "Metastability MTBF",
            "variables": [
              {
                "symbol": "MTBF",
                "meaning": "Mean Time Between Failures (metastability events)",
                "units": "seconds (years ideally)"
              },
              {
                "symbol": "t_{res}",
                "meaning": "Resolution time (slack for metastability to resolve)",
                "units": "nanoseconds"
              },
              {
                "symbol": "τ (tau)",
                "meaning": "Metastability time constant - how fast the flip-flop resolves unstable states (technology dependent, typically 10-50ps)",
                "units": "picoseconds"
              },
              {
                "symbol": "f_{clk}",
                "meaning": "Clock frequency",
                "units": "Hz"
              },
              {
                "symbol": "f_{data}",
                "meaning": "Data transition rate",
                "units": "Hz"
              },
              {
                "symbol": "T_{window}",
                "meaning": "Timing violation window (setup + hold)",
                "units": "seconds"
              }
            ],
            "meaning": "More resolution time exponentially increases MTBF. This is why we use 2-3 flip-flop synchronizer chains.",
            "derivation": "Each additional FF stage adds resolution time, multiplying MTBF by a huge factor.",
            "example": {
              "problem": "Why do synchronizers use 2+ flip-flops?",
              "given": [
                "Single FF MTBF might be hours",
                "Each FF adds ~30ps resolution time"
              ],
              "steps": [
                "MTBF ∝ exp(t_{res}/τ)",
                "Adding one FF: MTBF \\times 10⁶ (typical)",
                "Two FFs in series: MTBF = years to centuries"
              ],
              "answer": "2 FFs increase MTBF from hours to millions of years—safe for practical systems."
            },
            "latex": "MTBF = exp(t_{res} / τ) / (f_{clk} \\times f_{data} \\times T_{window})",
            "html": null
          }
        ],
        "exercises": [
          {
            "question": "A D flip-flop has D=1 and CLK transitions 0→1. What is Q after the clock edge?",
            "hint": "On rising edge, Q captures D.",
            "answer": "Q = 1 (D is captured at the rising edge)"
          },
          {
            "question": "If t_cq=60ps, t_logic=200ps, t_su=40ps, what is f_max?",
            "hint": "f_max = 1 / T, where T is the total delay through the longest path.",
            "answer": {
              "steps": [
                "1. Calc Total Delay (T): t_cq + t_logic + t_su = 60 + 200 + 40 = 300ps.",
                "2. convert to seconds: 300 × 10⁻¹² s.",
                "3. Calc f_max: 1 / (300 × 10⁻¹²) ≈ 3.33 × 10⁹ Hz.",
                "4. Result: 3.33 GHz."
              ],
              "answer": "3.33 GHz"
            }
          },
          {
            "question": "A design has a timing violation with 10ps negative slack. What are two ways to fix it?",
            "hint": "You need to either slow down or make the path faster.",
            "answer": {
              "steps": [
                "(1) Reduce clock frequency (longer period).",
                "(2) Reduce logic delay (shorter path or faster gates).",
                "(3) Use a faster flip-flop (lower t_cq + t_su)."
              ],
              "answer": ""
            }
          }
        ],
        "realWorld": {
          "context": "D flip-flops are the fundamental building blocks of all synchronous digital systems—from simple counters to billion-transistor CPUs.",
          "example": "A modern CPU has billions of flip-flops. The 4GHz clock must reach them all within ~10ps skew (clock tree design).",
          "numbers": "Apple M1 has ~16 billion transistors. Roughly 10-20% are in flip-flops for registers, pipeline stages, and control logic.",
          "connection": "This level introduces synchronous design—the discipline that makes complex digital systems possible by coordinating all changes to clock edges."
        }
      },
      "variants": {
        "easy": {
          "introText": "EDGE-TRIGGERED FLIP-FLOPS & SYNCHRONOUS DESIGN: The D Flip-Flop samples input D only on the clock edge.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "maxGates": 1
        },
        "medium": {
          "title": "D Flip-Flop with Enable",
          "objective": "Conditional data capture",
          "description": "Build a D-FF that only captures data when Enable=1. When Enable=0, it holds its previous value regardless of clock edges.",
          "introText": "An ENABLED FLIP-FLOP gives fine-grained control over which registers update on each clock cycle. In a CPU register file, only the destination register should change—others must hold their values. The classic solution: use a MUX to select between new Data (when Enable=1) and the current Q output (when Enable=0), feeding the result to a standard D-FF.",
          "physicsVisual": "dff_enable",
          "hint": "Use a MUX: when EN=0, feed Q back to D input. When EN=1, feed Data to D input. The MUX output goes to the D-FF.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "inputs": 3,
          "targetSequence": [
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "D=1, CLK=0, EN=0: Setup"
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0
              ],
              "desc": "D=1, CLK↑, EN=0: No capture (EN off)"
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "D=1, CLK=0, EN=1: Setup with EN"
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "D=1, CLK↑, EN=1: Capture D=1"
            },
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                1
              ],
              "desc": "D=0, CLK=0, EN=0: Hold Q=1"
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1
              ],
              "desc": "D=0, CLK↑, EN=0: Still hold Q=1"
            }
          ],
          "maxGates": 2,
          "xpReward": 135
        },
        "hard": {
          "title": "Rising Edge Detector",
          "objective": "Detect 0→1 transitions",
          "description": "Build a circuit that outputs a single pulse (1 for one clock cycle) whenever the input transitions from 0 to 1.",
          "introText": "EDGE DETECTION is essential in digital systems. A button press should trigger ONE action, not continuous actions while held. The classic solution: compare the current input with its delayed version (from a D-FF). Output = Input AND (NOT Delayed_Input). This creates a pulse only on 0→1 transitions. CPUs use edge detectors for interrupt handling and synchronization.",
          "physicsVisual": "edge_detector",
          "hint": "Use a D-FF to create a 1-cycle delayed version of the input. Then: Output = Input AND (NOT Delayed). When input goes 0→1, Delayed is still 0, so output is 1. Next cycle, Delayed becomes 1, output returns to 0.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "targetSequence": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "In=0, CLK=0: No edge"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "In=0, CLK↑: Still 0"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ],
              "desc": "In=1, CLK=0: Setup rising"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "In=1, CLK↑: EDGE DETECTED!"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ],
              "desc": "In=1, CLK=0: Hold"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ],
              "desc": "In=1, CLK↑: No edge (still high)"
            },
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "In=0, CLK=0: Falling"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0
              ],
              "desc": "In=1, CLK=0: Setup new rise"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "In=1, CLK↑: EDGE DETECTED!"
            }
          ],
          "maxGates": 3,
          "xpReward": 155
        }
      }
    },
    {
      "id": "level_16",
      "tier": "tier_4",
      "title": "Toggle Flip-Flop",
      "objective": "Divide Clock Frequency",
      "description": "Make the output flip every time the clock pulses.",
      "introText": "T FLIP-FLOP & FREQUENCY DIVISION: A T (Toggle) flip-flop changes state on each clock edge when T=1. The output frequency is exactly half the input frequency—this is a divide-by-2 circuit, the foundation of digital clocks and counters.",
      "physicsVisual": "t_flipflop_detailed",
      "hint": "Connect Q-Not back to D on a Flip-Flop.",
      "availableGates": [
        "dFlipFlop"
      ],
      "inputs": 1,
      "targetSequence": [
        {
          "in": [
            0
          ],
          "out": [
            0
          ],
          "desc": "Initial: CLK=0"
        },
        {
          "in": [
            1
          ],
          "out": [
            1
          ],
          "desc": "Toggle 1: CLK=1"
        },
        {
          "in": [
            0
          ],
          "out": [
            1
          ],
          "desc": "Hold: CLK=0"
        },
        {
          "in": [
            1
          ],
          "out": [
            0
          ],
          "desc": "Toggle 2: CLK=1"
        },
        {
          "in": [
            0
          ],
          "out": [
            0
          ],
          "desc": "Hold: CLK=0"
        },
        {
          "in": [
            1
          ],
          "out": [
            1
          ],
          "desc": "Toggle 3: CLK=1"
        }
      ],
      "maxGates": 1,
      "xpReward": 140,
      "storyText": "TOGGLE FLIP-FLOP IMPLEMENTATION: The T flip-flop is constructed by feeding Q̄ back to D. This creates a divide-by-2 frequency divider with perfect 50% duty cycle. Chaining T flip-flops creates prescalers for digital clocks.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "T Flip-Flop (Toggle)",
            "definition": "A flip-flop that toggles its output on each active clock edge. When T=1, Q_next = NOT(Q). When T=0, Q holds.",
            "why": "T flip-flops are the building blocks of counters and frequency dividers—essential for digital timing.",
            "analogy": "Like a light switch that flips every time you tap it—tap once for ON, tap again for OFF.",
            "visuals": [
              {
                "type": "t_flipflop_detailed",
                "title": "T Flip-Flop: Divide-by-2"
              }
            ],
            "latex": "Q_{next} = Q \\oplus T (toggle when T=1)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">gg</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "Frequency Division",
            "definition": "Reducing clock frequency by an integer factor. A T flip-flop divides by 2; n cascaded T-FFs divide by 2ⁿ.",
            "why": "High-frequency oscillators are precise but fast. Division creates usable lower frequencies.",
            "analogy": "Like gear reduction: a fast-spinning motor shaft drives a slower output shaft.",
            "visuals": [
              {
                "type": "counter_2bit",
                "title": "Cascaded Frequency Division"
              }
            ],
            "latex": "f_{out} = \\frac{f_{in}}{2}ⁿ",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3315em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">in</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9865em;\"><span style=\"top:-3.3851em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "term": "Duty Cycle",
            "definition": "The percentage of time a signal is HIGH during one period. A T flip-flop output has exactly 50% duty cycle.",
            "why": "Many circuits require specific duty cycles. 50% is symmetric and often ideal.",
            "analogy": "Like work-rest ratio: 50% duty = equal time ON and OFF.",
            "visuals": [
              {
                "type": "nand_universal",
                "title": "Symmetric Pulse Train"
              }
            ],
            "latex": "Duty = \\frac{T_{high}}{T_{period}} \\times 100%",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.5395em;vertical-align:-0.5481em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9914em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2901em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.5131em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3488em;margin-left:-0.1389em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">hi</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2901em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5481em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">100</span></span></span></span>"
          },
          {
            "term": "D-to-T Conversion",
            "definition": "A T flip-flop is made from a D flip-flop by connecting Q̄ to D. This makes D always the opposite of Q.",
            "why": "D flip-flops are more common in libraries; knowing the conversion lets you build T behavior.",
            "analogy": "Like using a see-saw: connecting Q̄ to D makes the output 'see-saw' between 0 and 1.",
            "latex": "D = \\bar{Q} (for always-toggle behavior)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0701em;vertical-align:-0.25em;\"></span><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\">Q</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1944em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">lw</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">ys</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">gg</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">ha</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mclose\">)</span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "T Flip-Flop Behavior",
            "variables": [
              {
                "symbol": "Q",
                "meaning": "Current output",
                "units": "Logic level"
              },
              {
                "symbol": "T",
                "meaning": "Toggle enable input",
                "units": "Logic level"
              },
              {
                "symbol": "Q_{next}",
                "meaning": "Output after clock edge",
                "units": "Logic level"
              },
              {
                "symbol": "\\oplus",
                "meaning": "XOR operation",
                "units": ""
              }
            ],
            "meaning": "When T=1, output toggles (XOR with 1 inverts). When T=0, output holds (XOR with 0 keeps same).",
            "derivation": "Q ⊕ 0 = Q (hold). Q ⊕ 1 = Q̄ (toggle). XOR naturally implements this behavior.",
            "example": {
              "problem": "If Q=1 and T=1, what is Q_next?",
              "given": [
                "Q = 1",
                "T = 1"
              ],
              "steps": [
                "Q_{next} = Q \\oplus T",
                "Q_{next} = 1 \\oplus 1",
                "Q_{next} = 0 (toggled)"
              ],
              "answer": "Q_next = 0 (output toggled from 1 to 0)"
            },
            "latex": "Q_{next} = Q \\oplus T",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>"
          },
          {
            "name": "Frequency Division",
            "variables": [
              {
                "symbol": "f_{in}",
                "meaning": "Input clock frequency",
                "units": "Hz"
              },
              {
                "symbol": "f_{out}",
                "meaning": "Output frequency",
                "units": "Hz"
              },
              {
                "symbol": "n",
                "meaning": "Number of cascaded T flip-flops",
                "units": "count"
              }
            ],
            "meaning": "Each T flip-flop halves the frequency. Chaining n of them divides by 2ⁿ.",
            "derivation": "1 T-FF: f/2. 2 T-FFs: (f/2)/2 = f/4. n T-FFs: f/2ⁿ.",
            "example": {
              "problem": "How many T flip-flops to divide 32.768kHz down to 1Hz?",
              "given": [
                "f_in = 32768 Hz",
                "f_out = 1 Hz"
              ],
              "steps": [
                "1. Apply formula: f_{out} = \\frac{f_{in}}{2}ⁿ",
                "2. Substitute: 1 Hz = 32768 \\frac{Hz}{2}ⁿ",
                "3. Rearrange: 2ⁿ = \\frac{32768}{1} = 32768",
                "4. Solve for n (exponent): since 2¹⁰ = 1024, 2¹¹ = 2048, 2¹² = 4096, 2¹³ = 8192, 2¹⁴ = 16384, 2¹⁵ = 32768.",
                "5. Result: n = 15"
              ],
              "answer": "15 T flip-flops (note: 32768 = 2¹⁵, why digital watches use this crystal!)"
            },
            "latex": "f_{out} = \\frac{f_{in}}{2}ⁿ",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2806em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">t</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.3315em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3281em;\"><span style=\"top:-2.357em;margin-left:-0.1076em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">in</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9865em;\"><span style=\"top:-3.3851em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "name": "Ripple Counter Delay",
            "variables": [
              {
                "symbol": "t_{ripple}",
                "meaning": "Total delay from clock to MSBoutput",
                "units": "nanoseconds"
              },
              {
                "symbol": "n",
                "meaning": "Number of stages (bits)",
                "units": "count"
              },
              {
                "symbol": "t_{prop}",
                "meaning": "Propagation delay per flip-flop",
                "units": "nanoseconds"
              }
            ],
            "meaning": "In a ripple counter, each stage waits for the previous. Total delay accumulates.",
            "derivation": "Stage 0 changes after t_prop. Stage 1 waits for stage 0, then t_prop more. Total = n × t_prop.",
            "example": {
              "problem": "An 8-bit ripple counter with t_prop=2ns per stage. Maximum delay?",
              "given": [
                "n = 8 bits",
                "t_prop = 2ns"
              ],
              "steps": [
                "t_{ripple} = n \\times t_{prop}",
                "t_{ripple} = 8 \\times 2ns",
                "t_{ripple} = 16ns"
              ],
              "answer": "16ns for MSB to settle (vs ~4ns for synchronous counter)"
            },
            "latex": "t_{ripple} = n \\times t_{prop}",
            "html": null
          }
        ],
        "exercises": [
          {
            "question": "A T flip-flop starts at Q=0. After 5 clock edges, what is Q?",
            "hint": "Toggle 5 times starting from 0: 0→1→0→1→0→1.",
            "answer": "Q = 1 (odd number of toggles from 0)"
          },
          {
            "question": "Design a divide-by-8 circuit. How many T flip-flops needed?",
            "hint": "8 = 2³, so divide by 2 three times.",
            "answer": "3 T flip-flops in series (each divides by 2: 2×2×2 = 8)"
          },
          {
            "question": "A 10MHz clock feeds a T flip-flop chain. What frequency comes out of the 4th flip-flop?",
            "hint": "Each stage divides by 2. After 4 stages: f/2⁴.",
            "answer": "10MHz / 2⁴ = 10MHz / 16 = 625kHz"
          }
        ],
        "realWorld": {
          "context": "T flip-flops and frequency dividers are essential for digital timekeeping and clock generation.",
          "example": "Digital watches use 32.768kHz crystals because 2¹⁵ = 32768, so 15 T flip-flops produce exactly 1Hz.",
          "numbers": "USB2.0 runs at 480MHz, derived from 12MHz oscillators. PLLs multiply up while T-FF chains divide down for various timing needs.",
          "connection": "This level teaches frequency division—the key to creating usable clock signals from fast oscillators and building counters."
        }
      },
      "variants": {
        "easy": {
          "introText": "T FLIP-FLOP & FREQUENCY DIVISION: A T (Toggle) flip-flop changes state on each clock edge when T=1.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ]
        },
        "medium": {
          "title": "Frequency Divider",
          "objective": "Divide clock by 2",
          "description": "Build a circuit that outputs a signal at half the frequency of the input clock. For every 2 input pulses, output 1 pulse.",
          "introText": "FREQUENCY DIVISION is fundamental to clock generation. A crystal oscillator might run at 100MHz, but your CPU needs various derived clocks (50MHz, 25MHz, etc.). A T flip-flop (toggle) naturally divides by 2: it flips state on every clock edge. Chain multiple together to divide by 4, 8, 16... This is how clock trees generate system clocks.",
          "physicsVisual": "freq_divider",
          "hint": "Connect Q_NOT back to D to make a toggle flip-flop. Output Q changes state on every clock edge, producing a half-frequency signal.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "targetSequence": [
            {
              "in": [
                0
              ],
              "out": [
                0
              ],
              "desc": "CLK=0: Initial state"
            },
            {
              "in": [
                1
              ],
              "out": [
                1
              ],
              "desc": "CLK↑ #1: Toggle to 1"
            },
            {
              "in": [
                0
              ],
              "out": [
                1
              ],
              "desc": "CLK=0: Hold at 1"
            },
            {
              "in": [
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK↑ #2: Toggle to 0"
            },
            {
              "in": [
                0
              ],
              "out": [
                0
              ],
              "desc": "CLK=0: Hold at 0"
            },
            {
              "in": [
                1
              ],
              "out": [
                1
              ],
              "desc": "CLK↑ #3: Toggle to 1"
            }
          ],
          "maxGates": 2,
          "xpReward": 145
        },
        "hard": {
          "title": "JK Flip-Flop",
          "objective": "Build the universal flip-flop",
          "description": "Build a JK Flip-Flop from a D Flip-Flop and logic gates. J=K=0: Hold, J=1,K=0: Set, J=0,K=1: Reset, J=K=1: Toggle.",
          "introText": "The JK FLIP-FLOP is called 'universal' because it can emulate D, T, and SR flip-flops. Its characteristic equation is: Q_next = J·Q' + K'·Q. Before modern synthesis tools, JK-FFs were the standard building block. The toggle mode (J=K=1) is particularly useful for counters. Understanding JK helps you appreciate why D-FFs became dominant (simpler to use in synchronous design).",
          "physicsVisual": "jk_flipflop",
          "hint": "D = (J AND NOT Q) OR (NOT K AND Q). Use the D-FF's Q output, invert it, and build this equation using AND/OR gates.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "inputs": 3,
          "targetSequence": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "J=0, K=0, CLK=0: Setup HOLD"
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "J=0, K=0, CLK↑: HOLD (Q stays 0)"
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "J=1, K=0, CLK=0: Setup SET"
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                1
              ],
              "desc": "J=1, K=0, CLK↑: SET (Q→1)"
            },
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                1
              ],
              "desc": "J=0, K=0, CLK=0: Setup HOLD"
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                1
              ],
              "desc": "J=0, K=0, CLK↑: HOLD (Q stays 1)"
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1
              ],
              "desc": "J=0, K=1, CLK=0: Setup RESET"
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0
              ],
              "desc": "J=0, K=1, CLK↑: RESET (Q→0)"
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0
              ],
              "desc": "J=1, K=1, CLK=0: Setup TOGGLE"
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "J=1, K=1, CLK↑: TOGGLE (0→1)"
            }
          ],
          "maxGates": 5,
          "xpReward": 170
        }
      }
    },
    {
      "id": "level_17",
      "tier": "tier_5",
      "title": "2-Bit Counter",
      "objective": "Count 00, 01, 10, 11",
      "description": "Build a circuit that counts clock pulses.",
      "introText": "BINARY COUNTERS & STATE MACHINES: A counter is a Finite State Machine (FSM) that sequences through states. An n-bit counter has 2ⁿ states. Counters are everywhere: program counters in CPUs, timers, address generators, and event trackers.",
      "physicsVisual": "counter_detailed",
      "hint": "Use two T-Flip-Flop configurations chained together.",
      "availableGates": [
        "dFlipFlop",
        "not"
      ],
      "inputs": 1,
      "targetSequence": [
        {
          "in": [
            0
          ],
          "out": [
            0,
            0
          ],
          "desc": "Initial: 0"
        },
        {
          "in": [
            1
          ],
          "out": [
            1,
            0
          ],
          "desc": "Tick 1: 01"
        },
        {
          "in": [
            0
          ],
          "out": [
            1,
            0
          ],
          "desc": "Wait: 01"
        },
        {
          "in": [
            1
          ],
          "out": [
            0,
            1
          ],
          "desc": "Tick 2: 10"
        },
        {
          "in": [
            0
          ],
          "out": [
            0,
            1
          ],
          "desc": "Wait: 10"
        },
        {
          "in": [
            1
          ],
          "out": [
            1,
            1
          ],
          "desc": "Tick 3: 11"
        },
        {
          "in": [
            0
          ],
          "out": [
            1,
            1
          ],
          "desc": "Wait: 11"
        },
        {
          "in": [
            1
          ],
          "out": [
            0,
            0
          ],
          "desc": "Tick 4: ROLLOVER to 00"
        }
      ],
      "maxGates": 4,
      "xpReward": 160,
      "storyText": "BINARY COUNTER ARCHITECTURE: A 2-bit counter requires 2 flip-flops. The LSB toggles every clock; the next bit toggles when LSB falls. This ripple counter is simple but has accumulated delay. Synchronous counters clock all FFs together for faster operation.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Binary Counter",
            "definition": "A sequential circuit that counts through binary states in sequence: 00→01→10→11→00 (for 2-bit).",
            "why": "Counters track events, generate addresses, and form the core of timers and program counters.",
            "analogy": "Like an odometer: each digit counts up, and when it reaches max, it rolls over and carries to the next digit.",
            "latex": "States = 2ⁿ for n-bit counter",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">co</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span></span></span></span>",
            "visuals": [
              {
                "type": "counter_detailed",
                "title": "Counter: Sequential States"
              }
            ]
          },
          {
            "term": "Ripple Counter",
            "definition": "A counter where each flip-flop is clocked by the output of the previous stage. Changes 'ripple' through.",
            "why": "Simple design using cascaded T flip-flops, but slower due to accumulated propagation delay.",
            "analogy": "Like dominoes falling: each one triggers the next after a small delay.",
            "visuals": [
              {
                "type": "counter_2bit",
                "title": "Ripple Propagation"
              }
            ],
            "latex": "Delay = n \\times t_{prop}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">De</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9012em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">ro</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "term": "Synchronous Counter",
            "definition": "A counter where all flip-flops share the same clock. Combinational logic determines which FFs toggle.",
            "why": "All outputs change simultaneously (within one t_prop), enabling faster operation.",
            "analogy": "Like synchronized swimmers: everyone moves at the same moment.",
            "visuals": [
              {
                "type": "t_flipflop",
                "title": "Synchronized Toggle"
              }
            ],
            "latex": "Delay = t_{prop} (same for all bits)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">De</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mord mathnormal mtight\">ro</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">am</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">bi</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>"
          },
          {
            "term": "Rollover (Overflow)",
            "definition": "When a counter exceeds its maximum value and wraps around to zero. For n bits: 2ⁿ-1 → 0.",
            "why": "Rollover can generate interrupts, trigger events, or indicate a complete counting cycle.",
            "analogy": "Like a clock going from 11:59 to 12:00—the cycle completes and starts over.",
            "visuals": [
              {
                "type": "half_adder",
                "title": "Overflow: Max + 1"
              }
            ],
            "latex": "11\\ldots1 + 1 = 00\\ldots0 (with overflow)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">11</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">00</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "Counter State Count",
            "latex": "States = 2ⁿ",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>",
            "variables": [
              {
                "symbol": "States",
                "meaning": "Number of unique count values",
                "units": "count"
              },
              {
                "symbol": "n",
                "meaning": "Number of bits (flip-flops)",
                "units": "bits"
              }
            ],
            "meaning": "An n-bit counter can represent 2ⁿ different values, from 0 to 2ⁿ-1.",
            "derivation": "Each bit can be 0 or 1. With n bits, there are 2×2×...×2 = 2ⁿ combinations.",
            "example": {
              "problem": "How many states does a 4-bit counter have? What's the maximum count?",
              "given": [
                "n = 4 bits"
              ],
              "steps": [
                "States = 2ⁿ = 2⁴ = 16",
                "Counts from 0 to 15",
                "Maximum = 2⁴ - 1 = 15"
              ],
              "answer": "16 states, counts 0 to 15"
            }
          },
          {
            "name": "Ripple Counter Toggle Condition",
            "variables": [
              {
                "symbol": "T_{0}",
                "meaning": "Toggle enable for LSB(bit 0)",
                "units": "Logic level"
              },
              {
                "symbol": "T_{n}",
                "meaning": "Toggle enable for bit n",
                "units": "Logic level"
              },
              {
                "symbol": "Q_{n-1}",
                "meaning": "Output of previous bit",
                "units": "Logic level"
              }
            ],
            "meaning": "In a ripple counter, each bit toggles when the previous bit transitions from 1 to 0.",
            "derivation": "Q₀ toggles every clock. Q₁ toggles when Q₀ falls (goes 1→0). Q₂ toggles when Q₁ falls.",
            "example": {
              "problem": "In state 01, which bits toggle on the next clock?",
              "given": [
                "Current state = 01 (Q₁=0, Q₀=1)"
              ],
              "steps": [
                "Q_{0} always toggles: 1→0",
                "Q_{1} toggles if Q_{0} falls (1→0): Yes!",
                "Next state: 10"
              ],
              "answer": "Both bits toggle: 01 → 10"
            },
            "latex": "T_{0} = 1 (always), T_{n} = Q_{n-1} falling edge",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">lw</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">ys</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9028em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span></span></span></span>"
          },
          {
            "name": "Synchronous Counter Toggle Condition",
            "variables": [
              {
                "symbol": "T_{n}",
                "meaning": "Toggle enable for bit n",
                "units": "Logic level"
              },
              {
                "symbol": "Q_{0}\\ldotsQ_{n-1}",
                "meaning": "All lower bit outputs",
                "units": "Logic levels"
              }
            ],
            "meaning": "In a synchronous counter, bit n toggles when ALL lower bits are 1 (about to roll over).",
            "derivation": "Bit n changes when lower bits go from 11...1 to 00...0. This happens when all lower bits are 1.",
            "example": {
              "problem": "In 4-bit synchronous counter at state 0111, which bits toggle?",
              "given": [
                "State = 0111 (Q₃=0, Q₂=1, Q₁=1, Q₀=1)"
              ],
              "steps": [
                "T_{0} = 1 (always toggle)",
                "T_{1} = Q_{0} = 1 (toggle)",
                "T_{2} = Q_{0} \\cdot Q_{1} = 1\\cdot 1 = 1 (toggle)",
                "T_{3} = Q_{0} \\cdot Q_{1} \\cdot Q_{2} = 1\\cdot1\\cdot1 = 1 (toggle)",
                "All toggle: 0111 → 1000"
              ],
              "answer": "All 4 bits toggle: 0111 → 1000"
            },
            "latex": "T_{n} = Q_{0} \\cdot Q_{1} \\cdot \\ldots \\cdot Q_{n-1}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8917em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span></span>"
          }
        ],
        "exercises": [
          {
            "question": "List the sequence of states for a 2-bit counter starting from 00, for 6 clock pulses.",
            "hint": "Count: 00, 01, 10, 11, then rollover and continue.",
            "answer": "00 → 01 → 10 → 11 → 00 → 01 → 10"
          },
          {
            "question": "Design an 8-bit counter. How many flip-flops needed? How many states?",
            "hint": "1 flip-flop per bit. States = 2ⁿ.",
            "answer": "8 flip-flops. 2⁸ = 256 states (counts 0 to 255)"
          },
          {
            "question": "A 3-bit ripple counter with t_prop=3ns per stage. What's the maximum delay for Q₂ to update?",
            "hint": "Ripple delay = stages × t_prop from clock to final bit.",
            "answer": "3 stages × 3ns = 9ns (clock→Q₀→Q₁→Q₂)"
          }
        ],
        "realWorld": {
          "context": "Counters are fundamental building blocks found in every digital system.",
          "example": "The Program Counter (PC) in a CPU is a counter that holds the address of the next instruction. MIPS: 32-bit PC, ARM: 32-bit or 64-bit.",
          "numbers": "Intel CPUs have hardware performance counters (48-bit) tracking cache misses, branch mispredictions, and instruction counts—essential for optimization.",
          "connection": "This level builds a 2-bit counter—the simplest FSM. You're now ready for more complex state machines like the traffic light controller."
        }
      },
      "variants": {
        "easy": {
          "introText": "BINARY COUNTERS & STATE MACHINES: A counter is a Finite State Machine (FSM) that sequences through states.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ]
        },
        "medium": {
          "title": "Gray Code Counter",
          "objective": "Count in Gray code sequence",
          "description": "Build a 2-bit counter that counts in Gray code: 00→01→11→10→00. Only one bit changes per transition.",
          "introText": "GRAY CODE is a binary numeral system where consecutive values differ by only one bit. This eliminates glitches during transitions—critical for rotary encoders, ADCs, and crossing clock domains. Normal binary 01→10 changes TWO bits; if they don't switch simultaneously, you might briefly read 00 or 11 (glitch!). Gray code: 01→11 changes only one bit. No glitch possible.",
          "physicsVisual": "gray_code_counter",
          "hint": "Gray code sequence: 00→01→11→10→00. Use two D-FFs and logic to compute next state. Q1_next and Q0_next depend on current Q1,Q0 in a specific pattern.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "targetSequence": [
            {
              "in": [
                0
              ],
              "out": [
                0,
                0
              ],
              "desc": "Initial: 00"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                1
              ],
              "desc": "Tick 1: 01 (1 bit change)"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                1
              ],
              "desc": "Tick 2: 11 (1 bit change)"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "Tick 3: 10 (1 bit change)"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "Tick 4: 00 (wrap, 1 bit change)"
            }
          ],
          "maxGates": 6,
          "xpReward": 175
        },
        "hard": {
          "title": "Synchronous 2-Bit Counter",
          "objective": "Glitch-free parallel counting",
          "description": "Build a synchronous 2-bit counter where all flip-flops update on the same clock edge. No ripple delay!",
          "introText": "SYNCHRONOUS COUNTERS eliminate ripple delay by computing all next-state bits combinationally and latching them simultaneously. For a 2-bit counter: Q0 toggles every cycle (D0 = NOT Q0). Q1 toggles when Q0 is 1 (D1 = Q1 XOR Q0). All FFs share the same clock—outputs change in parallel with no skew. This is how real CPU program counters work.",
          "physicsVisual": "sync_counter",
          "hint": "Both D-FFs get the system clock directly. D0 = NOT Q0 (always toggle). D1 = Q1 XOR Q0 (toggle Q1 only when Q0=1). Use XOR and NOT gates with two D-FFs.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "targetSequence": [
            {
              "in": [
                0
              ],
              "out": [
                0,
                0
              ],
              "desc": "Initial: 00, CLK=0"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                1
              ],
              "desc": "CLK↑: 00→01 (parallel update)"
            },
            {
              "in": [
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "CLK=0: Hold 01"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "CLK↑: 01→10 (parallel update)"
            },
            {
              "in": [
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "CLK=0: Hold 10"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                1
              ],
              "desc": "CLK↑: 10→11 (parallel update)"
            },
            {
              "in": [
                0
              ],
              "out": [
                1,
                1
              ],
              "desc": "CLK=0: Hold 11"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "CLK↑: 11→00 (wrap)"
            }
          ],
          "xpReward": 190
        }
      }
    },
    {
      "id": "level_18",
      "tier": "tier_5",
      "title": "Traffic Light Controller",
      "objective": "Green -> Yellow -> Red",
      "description": "Design a Finite State Machine.",
      "introText": "FINITE STATE MACHINE DESIGN: An FSM consists of states, inputs, outputs, and transition logic. The traffic light is a classic example: three states (GREEN, YELLOW, RED) cycling in sequence. FSMs are the control logic in every digital system.",
      "physicsVisual": "fsm_traffic",
      "hint": "Use Flip-Flops to store state and logic to determine next state.",
      "availableGates": [
        "dFlipFlop",
        "and",
        "or",
        "not"
      ],
      "inputs": 1,
      "targetSequence": [
        {
          "in": [
            0
          ],
          "out": [
            0,
            0,
            0
          ],
          "desc": "Initial State (Reset)"
        },
        {
          "in": [
            1
          ],
          "out": [
            1,
            0,
            0
          ],
          "desc": "Tick 1: GREEN"
        },
        {
          "in": [
            0
          ],
          "out": [
            1,
            0,
            0
          ],
          "desc": "Wait: GREEN"
        },
        {
          "in": [
            1
          ],
          "out": [
            0,
            1,
            0
          ],
          "desc": "Tick 2: YELLOW"
        },
        {
          "in": [
            0
          ],
          "out": [
            0,
            1,
            0
          ],
          "desc": "Wait: YELLOW"
        },
        {
          "in": [
            1
          ],
          "out": [
            0,
            0,
            1
          ],
          "desc": "Tick 3: RED"
        },
        {
          "in": [
            0
          ],
          "out": [
            0,
            0,
            1
          ],
          "desc": "Wait: RED"
        },
        {
          "in": [
            1
          ],
          "out": [
            1,
            0,
            0
          ],
          "desc": "Tick 4: Back to GREEN"
        }
      ],
      "maxGates": 10,
      "xpReward": 200,
      "storyText": "FSM DESIGN METHODOLOGY: (1) Draw state diagram, (2) Create state table, (3) Choose state encoding, (4) Derive next-state equations, (5) Implement with flip-flops and logic. This systematic approach scales from traffic lights to CPU control units.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Finite State Machine (FSM)",
            "definition": "A computational model with a finite number of states, transitions between states based on inputs, and outputs determined by state (and possibly inputs).",
            "why": "FSMs are the foundation of sequential logic design—they model any system with memory and defined behaviors.",
            "analogy": "Like a board game: you're always on one square (state), dice rolls (inputs) determine your next square, and the square determines what happens (output).",
            "latex": "FSM = (States, Inputs, Outputs, Transitions)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">FSM</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">s</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "fsm_traffic",
                "title": "FSM: State → Outputs"
              }
            ]
          },
          {
            "term": "Moore Machine",
            "definition": "An FSM where outputs depend ONLY on the current state, not on inputs. Outputs are 'attached' to states.",
            "why": "Moore machines have stable, glitch-free outputs that change only on clock edges.",
            "analogy": "Like traffic light colors: the light color depends on which state you're in, not on what cars are doing.",
            "latex": "Output = f(State)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "decoder",
                "title": "State Decode to Outputs"
              }
            ]
          },
          {
            "term": "Mealy Machine",
            "definition": "An FSM where outputs depend on both current state AND current inputs. Outputs are 'attached' to transitions.",
            "why": "Mealy machines can respond faster (within the same clock cycle as input) but may have glitchy outputs.",
            "analogy": "Like a vending machine: what it dispenses depends on current state AND what button you press.",
            "latex": "Output = f(State, Input)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">tp</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "multiplexer",
                "title": "State+Input → Output MUX"
              }
            ]
          },
          {
            "term": "State Encoding",
            "definition": "The binary representation chosen for each state. Options: binary (minimum FFs), one-hot (one FF per state), Gray code (minimal transitions).",
            "why": "Encoding affects circuit complexity, speed, and power consumption.",
            "analogy": "Like numbering seats in a theater: you can use row+seat, sequential numbers, or coordinates.",
            "visuals": [
              {
                "type": "sr_latch",
                "title": "Storage: FFs Hold State"
              }
            ],
            "latex": "Binary: ceil(log_{2}N) FFs. One-hot: N FFs.",
            "html": null
          }
        ],
        "formulaCards": [
          {
            "name": "Ceiling Function",
            "latex": "⌈x⌉ = smallest integer ≥ x",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">⌉</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">es</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>",
            "variables": [
              {
                "symbol": "⌈x⌉",
                "meaning": "Ceiling of x - round up to next integer",
                "units": "integer"
              },
              {
                "symbol": "x",
                "meaning": "Any real number",
                "units": "real"
              }
            ],
            "meaning": "Always rounds UP. Used when you need 'at least' a certain number (like flip-flops for states).",
            "derivation": "Examples: ⌈1.1⌉=2, ⌈2.0⌉=2, ⌈2.9⌉=3. If x is not a whole number, go to the next whole number above.",
            "example": {
              "problem": "How many bits needed to represent 5 states?",
              "given": [
                "States = 5",
                "Bits = ⌈log₂(5)⌉"
              ],
              "steps": [
                "log_{2}(5) ≈ 2.32",
                "⌈2.32⌉ = 3",
                "3 bits can represent 2³=8 values (≥5)"
              ],
              "answer": "3 bits needed"
            }
          },
          {
            "name": "State Count vs Flip-Flops",
            "variables": [
              {
                "symbol": "FFs",
                "meaning": "Number of flip-flops needed",
                "units": "count"
              },
              {
                "symbol": "States",
                "meaning": "Number of states in FSM",
                "units": "count"
              },
              {
                "symbol": "⌈x⌉",
                "meaning": "Ceiling function (round up)",
                "units": ""
              }
            ],
            "meaning": "For binary encoding, you need enough flip-flops to represent all states in binary.",
            "derivation": "n flip-flops can represent 2ⁿ states. Need smallest n where 2ⁿ ≥ States.",
            "example": {
              "problem": "How many flip-flops for a traffic light (3 states)?",
              "given": [
                "States = 3 (GREEN, YELLOW, RED)"
              ],
              "steps": [
                "FFs = ⌈log_{2}(3)⌉",
                "log_{2}(3) ≈ 1.58",
                "⌈1.58⌉ = 2"
              ],
              "answer": "2 flip-flops (can represent 4 states, we use 3)"
            },
            "latex": "FFs = ⌈log_{2}(States)⌉",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">FF</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">es</span><span class=\"mclose\">)⌉</span></span></span></span>"
          },
          {
            "name": "Traffic Light State Encoding",
            "latex": "GREEN=00, YELLOW=01, RED=10",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">GREEN</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">00</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">LL</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">01</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">RE</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">10</span></span></span></span>",
            "variables": [
              {
                "symbol": "S_{1}S_{0}",
                "meaning": "Two-bit state encoding",
                "units": "binary"
              },
              {
                "symbol": "00",
                "meaning": "GREEN state",
                "units": ""
              },
              {
                "symbol": "01",
                "meaning": "YELLOW state",
                "units": ""
              },
              {
                "symbol": "10",
                "meaning": "RED state",
                "units": ""
              }
            ],
            "meaning": "Each state is assigned a unique binary code. The sequence is GREEN→YELLOW→RED→GREEN.",
            "derivation": "With 2 FFs, we have codes 00,01,10,11. We use 00,01,10 and treat 11 as don't-care or reset to 00.",
            "example": {
              "problem": "What's the next state from YELLOW (01)?",
              "given": [
                "Current state = 01 (YELLOW)"
              ],
              "steps": [
                "Sequence: GREEN(00)→YELLOW(01)→RED(10)→GREEN(00)",
                "After 01 comes 10"
              ],
              "answer": "Next state = 10 (RED)"
            }
          },
          {
            "name": "Next State Logic (Mod-3 Counter)",
            "variables": [
              {
                "symbol": "S_{1}, S_{0}",
                "meaning": "Current state bits",
                "units": "Logic level"
              },
              {
                "symbol": "S_{1,\\text{next}}, S_{0,\\text{next}}",
                "meaning": "Next state bits",
                "units": "Logic level"
              }
            ],
            "meaning": "These equations implement the state transition 00→01→10→00 (cycling through 3 states).",
            "derivation": "From state table: 00→01 (S₁:0→0, S₀:0→1), 01→10 (S₁:0→1, S₀:1→0), 10→00 (S₁:1→0, S₀:0→0).",
            "example": {
              "problem": "Calculate next state from GREEN (S₁=0, S₀=0).",
              "given": [
                "S₁ = 0",
                "S₀ = 0"
              ],
              "steps": [
                "S_{1,\\text{next}} = S_{0}\\cdot\\bar{S}_{1} = 0\\cdot1 = 0",
                "S_{0,\\text{next}} = \\bar{S}_{0}\\cdot\\bar{S}_{1} = 1\\cdot1 = 1",
                "Next state = 01"
              ],
              "answer": "01 (YELLOW) - correct transition from GREEN"
            },
            "latex": "S_{1,\\text{next}} = S_{0}\\cdot\\bar{S}_{1}, S_{0,\\text{next}} = \\bar{S}_{0}\\cdot\\bar{S}_{1}",
            "html": null
          }
        ],
        "exercises": [
          {
            "question": "How many flip-flops for a 5-state FSM using binary encoding?",
            "hint": "FFs = ⌈log₂(5)⌉. What's the smallest n where 2ⁿ ≥ 5?",
            "answer": "3 flip-flops (2³ = 8 ≥ 5, but 2² = 4 < 5)"
          },
          {
            "question": "In one-hot encoding, how many flip-flops for a 5-state FSM?",
            "hint": "One-hot uses one FF per state.",
            "answer": "5 flip-flops (states: 00001, 00010, 00100, 01000, 10000)"
          },
          {
            "question": "Design a mod-4 counter (states 00→01→10→11→00). What's the next-state equation for S₁?",
            "hint": "S₁ toggles when S₀ is 1 (going from x1 to y0).",
            "answer": "S₁_next = S₁ ⊕ S₀ (toggle S₁ when S₀=1)"
          }
        ],
        "realWorld": {
          "context": "FSMs control everything from traffic lights to TCP/IP connections to CPU instruction decoders.",
          "example": "TCP state machine: CLOSED→LISTEN→SYN_RCVD→ESTABLISHED→FIN_WAIT→CLOSED. ARM Cortex-M instruction decoder uses ~50 states.",
          "numbers": "A modern CPU control unit might have thousands of states. FPGA implementations can handle millions of state transitions per second.",
          "connection": "This level teaches systematic FSM design—the methodology used to design any sequential control system."
        }
      },
      "variants": {
        "easy": {
          "introText": "FINITE STATE MACHINE DESIGN: An FSM consists of states, inputs, outputs, and transition logic.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "targetSequence": [
            {
              "in": [
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "Initial State (Reset)"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "Tick 1: GREEN"
            },
            {
              "in": [
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "Wait: GREEN"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "Tick 2: YELLOW"
            },
            {
              "in": [
                0
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "Wait: YELLOW"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "Tick 3: RED"
            },
            {
              "in": [
                0
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "Wait: RED"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "Tick 4: Back to GREEN"
            }
          ]
        },
        "medium": {
          "title": "Ring Counter",
          "objective": "Rotating one-hot pattern",
          "description": "Build a 3-bit ring counter that circulates a single '1' through three outputs: 001→010→100→001...",
          "introText": "A RING COUNTER is a simple FSM that rotates a pattern through shift registers. With 3 flip-flops initialized to 001, the pattern rotates: 001→010→100→001. Ring counters are used in round-robin arbiters, LED chasers, and stepper motor controllers. They're 'one-hot' encoded—exactly one bit is always 1.",
          "physicsVisual": "ring_counter",
          "hint": "Connect D-FFs in a ring: Q0→D1, Q1→D2, Q2→D0. Initialize so only one FF starts as 1. The 1 bit 'shifts' around the ring on each clock edge.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "targetSequence": [
            {
              "in": [
                0
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "Initial: 001"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "Tick 1: 010"
            },
            {
              "in": [
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "Tick 2: 100"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "Tick 3: 001 (wrap)"
            },
            {
              "in": [
                1
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "Tick 4: 010"
            }
          ],
          "maxGates": 6,
          "xpReward": 210
        },
        "hard": {
          "title": "Sequence Detector (101)",
          "objective": "Detect the pattern 101",
          "description": "Build an FSM that outputs 1 when it detects the sequence '101' in a serial input stream. The detector should be overlapping (can immediately start detecting the next sequence).",
          "introText": "SEQUENCE DETECTORS are classic FSM problems used in communication protocols, pattern matching, and security systems. To detect '101', you need states: S0 (initial), S1 (seen '1'), S10 (seen '10'), and output 1 when in S10 and input is '1'. Overlapping means after detecting 101, if the next bit is 0, you're already in state S10 (the final '1' starts a new potential '101').",
          "physicsVisual": "sequence_detector",
          "hint": "States: S0→(1)→S1→(0)→S10→(1)→S0+OUTPUT. Use 2 D-FFs for 3 states. Output = Q1·Q0'·Input (in state S10 and input=1). This is a Mealy machine: output depends on current state AND input.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop"
          ],
          "inputs": 2,
          "targetSequence": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0
              ],
              "desc": "CLK=0, In=0: Start in S0"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK↑, In=1: S0→S1"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK=0, In=0: Setup"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK↑, In=0: S1→S10"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK=0, In=1: Setup"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "CLK↑, In=1: DETECTED 101! Output=1, →S1"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK=0, In=0: Setup"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK↑, In=0: S1→S10"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0
              ],
              "desc": "CLK=0, In=1: Setup"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                1
              ],
              "desc": "CLK↑, In=1: DETECTED 101 again!"
            }
          ],
          "maxGates": 8,
          "xpReward": 250
        }
      }
    },
    {
      "id": "level_19",
      "tier": "tier_6",
      "title": "Arithmetic Logic Unit",
      "objective": "Add or Subtract based on Opcode",
      "description": "The calculator core.",
      "introText": "ALU MICROARCHITECTURE: The Arithmetic Logic Unit is the computational core of every processor. It performs arithmetic, logic, and comparison operations, selected by an opcode. The ALU is where computation actually happens.",
      "physicsVisual": "alu_detailed",
      "hint": "Use MUX to select between (A+B) and (A-B) or Logic operations.",
      "availableGates": [
        "fullAdder",
        "mux2to1",
        "xor",
        "and",
        "or",
        "not"
      ],
      "inputs": 3,
      "targetTruthTable": [
        {
          "in": [
            0,
            0,
            0
          ],
          "out": [
            0,
            0
          ],
          "desc": "0 + 0 = 0"
        },
        {
          "in": [
            0,
            1,
            0
          ],
          "out": [
            1,
            0
          ],
          "desc": "0 + 1 = 1"
        },
        {
          "in": [
            1,
            0,
            0
          ],
          "out": [
            1,
            0
          ],
          "desc": "1 + 0 = 1"
        },
        {
          "in": [
            1,
            1,
            0
          ],
          "out": [
            0,
            1
          ],
          "desc": "1 + 1 = 10"
        },
        {
          "in": [
            0,
            0,
            1
          ],
          "out": [
            0,
            1
          ],
          "desc": "0 - 0 = 0 (Carry=1 means no borrow)"
        },
        {
          "in": [
            0,
            1,
            1
          ],
          "out": [
            1,
            0
          ],
          "desc": "0 - 1 = 1 (Carry=0 means borrow)"
        },
        {
          "in": [
            1,
            0,
            1
          ],
          "out": [
            1,
            1
          ],
          "desc": "1 - 0 = 1 (Carry=1 means no borrow)"
        },
        {
          "in": [
            1,
            1,
            1
          ],
          "out": [
            0,
            1
          ],
          "desc": "1 - 1 = 0 (Carry=1 means no borrow)"
        }
      ],
      "maxGates": 10,
      "xpReward": 300,
      "storyText": "ALU DESIGN PRINCIPLES: Parallel function units compute ALL operations simultaneously. A MUX tree controlled by the opcode selects which result reaches the output. Status flags (Zero, Negative, Carry, Overflow) enable conditional branching.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Arithmetic Logic Unit (ALU)",
            "definition": "A combinational circuit that performs arithmetic (add, subtract) and logic (AND, OR, XOR) operations on binary operands.",
            "why": "The ALU is the 'calculator' inside every CPU. All computations ultimately happen here.",
            "analogy": "Like a Swiss Army knife for numbers: multiple tools (operations) in one unit, selected by which one you pull out (opcode).",
            "latex": "Result = Operation(A, B, Opcode)",
            "html": null,
            "visuals": [
              {
                "type": "alu_detailed",
                "title": "ALU: Operation Select & Flags"
              }
            ]
          },
          {
            "term": "Opcode (Operation Code)",
            "definition": "A binary code that selects which operation the ALU performs. Different opcodes select ADD, SUB, AND, OR, etc.",
            "why": "The opcode comes from the instruction being executed—it's how software controls hardware.",
            "analogy": "Like a TV remote button: each button (opcode) selects a different channel (operation).",
            "visuals": [
              {
                "type": "multiplexer",
                "title": "Opcode-Controlled MUX"
              }
            ],
            "latex": "ALU_{Op}: 00=AND, 01=OR, 10=ADD, 11=SUB(example)",
            "html": null
          },
          {
            "term": "Status Flags",
            "definition": "Single-bit outputs indicating properties of the ALU result. Common flags include Zero (Z), Negative (N), Carry (C), and Overflow (V).",
            "why": "Flags enable 'conditional branching' (IF-statements). For example, a BEQ (Branch if Equal) instruction works by checking if the Zero flag is 1 after a subtraction.",
            "analogy": "Like warning lights on a car dashboard: they don't show the whole engine state, just a summary (like 'Low Oil') that requires action.",
            "latex": "Z = (Result == 0), N = Result[MSB], etc.",
            "html": null,
            "visuals": [
              {
                "type": "full_adder",
                "title": "Carry Flag (Cout)"
              }
            ]
          },
          {
            "term": "Superscalar Execution",
            "definition": "A CPU design that issues multiple instructions per clock cycle to parallel execution units. Achieves IPC (Instructions Per Cycle) greater than 1.",
            "why": "Modern CPUs execute 4-8 instructions/cycle using multiple ALUs, load/store units, and branch units in parallel.",
            "analogy": "Like a restaurant with multiple chefs—more orders completed per minute than a single chef.",
            "latex": "IPC = Instructions \\frac{completed}{Clock} cycles",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2772em;vertical-align:-0.345em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">Cl</span><span class=\"mord mathnormal mtight\">oc</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4461em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">co</span><span class=\"mord mathnormal mtight\">m</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">pl</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">d</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">cyc</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">es</span></span></span></span>"
          },
          {
            "term": "Two's Complement Subtraction",
            "definition": "Subtraction implemented as addition: A - B = A + NOT(B) + 1. Invert B and add 1 (the 'complement').",
            "why": "This lets us use the same adder hardware for both addition and subtraction.",
            "analogy": "Like going backward by going forward on a circular track—adding the complement takes you 'backward'.",
            "latex": "A - B = A + (~B) + 1",
            "html": null,
            "visuals": [
              {
                "type": "nand_to_not",
                "title": "Invert B(NOT gate)"
              }
            ]
          },
          {
            "term": "Subtraction Terminology",
            "definition": "Minuend = the number being subtracted FROM (A in A-B). Subtrahend = the number being subtracted (B in A-B). Difference = the result.",
            "why": "These terms appear in ALU documentation and help clarify operand roles in subtraction circuits.",
            "analogy": "In 10-3=7: 10 is the minuend (what you have), 3 is the subtrahend (what you take away), 7 is the difference.",
            "latex": "Minuend - Subtrahend = Difference",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">ah</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ere</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">ce</span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "Two's Complement Subtraction",
            "variables": [
              {
                "symbol": "A",
                "meaning": "Minuend (number being subtracted from)",
                "units": "Binary"
              },
              {
                "symbol": "B",
                "meaning": "Subtrahend (number being subtracted)",
                "units": "Binary"
              },
              {
                "symbol": "\\overline{B}",
                "meaning": "Bitwise complement of B",
                "units": "Binary"
              },
              {
                "symbol": "+1",
                "meaning": "Added via carry-in of adder",
                "units": ""
              }
            ],
            "meaning": "Subtraction reuses the adder by inverting B and setting carry-in to 1.",
            "derivation": "In two's complement: -B = NOT(B) + 1. So A - B = A + (-B) = A + NOT(B) + 1.",
            "example": {
              "problem": "Calculate 5 - 3 using two's complement (4-bit).",
              "given": [
                "A = 5 = 0101",
                "B= 3 = 0011"
              ],
              "steps": [
                "\\overline{B} = \\overline{0011} = 1100",
                "A + \\overline{B} = 0101 + 1100 = 10001",
                "Add carry-in (+1): already included in sum",
                "Result (4 bits): 0010 = 2",
                "Carry out = 1 (ignore for subtraction)"
              ],
              "answer": "5 - 3 = 2 (0010 in binary)"
            },
            "latex": "A - B = A + \\overline{B} + 1",
            "html": null
          },
          {
            "name": "Zero Flag",
            "variables": [
              {
                "symbol": "Z",
                "meaning": "Zero flag (1 if result is zero)",
                "units": "Logic level"
              },
              {
                "symbol": "R_{0}\\ldotsR_{n-1}",
                "meaning": "Result bits",
                "units": "Logic levels"
              }
            ],
            "meaning": "Z is 1 only when ALL result bits are 0. This is a NOR of all bits.",
            "derivation": "If any bit is 1, the OR is 1, and NOT(1)=0. Only when all bits are 0: NOT(0)=1.",
            "example": {
              "problem": "Compute Z flag for result = 0000.",
              "given": [
                "Result = 0000"
              ],
              "steps": [
                "R_{0} OR R_{1} OR R_{2} OR R_{3} = 0|0|0|0 = 0",
                "Z = \\overline{0} = 1"
              ],
              "answer": "Z = 1 (result is zero)"
            },
            "latex": "Z = \\overline{R_{0} OR R_{1} OR \\ldots OR R_{n-1}}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0917em;vertical-align:-0.2083em;\"></span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">OR</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.8033em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span></span></span>"
          },
          {
            "name": "Overflow Flag (Signed)",
            "variables": [
              {
                "symbol": "V",
                "meaning": "Overflow flag (signed overflow)",
                "units": "Logic level"
              },
              {
                "symbol": "C_{in, MSB}",
                "meaning": "Carry into the MSB position",
                "units": "Logic level"
              },
              {
                "symbol": "C_{out, MSB}",
                "meaning": "Carry out of the MSB position",
                "units": "Logic level"
              }
            ],
            "meaning": "Signed overflow occurs when the sign of the result is wrong—detected by comparing carries at MSB.",
            "derivation": "Overflow happens when two positives give negative, or two negatives give positive. This creates a carry discrepancy at MSB.",
            "example": {
              "problem": "Detect overflow: 7 + 1 in 4-bit signed (should be 8, but max is 7).",
              "given": [
                "A = 0111 (7)",
                "B= 0001 (1)"
              ],
              "steps": [
                "Sum: 0111 + 0001 = 1000 (-8 in signed!)",
                "C_{in} to bit 3: 1 (carry from bit 2)",
                "C_{out} from bit 3: 0 (no carry out)",
                "V = 1 XOR 0 = 1 (OVERFLOW!)"
              ],
              "answer": "V = 1 (7 + 1 = -8 is wrong in 4-bit signed)"
            },
            "latex": "V = C_{in, MSB} XOR C_{out, MSB}",
            "html": null
          }
        ],
        "exercises": [
          {
            "question": "Using an ALU that performs A + B when Op=0 and A - B when Op=1, compute the output for A=6, B=2, Op=1.",
            "hint": "Op=1 selects the subtraction unit or mode. Compute decimal 6 - 2.",
            "answer": {
              "steps": [
                "1. Mode: Op=1 → Subtraction.",
                "2. Operation: 6 - 2 = 4.",
                "3. Binary output (4-bit): 0100."
              ],
              "answer": "0100"
            }
          },
          {
            "question": "What are the Z and N flags for result = 11111100 (8-bit)?",
            "hint": "Z: is it all zeros? N: what's the MSB?",
            "answer": "Z = 0 (not zero), N = 1 (MSB is 1, negative in signed interpretation)"
          },
          {
            "question": "How does a single adder implement both A+B and A-B?",
            "hint": "Think about what changes: B vs NOT(B), and the carry-in.",
            "answer": "For add: Adder(A, B, Cin=0). For subtract: Adder(A, NOT(B), Cin=1). XOR gates controlled by Op can invert B."
          }
        ],
        "realWorld": {
          "context": "The ALU is the computational heart of every processor—from simple microcontrollers to supercomputers.",
          "example": "Intel Skylake has 4 integer ALUs per core for superscalar execution. NVIDIA GPUs have thousands of simplified ALUs (CUDA cores).",
          "numbers": "A 64-bit ALU add takes ~1 clock cycle (0.25ns at 4GHz). ARM NEON processes 128 bits (4×32-bit) per cycle with SIMD ALUs.",
          "connection": "This level builds the ALU—the circuit that actually computes. Combined with registers and control, you have a CPU!"
        }
      },
      "variants": {
        "easy": {
          "introText": "ALU MICROARCHITECTURE: The Arithmetic Logic Unit is the computational core of every processor.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop",
            "fullAdder"
          ]
        },
        "medium": {
          "title": "ALU with Logic Operations",
          "objective": "Add AND, OR, XOR operations",
          "description": "Extend the ALU to perform both arithmetic (ADD/SUB) and logic (AND/OR/XOR) operations based on a 2-bit opcode.",
          "introText": "Real ALUs perform multiple operations selected by an opcode. A simple ALU might have: 00=ADD, 01=SUB, 10=AND, 11=OR. Use multiplexers to select which operation's result reaches the output. x86 and ARM ALUs have dozens of operations, but the principle is the same: compute all results in parallel, then MUX-select the correct one.",
          "physicsVisual": "alu_extended",
          "hint": "Compute ADD, AND, OR results in parallel. Use a 4:1 MUX (or tree of 2:1 MUXes) controlled by 2-bit opcode to select output. For simplicity, just implement 2 ops: opcode=0 for ADD, opcode=1 for AND.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop",
            "fullAdder"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0
              ],
              "out": [
                0,
                0
              ],
              "desc": "Op=ADD: 0+0=0"
            },
            {
              "in": [
                0,
                1,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "Op=ADD: 0+1=1"
            },
            {
              "in": [
                1,
                0,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "Op=ADD: 1+0=1"
            },
            {
              "in": [
                1,
                1,
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "Op=ADD: 1+1=10"
            },
            {
              "in": [
                0,
                0,
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "Op=AND: 0&0=0"
            },
            {
              "in": [
                0,
                1,
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "Op=AND: 0&1=0"
            },
            {
              "in": [
                1,
                0,
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "Op=AND: 1&0=0"
            },
            {
              "in": [
                1,
                1,
                1
              ],
              "out": [
                1,
                0
              ],
              "desc": "Op=AND: 1&1=1"
            }
          ],
          "maxGates": 6,
          "xpReward": 320
        },
        "hard": {
          "title": "Magnitude Comparator",
          "objective": "Compare two numbers: A>B, A=B, A<B",
          "description": "Build a 2-bit magnitude comparator that outputs three signals: GT (A>B), EQ (A=B), LT (A<B).",
          "introText": "MAGNITUDE COMPARATORS are essential for conditional branches (if A > B, jump). For 2-bit numbers, compare MSB first: if A1>B1, then A>B. If A1=B1, compare LSB. The cascading comparison principle scales to any width. CPUs use optimized comparators with carry-lookahead for speed. Understanding this builds intuition for branch prediction units.",
          "physicsVisual": "magnitude_comparator",
          "hint": "For 2 bits: GT = A1·B1' + (A1⊕B1)'·A0·B0'. EQ = (A1⊕B1)'·(A0⊕B0)'. LT = A1'·B1 + (A1⊕B1)'·A0'·B0. Use XNOR for equality checks.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop",
            "fullAdder"
          ],
          "inputs": 4,
          "targetTruthTable": [
            {
              "in": [
                0,
                0,
                0,
                0
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "00 vs 00: EQ"
            },
            {
              "in": [
                0,
                0,
                0,
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "00 vs 01: LT"
            },
            {
              "in": [
                0,
                0,
                1,
                0
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "00 vs 10: LT"
            },
            {
              "in": [
                0,
                0,
                1,
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "00 vs 11: LT"
            },
            {
              "in": [
                0,
                1,
                0,
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "01 vs 00: GT"
            },
            {
              "in": [
                0,
                1,
                0,
                1
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "01 vs 01: EQ"
            },
            {
              "in": [
                0,
                1,
                1,
                0
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "01 vs 10: LT"
            },
            {
              "in": [
                0,
                1,
                1,
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "01 vs 11: LT"
            },
            {
              "in": [
                1,
                0,
                0,
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "10 vs 00: GT"
            },
            {
              "in": [
                1,
                0,
                0,
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "10 vs 01: GT"
            },
            {
              "in": [
                1,
                0,
                1,
                0
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "10 vs 10: EQ"
            },
            {
              "in": [
                1,
                0,
                1,
                1
              ],
              "out": [
                0,
                0,
                1
              ],
              "desc": "10 vs 11: LT"
            },
            {
              "in": [
                1,
                1,
                0,
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "11 vs 00: GT"
            },
            {
              "in": [
                1,
                1,
                0,
                1
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "11 vs 01: GT"
            },
            {
              "in": [
                1,
                1,
                1,
                0
              ],
              "out": [
                1,
                0,
                0
              ],
              "desc": "11 vs 10: GT"
            },
            {
              "in": [
                1,
                1,
                1,
                1
              ],
              "out": [
                0,
                1,
                0
              ],
              "desc": "11 vs 11: EQ"
            }
          ],
          "maxGates": 12,
          "xpReward": 380
        }
      }
    },
    {
      "id": "level_boss",
      "tier": "tier_6",
      "title": "The CPU Datapath",
      "objective": "Fetch, Decode, Execute",
      "description": "The final challenge. Build a simple processor.",
      "introText": "VON NEUMANN ARCHITECTURE & THE CPU DATAPATH: John von Neumann (1945) defined the stored-program computer: instructions and data share memory, fetched and executed sequentially. This is the architecture inside every computer you've ever used.",
      "physicsVisual": "cpu_datapath_detailed",
      "hint": "PC -> Instruction Memory -> Decoder -> ALU -> Register.",
      "availableGates": [
        "dFlipFlop",
        "fullAdder",
        "mux2to1",
        "and",
        "or",
        "not",
        "xor"
      ],
      "inputs": 2,
      "targetSequence": [
        {
          "in": [
            0,
            1
          ],
          "out": [
            0
          ],
          "desc": "Reset High"
        },
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ],
          "desc": "Reset Low, Ready"
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            0
          ],
          "desc": "Clock 1: Fetch"
        },
        {
          "in": [
            0,
            0
          ],
          "out": [
            0
          ],
          "desc": "Hold"
        },
        {
          "in": [
            1,
            0
          ],
          "out": [
            1
          ],
          "desc": "Clock 2: Execute & Writeback"
        }
      ],
      "xpReward": 500,
      "storyText": "You have completed the journey from electrons to computation! From simple wires to a working processor, you now understand how transistors become logic, logic becomes circuits, and circuits become the computers that power our world.",
      "physicsDetails": {
        "conceptCards": [
          {
            "term": "Von Neumann Architecture",
            "definition": "A computer architecture where program instructions and data share the same memory and bus, with sequential instruction execution.",
            "why": "This is THE architecture of modern computers. The stored-program concept allows software to be as flexible as the hardware.",
            "analogy": "Like a chef (CPU) following a recipe (program) stored in the same kitchen (memory) where ingredients (data) are kept.",
            "latex": "Memory holds both Instructions and Data",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ory</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">an</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span></span></span></span>",
            "visuals": [
              {
                "type": "decoder",
                "title": "Von Neumann: Address Decode to Memory"
              }
            ]
          },
          {
            "term": "Datapath Components (PC, IR, RF)",
            "definition": "The hardware that processes data. Key parts: PC (Program Counter) holds the current address; IR (Instruction Register) holds the current command; RF (Register File) stores temporary data; ALU performs calculations; and DM (Data Memory) stores program variables.",
            "why": "The datapath is the 'body' of the CPU—it physically moves and transforms bits according to the control unit's instructions.",
            "analogy": "Like a factory floor: the PC is the clipboard showing the next task, IR is the current task description, and RF are the workbenches where active parts are kept.",
            "latex": "Datapath = {PC, IR, RF, ALU, DM}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">RF</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">LU</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span>",
            "visuals": [
              {
                "type": "cpu_datapath_detailed",
                "title": "CPU Datapath: Fetch → Decode → Execute"
              }
            ]
          },
          {
            "term": "Control Unit",
            "definition": "The FSM that decodes instructions and generates control signals to orchestrate datapath operations.",
            "why": "The control unit is the 'brain' that tells the datapath what to do each cycle.",
            "analogy": "Like a traffic controller: it doesn't move cars (data) itself but directs the flow.",
            "latex": "Control Signals = f(Opcode)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">lS</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">na</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Op</span><span class=\"mord mathnormal\">co</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "traffic_light",
                "title": "Control Unit FSM"
              }
            ]
          },
          {
            "term": "Fetch-Decode-Execute Cycle",
            "definition": "The fundamental operation of a CPU: (1) Fetch instruction from memory, (2) Decode opcode and operands, (3) Execute the operation.",
            "why": "This cycle repeats billions of times per second in your computer, running every program.",
            "analogy": "Like reading a recipe: (1) Read the next step, (2) Understand what it says, (3) Do it.",
            "latex": "Loop: Fetch → Decode → Execute → (repeat)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">oo</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">Deco</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">re</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>",
            "visuals": [
              {
                "type": "counter_2bit",
                "title": "Fetch-Decode-Execute Sequencing"
              }
            ]
          },
          {
            "term": "Pipeline Hazards",
            "definition": "Problems that prevent the next instruction from executing in its designated clock cycle. Types: Data hazard (need result not yet computed), Control hazard (branch destination unknown), Structural hazard (resource conflict).",
            "why": "Hazards cause 'stalls' (pipeline bubbles) that reduce performance. Modern CPUs use forwarding, branch prediction, and out-of-order execution to mitigate them.",
            "analogy": "Like an assembly line where a station must wait for parts from the previous station—the whole line slows down.",
            "latex": "Stall cycles reduce effective IPC",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">St</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">cyc</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">esre</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">cee</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">ff</span><span class=\"mord mathnormal\">ec</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span></span></span></span>"
          },
          {
            "term": "IPC (Instructions Per Cycle)",
            "definition": "The average number of instructions completed per clock cycle. IPC > 1 indicates superscalar execution; IPC < 1 indicates frequent stalls.",
            "why": "Performance = IPC × Frequency. Improving IPC is as important as increasing clock speed.",
            "analogy": "Like productivity: not just how fast you work (frequency), but how many tasks you complete per hour (IPC).",
            "latex": "Performance = IPC \\times Clock_{Frequency}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">man</span><span class=\"mord mathnormal\">ce</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">Cl</span><span class=\"mord mathnormal\">oc</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal mtight\">re</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal mtight\">u</span><span class=\"mord mathnormal mtight\">e</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">cy</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>"
          }
        ],
        "formulaCards": [
          {
            "name": "Instruction Fetch",
            "latex": "IR = Memory[PC]; PC = PC + 4",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ory</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">PC</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span>",
            "variables": [
              {
                "symbol": "IR",
                "meaning": "Instruction Register (holds current instruction)",
                "units": "32 bits"
              },
              {
                "symbol": "PC",
                "meaning": "Program Counter (address of next instruction)",
                "units": "32-bit address"
              },
              {
                "symbol": "Memory[PC]",
                "meaning": "Instruction at address PC",
                "units": "32-bit instruction"
              }
            ],
            "meaning": "Fetch reads the instruction pointed to by PC into IR, then increments PC to point to the next instruction.",
            "derivation": "Instructions are 4 bytes (32 bits), so PC increments by 4. Sequential execution fetches consecutive addresses.",
            "example": {
              "problem": "If PC=0x1000, what happens during fetch?",
              "given": [
                "PC = 0x1000",
                "Memory[0x1000] = ADD R1, R2, R3"
              ],
              "steps": [
                "IR = Memory[0x1000] = ADD R1, R2, R3",
                "PC = 0x1000 + 4 = 0x1004",
                "Ready for next fetch at 0x1004"
              ],
              "answer": "IR holds ADD instruction, PC now points to 0x1004"
            }
          },
          {
            "name": "Critical Path (Single-Cycle)",
            "variables": [
              {
                "symbol": "T_{cycle}",
                "meaning": "Clock period",
                "units": "nanoseconds"
              },
              {
                "symbol": "t_{PC}",
                "meaning": "PC read time",
                "units": "ns"
              },
              {
                "symbol": "t_{IM}",
                "meaning": "Instruction memory access",
                "units": "ns"
              },
              {
                "symbol": "t_{RF}",
                "meaning": "Register file read",
                "units": "ns"
              },
              {
                "symbol": "t_{ALU}",
                "meaning": "ALU computation",
                "units": "ns"
              },
              {
                "symbol": "t_{DM}",
                "meaning": "Data memory access",
                "units": "ns"
              },
              {
                "symbol": "t_{WB}",
                "meaning": "Writeback to register",
                "units": "ns"
              }
            ],
            "meaning": "In single-cycle design, the clock period must accommodate the longest instruction path (typically LOAD).",
            "derivation": "LOAD uses all stages: PC→IM→RF→ALU(address)→DM→RF(writeback). Clock must be this slow.",
            "example": {
              "problem": "Calculate minimum cycle time: t_PC=0.1ns, t_IM=2ns, t_RF=1ns, t_ALU=2ns, t_DM=2ns, t_WB=1ns.",
              "given": [
                "All delay values in nanoseconds"
              ],
              "steps": [
                "Sum = 0.1 + 2 + 1 + 2 + 2 + 1 = 8.1ns",
                "T_{cycle} ≥ 8.1ns",
                "f_{max} = \\frac{1}{8}.1ns ≈ 123MHz"
              ],
              "answer": "Minimum cycle = 8.1ns, max frequency ≈ 123MHz"
            },
            "latex": "T_{cycle} ≥ t_{PC} + t_{IM} + t_{RF} + t_{ALU} + t_{DM} + t_{WB}",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">cyc</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">e</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">PC</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">RF</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">A</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">LU</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>"
          },
          {
            "name": "Pipeline Speedup",
            "latex": "Speedup ≈ n (for n-stage pipeline)",
            "html": "<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Sp</span><span class=\"mord mathnormal\">ee</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">or</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span></span></span></span>",
            "variables": [
              {
                "symbol": "n",
                "meaning": "Number of pipeline stages",
                "units": "count"
              },
              {
                "symbol": "Speedup",
                "meaning": "Throughput improvement vs single-cycle",
                "units": "factor"
              }
            ],
            "meaning": "An n-stage pipeline can ideally execute n instructions simultaneously, achieving n× throughput.",
            "derivation": "Each stage is 1/n of the original cycle. After filling, one instruction completes per short cycle.",
            "example": {
              "problem": "A 5-stage pipeline (IF, ID, EX, MEM, WB) vs single-cycle. Theoretical speedup?",
              "given": [
                "n = 5 stages"
              ],
              "steps": [
                "Single-cycle: 1 instruction per long cycle",
                "Pipeline: 5 instructions in-flight simultaneously",
                "After 5 cycles to fill, 1 completes each short cycle",
                "Speedup ≈ 5×"
              ],
              "answer": "~5× throughput improvement (ideal case, ignoring stalls)"
            }
          }
        ],
        "exercises": [
          {
            "question": "List the 5 classic pipeline stages and what each does.",
            "hint": "IF = Instruction Fetch, ID = ..., EX = ..., MEM = ..., WB = ...",
            "answer": "IF: Fetch instruction. ID: Decode and read registers. EX: Execute ALU operation. MEM: Access data memory. WB: Write result to register."
          },
          {
            "question": "Why can't you just make a 100-stage pipeline for 100× speedup?",
            "hint": "Think about what happens with branches and data dependencies.",
            "answer": "Hazards! Branch mispredictions flush the pipeline (wasting cycles). Data dependencies cause stalls. More stages = more vulnerability to these problems. Diminishing returns."
          },
          {
            "question": "A CPU runs at 4GHz and achieves IPC=3.5 (instructions per cycle due to superscalar). How many instructions per second?",
            "hint": "IPS = IPC × frequency. Remember 1 GHz = 10⁹ Hz (cycles per second).",
            "answer": {
              "steps": [
                "1. Frequency: 4 GHz = 4 × 10⁹ cycles/sec.",
                "2. Formula: IPS = 3.5 instructions/cycle × (4 × 10⁹ cycles/sec).",
                "3. Calculate: 3.5 × 4 = 14.",
                "4. Result: 14 × 10⁹ IPS = 14 Billion Instructions Per Second."
              ],
              "answer": "14 Billion Instructions Per Second"
            }
          }
        ],
        "realWorld": {
          "context": "You now understand the architecture inside every computer—from your phone to data centers.",
          "example": "Apple M2: 5nm, 20 Billion transistors, 8-core CPU + 10-core GPU, 8-wide decode, 600+ instruction reorder buffer.",
          "numbers": "Intel Core i9-13900K: 5.8GHz, 24 cores, >14 pipeline stages, executes ~6 instructions/cycle/core.",
          "connection": "🎉 CONGRATULATIONS! You've journeyed from silicon atoms to a working CPU. You now understand how electrons become apps, how physics becomes software, how gates become Google. The digital world is no longer magic—it's engineering you understand."
        }
      },
      "variants": {
        "easy": {
          "introText": "VON NEUMANN ARCHITECTURE & THE CPU DATAPATH: John von Neumann defined the stored-program computer.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop",
            "fullAdder"
          ],
          "maxGates": 10
        },
        "medium": {
          "title": "Instruction Decoder",
          "objective": "Decode opcode to control signals",
          "description": "Build an instruction decoder that converts a 2-bit opcode into control signals for ALU operation, register write enable, and memory access.",
          "introText": "The INSTRUCTION DECODER is the brain of the CPU control unit. It reads the opcode field from the instruction and generates control signals that orchestrate the datapath: which ALU operation to perform, whether to write to registers, whether to access memory. A 2-bit opcode gives 4 instructions: 00=ADD, 01=SUB, 10=LOAD, 11=STORE. Each needs different control signals activated.",
          "physicsVisual": "instruction_decoder",
          "hint": "This is essentially a 2-to-4 decoder with additional logic. For each opcode, determine which control signals should be HIGH. ALU_op for arithmetic, RegWrite for register destination, MemRead/MemWrite for memory ops.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop",
            "fullAdder"
          ],
          "targetTruthTable": [
            {
              "in": [
                0,
                0
              ],
              "out": [
                0,
                1,
                0,
                0
              ],
              "desc": "ADD: ALU_Sub=0, RegWrite=1, MemRead=0, MemWrite=0"
            },
            {
              "in": [
                0,
                1
              ],
              "out": [
                1,
                1,
                0,
                0
              ],
              "desc": "SUB: ALU_Sub=1, RegWrite=1, MemRead=0, MemWrite=0"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0,
                1,
                1,
                0
              ],
              "desc": "LOAD: ALU_Sub=0, RegWrite=1, MemRead=1, MemWrite=0"
            },
            {
              "in": [
                1,
                1
              ],
              "out": [
                0,
                0,
                0,
                1
              ],
              "desc": "STORE: ALU_Sub=0, RegWrite=0, MemRead=0, MemWrite=1"
            }
          ],
          "maxGates": 8,
          "xpReward": 1000
        },
        "hard": {
          "title": "2-Stage Pipeline",
          "objective": "Fetch while Executing",
          "description": "Build a simple 2-stage pipelined processor: Stage 1 fetches the next instruction while Stage 2 executes the current one. Double the throughput!",
          "introText": "PIPELINING is the key to high-performance CPUs. Instead of completing one instruction before starting the next, we overlap them: while instruction N executes, instruction N+1 is being fetched. This doubles throughput (instructions per cycle) without increasing clock speed. Modern CPUs have 10-20+ pipeline stages! You'll build the simplest version: 2 stages with proper handshaking between Fetch and Execute units.",
          "physicsVisual": "pipeline_2stage",
          "hint": "Use two sets of registers: IR (Instruction Register) holds the fetched instruction, and a PC (Program Counter) tracks what to fetch next. On each clock: PC increments (fetch stage) while IR's instruction executes (execute stage). A MUX handles the initial fill of the pipeline.",
          "availableGates": [
            "transistor",
            "not",
            "and",
            "or",
            "nand",
            "nor",
            "xor",
            "mux2to1",
            "srLatch",
            "dFlipFlop",
            "fullAdder"
          ],
          "targetSequence": [
            {
              "in": [
                0,
                1
              ],
              "out": [
                0,
                0
              ],
              "desc": "Reset: Clear pipeline"
            },
            {
              "in": [
                0,
                0
              ],
              "out": [
                0,
                0
              ],
              "desc": "Ready: Pipeline empty"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "CLK1: Fetch I1 (pipeline filling)"
            },
            {
              "in": [
                0,
                0
              ],
              "out": [
                0,
                1
              ],
              "desc": "Hold: I1 in IR"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "CLK2: Execute I1, Fetch I2 (full pipeline)"
            },
            {
              "in": [
                0,
                0
              ],
              "out": [
                1,
                0
              ],
              "desc": "Hold: I2 in IR"
            },
            {
              "in": [
                1,
                0
              ],
              "out": [
                1,
                1
              ],
              "desc": "CLK3: Execute I2, Fetch I3 (steady state)"
            }
          ],
          "maxGates": 15,
          "xpReward": 1500
        }
      }
    }
  ]
}